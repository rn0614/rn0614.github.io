<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[posting]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>posting</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 22 Dec 2025 14:03:00 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 22 Dec 2025 14:02:39 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[React 프로젝트 필수 라이브러리 12선]]></title><description><![CDATA[현대 React 프로젝트의 표준 스택인 12개 라이브러리의 기능, 사용법, 실무 예시를 정리합니다. date-fns부터 react-hook-form까지 타입 안전성과 개발 생산성에 중점을 둔 구성입니다.]]></description><link>300-resources/310-개발공부/311-front/react_프로젝트_필수_라이브러리_12선.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/React_프로젝트_필수_라이브러리_12선.md</guid><pubDate>Mon, 22 Dec 2025 14:02:01 GMT</pubDate></item><item><title><![CDATA[Drawing 2025-12-20 16.50.09]]></title><description><![CDATA[<img src="800-references/802-excalidraw/drawing-2025-12-20-16.50.09.excalidraw.svg" target="_self">]]></description><link>800-references/802-excalidraw/drawing-2025-12-20-16.50.09.excalidraw.html</link><guid isPermaLink="false">800 References/802 Excalidraw/Drawing 2025-12-20 16.50.09.excalidraw.svg</guid><pubDate>Mon, 22 Dec 2025 08:28:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[LLM의 이해]]></title><description><![CDATA[LLM은 2개의 파일로 구성
Paramter file
run file
인공신경망의 갯수로 7B, 14B 으로 인공신경망의 갯수를 나타냄
pre-training : 시중에 나와있는 모델
fine-tunning : 내가 원하는대로 한번 더 재학습 시키는 방식
reinforcement learning : 사용자의 피드백으로 강화학습
영어로 의미를 가진 최소 단위로 단어가 아닌 복합 언어의 갯수 예를들어 incomponent는 in+ component로 2단어로 해석 가능
llm이 한번에 이해할 수 있는 토큰의 갯수를 token limit 이라고 하며 현재 llm이 이해할 수 있는 대화 맥락 정보를 context window라고 함.보통 한토큰은 영어기준으로 약 4자 정도 되며 gpt-4 가 최대 128,000 개이므로 대략 32000개의 단어를 이해할 수 있는 상황임. chatgpt/ claude 같은경우는 fine-tunning을 허용하지 않기 때문에 gpts같이 RAG과 유사한 형태의 학습을 시켜서 사용함. LLM은 텍스트요약, 확장, 재구성에는 유리하지만 수학/ 이미지생성 등의 특수기능에 능하지 않음.
이런 특수한 기능을 수행할 때 정해진 특정 FUNCTIO(API)를 수행하도록 하는게 FUNCTION CALL CLAUDE에서 MCP를 내놓으면서 이 FUNCTION CALL 의 기능의 규격을 제시함.
Andrew Karpathy 는 LLM을 운영체계에 비유해서 얘기함
LLM =&gt; OS
CONTEXT WINDOW =&gt; RAM
FUNCTION CALL =&gt; 외부장치
VECTOR DB =&gt; 디스크
llm에 지식을 추가하는 방식은 아래 2개임. in-context learning을 통해서 프롬프트에 직접 입력하는 방식
direct 기술(rag 기술로 vector db를 통해서 사용) / embedding된 데이터중 가장 유사한 데이터를 가져와서 같이 질문하여 답변 생성
RAG을 최적화 하기 위해서는 Chunk 단위를 유의미하게 쪼갤 수 있어야하고 rerank 전략이나 context overflow를 방지하기 위한 장치도 필요함.]]></description><link>300-resources/310-개발공부/316-ai/llm의-이해.html</link><guid isPermaLink="false">300 Resources/310 개발공부/316 AI/LLM의 이해.md</guid><pubDate>Sun, 21 Dec 2025 19:12:47 GMT</pubDate></item><item><title><![CDATA[MCP 관리 툴 프로그램]]></title><description><![CDATA[MCP 관리툴 프로그램으로 다양한 MCP 도구를 효율적으로 관리하고 설정하는 방법을 알아보세요.]]></description><link>100-projects/_archive/mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">100 Projects/_archive/MCP 관리 툴 프로그램.md</guid><pubDate>Sun, 21 Dec 2025 19:12:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Clean Code]]></title><description><![CDATA[클린 코드를 위한 베스트 프랙티스와 최적화 기법을 소개합니다. 전역공간 최소화, 임시변수 제한, 호이스팅 등 다양한 팁을 확인하세요.]]></description><link>300-resources/310-개발공부/311-front/clean-code.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Clean Code.md</guid><pubDate>Sun, 21 Dec 2025 14:03:38 GMT</pubDate></item><item><title><![CDATA[obsidian plugin Custom사용법]]></title><description><![CDATA[obsidian에서 plugin을 custom 해서 사용해보자]]></description><link>100-projects/101-지식관리-pipelin만들기/02-obsidian-plugin-custom사용법.html</link><guid isPermaLink="false">100 Projects/101 지식관리 pipelin만들기/02 obsidian plugin Custom사용법.md</guid><pubDate>Sun, 21 Dec 2025 13:38:57 GMT</pubDate></item><item><title><![CDATA[GitHub_Release_자동화_가이드]]></title><description><![CDATA[GitHub Release 자동화 가이드를 통해 소프트웨어 배포의 효율성을 높이고, 안정적인 버전 관리를 배워보세요.]]></description><link>300-resources/310-개발공부/313-cicd/github-release-자동화-가이드.html</link><guid isPermaLink="false">300 Resources/310 개발공부/313 CICD/GitHub Release 자동화 가이드.md</guid><pubDate>Sun, 21 Dec 2025 13:37:31 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[github release 적용]]></title><link>100-projects/101-지식관리-pipelin만들기/github-release-적용.html</link><guid isPermaLink="false">100 Projects/101 지식관리 pipelin만들기/github release 적용.md</guid><pubDate>Sun, 21 Dec 2025 12:31:30 GMT</pubDate></item><item><title><![CDATA[VScode_디버깅설정]]></title><description><![CDATA[
문제의 본질은 하나의 IDE에서 BACK, FRONT를 동시에 DEBUGGING해야 편하다는 점이다. 물로 NEXTJS 의 경우 크롬창에서 디버깅이 가능하지만 BACK단 로직은 직접적으로 VSCODE에서 디버깅하기가 편하다는 장점이 있다. 배경지식 Vscode 관련해서 디버깅 모드의 관리는 root dir의 .vscode/launch.json 파일에서 관리한다.
해당폴더 내 configuration 에서는 각각 실행환경을 정의한다. // .vscode/launch.json
{ "version": "0.2.0", "configurations": [ // backend debugging 설정(Spring boot) { "type": "java", "name": "SpringBackApplication", "request": "launch", "mainClass": "com.backproject.springback.SpringBackApplication", "projectName": "spring-back", "cwd":"${workspaceFolder}/spring-back" // 백엔드 위치선언 }, // frontend debugging 설정(Next.js) { "name": "Next.js: debug full stack", "type": "node-terminal", "request": "launch", "command": "npm run dev", "cwd": "${workspaceFolder}/front", // 전체 root위치 선언(node.js) "serverReadyAction": { "pattern": "- Local:.+(https?://.+)", "uriFormat": "%s", "action": "debugWithChrome", "webRoot": "${workspaceFolder}/front" // 클라이언트 위치선언(웹 리소스) } } ]
}
독학을 하는 입장에서 비빌 곳은 디버깅이다. 물론 CS적 지식을 알아야하는 부분도 있지만 에러 발생 시 가장 먼저 필요한 행동은 "어디서 발생했는지" 를 찾는 것이다. 그리고 이런 부분에 대한 노동도 시간이 많이든다.
결국 클린코드라는 것도 이런 고장난 부분을 빠르게 찾기 위한 네이밍, SOLID원칙 등이 생겨난 것이라고 생각이 든다.디버깅설정]]></description><link>300-resources/310-개발공부/319-etc/vscode_디버깅설정.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/VScode_디버깅설정.md</guid><pubDate>Sun, 21 Dec 2025 10:38:20 GMT</pubDate></item><item><title><![CDATA[VSCODE 문자열을 원래 문자열과 함께 특정형태 replace]]></title><description><![CDATA[
일반적인 vscode의 문자열 replace는 문자 자체를 replace한다. 하지만 정규식으로 찾은 문자열은 이전형식을 이용해서 replace해야하는 경우가 있다. 해당 경우에 ()로 감싸면 $1으로 해당 내용을 순서대로 pointer로 사용할 수 있다. 이전의 날짜 형식은 일까지만 사용했으나 일자를 시,분,초까지 표기해야하는 상황이 발생하였다. target문자열 : last_modified_at: yyyy-mm-dd 형식이어서 정규식을 last_modified_at: \d{4}-\d{2]-\d{2} 형식으로 찾았다.
이후 해당 문자열 바로 뒤에 default 시간으로 00:00:00 을 붙이기 위해 정규식을 ()로 감싸고 대체하는 문자열에 해당 문자열을 가르키는 $1을 앞에 추가해서 replace를 진행하였다.
<img src="800-references/801-image/2025/08/vscode-문자열을-원래-문자열과-함께-특정형태-replace-1.png" target="_self">1]]></description><link>300-resources/310-개발공부/319-etc/vscode-문자열을-원래-문자열과-함께-특정형태-replace.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/VSCODE 문자열을 원래 문자열과 함께 특정형태 replace.md</guid><pubDate>Sun, 21 Dec 2025 10:38:16 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[VSCode 단축키]]></title><description><![CDATA[
개발을 하다보면 사람마다 속도차이가 난다. 누구는 엑셀로 몇초만에 대량의 데이터를 정리하고 합산하지만 누구는 하루종일 걸리기도 한다. 하지만 개발자라면 초기에 한번은 무조건 집고 넘어가고 또 반복된 작업을 하고 있다면 더 좋은 방법이 있는지 검색해봐야한다.(공유까지 한다면 더 좋지만 혼자만 공유하는건 오래 못가는거 같다./ 그렇다면 나한테 남는 방식으로 저장하는 형태를 택하겠다고 생각했다.)
하지만 엑셀자격증은 있지만 VSCode자격증, Eclipse자격증 같은건 없으므로 본인이 신경쓰지 않는다면 낡고 뒤쳐진 방법을 고수하는 형태가 되기도 한다.
단, 너무 매몰될 필요는 없다고 생각한다. 1달에 한번 쓸까말까한 window메뉴 탭에 있어서 금방 실행하는 방식을 굳이 단축키로 무조건 실행하는게 무슨 의미가 있겠는가?
(alt + shift +a 로 블록주석이 가능하지만 팀원 전부 ctrl +/ 로 해결하는데 이럴때 다르게 써봤자 의미 없다.)
]]></description><link>300-resources/310-개발공부/319-etc/vscode-단축키.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/VSCode 단축키.md</guid><pubDate>Sun, 21 Dec 2025 10:38:12 GMT</pubDate></item><item><title><![CDATA[ngrock, n8n, docker-desktop]]></title><description><![CDATA[n8n을 셀프 호스팅으로 설정하고 ngrok을 통해 외부 API와 연결하는 방법을 소개합니다.]]></description><link>300-resources/310-개발공부/319-etc/ngrock,-n8n,-docker-desktop.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/ngrock, n8n, docker-desktop.md</guid><pubDate>Sun, 21 Dec 2025 10:38:08 GMT</pubDate></item><item><title><![CDATA[Cursor rule 관련]]></title><description><![CDATA[
ai 의 system prompt와 같이 cursor에서는 cursor rules 라는 방식을 사용하여 코드의 룰을 정의하고 개발한다.
해당 rule을 추가하면 .cursor/rules 폴더에 mdc 파일이 생성된다.
![](800 References/801 Image/2025/08/Cursor rule 관련-1.png)rule의 type에는 다음과 같이 사용한다.
Always: 항상 context 포함
Auto Attached: 특정 파일 확장자나 네이밍 패턴에 맞게 사용 **/*.tsx
Agent Request: 포함여부를 문맥에 따라서 ai가 결정(제목이 매우 중요)
Manual: @로 컨텍스에 포함될 때만 사용
![](age%20<img src="800-references/801-image/2025/08/cursor-rule-관련-2.png" target="_self">1이 적용될 때 자동으로 적용됨. 스코프위치에서 .cursor/rules를 사용하면 해당 위치에서의 rule을 정의할 수 있음.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://cursor.directory/" target="_self">https://cursor.directory/</a> cursor rules를 기본적으로 잘 사용하기 위한 참고용 rules를 제공해주는 사이트]]></description><link>300-resources/310-개발공부/319-etc/cursor-rule-관련.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/Cursor rule 관련.md</guid><pubDate>Sun, 21 Dec 2025 10:38:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[COMMIT MESSAGE규칙]]></title><description><![CDATA[
1인개발자여도 PR을 할 때 COMMIT 메세지는 중요하다. 처음 메세지를 적을 때 단순하게 뭘 개발했다라고만 관리를 했었는데 프로젝트를 진행하면서 점점 이전에 기능을 뺄때도 있고 이 코드는 언제 수정했는지 확인하면서 왜 이 코드를 수정했는지 알 수 없는 경우도 나왔다. 특히 프로젝트가 길어지면서 이런 부분에서 내 COMMIT 메세지를 개선해야할 필요성을 느꼈다. 현재 내가 다니는 회사에서는 사용자가 요청한 명칭을 가지고 COMMIT을 적용하고 있다. 이런식으로 하면 요청자가 보낸 제목과 COMMIT메세지가 같아 단기적인 수정에는 문제가 없지만 장기적으로 같은 요청제목으로 사용자가 보낼땐 요청번호를 한번더 확인하거나 조금만 지나도 제목만으로 요청이 무엇인지 파악하기 힘들다는 단점이 있다.
COMMIT 메세지를 표준화해야한다. 우선 여러 블로그를 다녀본 결과 아래 블로그에서 처리한 내용에 따라서 정리한게 많다. 우선 해당방식으로 구현한 내용에 대해서 알아보자
가장 많이 쓰는 전통적인 conventional Commit 방식으로 따라간다. 무엇이든 처음할 때는 전통적인것을 따라가보고 내가 필요한 것을 추가하거나 개선하는 방향으로 하는게 효율이 좋았다.
(나의 경우는 post로 posting할 때 쓰는 부분도 추가)
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.conventionalcommits.org/en/v1.0.0/" target="_self">https://www.conventionalcommits.org/en/v1.0.0/</a>
template가 있으므로 어느정도 자동으로 채우는 템플릿을 맞추는게 좋다. 루트폴더에 다음과 같이 txt 폴더를 만들고 나서 global 설정을 해주면 commit 창에서 자동으로 메세지가 나오고 git commit을 쳤을 때 자동으로 템플릿이 나오게 된다.<br>
<img src="800-references/801-image/2025/08/commit-message규칙-1.png" target="_self">1
git config --global commit.template ./template.txt
// template.txtfeat: 제목 본문위치
feat:	새로운 기능 추가
fix:	버그 수정
docs:	문서 수정 (README, 주석 등)
style:	코드 스타일 변경 (포매팅, 세미콜론 추가 등 기능 변경 없음)
refactor:	코드 리팩토링 (기능 변경 없이 코드 개선)
perf:	성능 개선
test:	테스트 코드 추가/수정
chore:	빌드 시스템, 패키지 매니저 설정 변경 (코드 수정 X)
ci:	CI/CD 관련 설정 변경
build:	빌드 관련 파일 수정 (예: package.json, webpack 설정 변경)
revert:	이전 커밋을 되돌림
infra:	인프라 관련 수정 (서버, 배포 설정 등) Resolves: #123
]]></description><link>300-resources/310-개발공부/319-etc/commit-message규칙.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/COMMIT MESSAGE규칙.md</guid><pubDate>Sun, 21 Dec 2025 10:38:02 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Arrray 내장 메서드]]></title><description><![CDATA[실제 배열이 아니고 배열의 동작을 흉내낸 특수한 객체이다. 실제로는 아래와 같이 숫자값을 key로 갖는 배열이다. 이 배열의 최대 길이는 232 -1 이므로 너무 긴 배열의 경우 주의하도록 하자객체이므로 자바스크립트로 강제로 중간값을 없애는 empty를 만들 수 있는데 웬만하면 이런 특징을 사용하지 않도록 한다.console.log(Object.getOwnPropertyDescriptor([1,2,3]));
/*
{ '0':{value:1, writable:true, enumerable: true, configurable: true}, '1':{value:2, writable:true, enumerable: true, configurable: true}, '2':{value:3, writable:true, enumerable: true, configurable: true}, length:{value:3, writable:true, enumerable: false, configurable: false},
}
*/
빠르게 만들어진 언어다보니 원본 객체의 보장을 하지 않는 메서드들이 일부 있다. 따라서 JS를 쓸때는 2가지를 중점적으로 봐야한다. 1.원본배열의 변화유무, 2.반환값 <a href=".?query=tag:추가작성필요" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#추가작성필요">#추가작성필요</a> mutator method : 원본배열 변경메서드
splice, pushaccessor method : 새 배열 생성메서드
concat, // 배열의 생성
const list = (new Array(10)).fill(0); /* new Array(1,2,3) = [1,2,3] Array.of(1) =&gt; [1] Array.from({length} ,(_ , i) =&gt; i) =&gt; [0, 1, 2]
*/ // list는 object객체임.
typeof list // retun 'object' //length
list.length // 배열의 길이 // isArray
Array.isArray(list) // true // indexOf , inclueds
[1,2,3,4].indexOf(2, _) // 1 _는 시작위치
[1,2,3,4].includes(3) // true [2,23,4].push('test') /// return list.length =4 [2,23,4].pop() // return 2 [2,23,4].unshift('test','te') /// return list.length =5 [2,23,4].shift() /// return list.length =2 [1,2,3].concat([4,5,6],7) // [1,2,3,4,5,6,7] , 될수있으면 spread쓸것 // join
['가','나','다'].join(":") // return "가나다" // fill *원본배열변경*
[1,2,3,4,5].fill(0) // [0,0,0,0,0] // splice *원본배열변경*
const originArr = [1,2,3,4,5]
const targetItem = originArr.splice(1,1) //return [2], originArr = [1,3,4,5]
// 하나만 제거시 요소를 indexOf로 특정하고 splice로 제거
// filter는 전체 요소 제거 // slice
const originArr = [1,2,3,4,5]
const targetItem = originArr.slice(1,1) //return [2], originArr = [1,2,3,4,5]
const reverseItem = originArr.slice(-1) //return [5], originArr = [1,2,3,4,5] // flat
[1,[2,3,[4,[5]]]].flat(2) // return [1,2,3,4,[5]] , dept에 따라서 깊이, default는 1 // sort *원본배역*
[2,8,1,5].sort((a,b)=&gt; a-b) // return undefined , originArr =[1,2,5,8] // find
const targetItem = list.find((item)=&gt;{return item.id == targetId}) // return Item // findIndex
const targetItem = list.findIndex((item)=&gt;{return item.id == targetId}) // return index as number // some
const targetItem = list.some((item)=&gt;{return item.id == targetId}) // return boolean // every
const targetItem = list.every((item)=&gt;{return item.id == targetId}) // return boolean // filter
const targetItem = list.filter((item)=&gt;{return item.id == targetId}) // return Item[]
const usefullFilter = list.filter((val, i, self)=&gt;self.indexOf(val)===i); // 일반적인 중복제거 방법이지만 객체의 요소를 비교해서 중복을 제거해야할 때 사용하면 좋다 // map
const targetItem = list.map((item)=&gt;{return {...item, value:item.value+1}}) // return Item[] // flatMap = map().flat(1) 과 동일
list.map((item)=&gt;item.split('')).flat(); // reduce
const targetItem = list.reduce((acc,cur)=&gt;(acc+cur), 0) // return 최종값
const usefullReduce = list.reduce((arr, cur)=&gt;{ acc[cur] = (acc[cur]|| 0) + 1 return arr
}, {}) // 최종적으로 list에 있는 요소들의 숫자를 {key:value} 형태로 가지고 있음 // forEach는 리턴값이 없고 map은 리턴배열을 받음
const forEachResult = list.forEach((item)=&gt;{ return item}) // undefined
const mapResult = list.map((item)=&gt;{ return item}) // [1,2,3]
]]></description><link>300-resources/310-개발공부/319-etc/arrray-내장-메서드.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/Arrray 내장 메서드.md</guid><pubDate>Sun, 21 Dec 2025 10:37:57 GMT</pubDate></item><item><title><![CDATA[API 설계 원칙]]></title><description><![CDATA[
API는 다른 서비스를 개발하기 위한 중간 제품으로 인지된다. API가 변화하게 될 때 해당 API를 사용한 모든 서비스에 문제를 야기할 수 있음.
협업 : 다양한 이해관계자들의 충분한 합의가 필요함.
성과 : 가치, 도메인을 중심에 둘 것 (쓸모있는 것)
기술 : 기술 선택은 용도에 맞출 것(기술중심이 아닐것)
약속 : API는 고객과의 약속임. 큰 책임을 고려할것
문서 : 무엇보다 문서가 우선될 것
개발부터하고 그 결과를 문서로 생성함
개발이 변경되면 자동생성기가 문서를 변화시킴
문서를 기반으로 개발코드를 만들어야함. 5대 원칙에 근거하여 API문서가 먼저 작성됨
도메인이나 고객의 변화에 따라 API의 변화가 생겨날
실제 개발되는 코드나 언어와 무관하게 문서가 운영됨 개발을 못하는 기획과 할경우 개발자가 API DOC문서작성의 주체가 되어 개발중심으로 되는 경우가 문제임.
기획자가 API설계는 할 줄 알아야함.
ADDR프로세스에 따라 작성 도메인분석을 통한 작업스토리 추출 및 디지털기능식별(웹으로 가능한지여부) : EX) 나는 무엇에 관심이 있어서 그걸 CALL해서 어떤 데이터를 받는다. EX) 헬스자체는 못하지만 헬스장 운동 기록은 디지털기능으로 가능 작업스토리별 액티비티 단계 캡처 EX) 절차 프로세스 확인 : 장바구니 담기 -&gt; 포인트사용 -&gt; 결제 이벤트스토밍의 네러티브를 이용한 API경계 실별(애그리거트 분리) 식별된 바운디드컨텍스트 내의 구체적인 개별 API정의 REST구조에 맞는 실제 설계 DDD등 여러 기법 동원 유저스토리매칭, 작업스토리, 스토리스토밍, 유즈케이스, 예제매핑 등 하나의 규격, 많은 API를 기술 가능하고 사용이 많음. 메소드 적용을 얼마나 엄격하게 할 것인가? PUT, POST 멱등성의 범위를 어떻게 정의할 것인가? 요청 변수는 공통 포멧을 적용할 것인가? 인증, 인가, 상태를 어떻게 처리할 것인가? 모든 응답의 공통포멧을 적용할 것인가? 응답의 상태별 공통 포멧을 적용할 것인가? 정상응답의 페이로드는 공통 포멧을 적용할것인가? OBJECT? ,LIST? 응답코드의 공통 기준을 적용할 것인가? 하이퍼미디어를 적용할것인가? (동적 ENDPOINT, 실행해봐야 ENDPOINT를 알 수 있음.)/ 해태우스 비지니스를 잘 이해했다 = 돈을 많이 벌고 있다.
대부분 돈을 많이 벌고 있지 않음.
돈 벌고 있는 대부분도 왜 돈이 벌렸는지 잘 모름
사업당사자도 비지니스로서의 도메인을 잘 이해하지 못함.
따라서 개발자가 비지니스를 잘 이해한다는건 거의 불가능에 가까움. 관찰해보니 그 일을 실제하고 있음.
비지니스 경쟁자가 어떤일을 하고 있음
비지니스 관련 법령이나 암묵지로 해야할 일이 있음 크게 돈 되는 부분 - 핵심 하위 도메인
작게 돈 되는 부분 - 일반 하위 도메인
돈 벌려면 해야하는 부분 - 지원 하위 도메인 뭐가 왜 돈 되는지 사업 당사자도 잘 모름
핵심 하위 도메인이라고 생각했던게 도메인 자체가 아니었음
일반 하위 도메인이라고 생각한 부분으로 회사가 돌아감 ex) 쇼핑몰로 돈벌려고 했는데 AWS로 돈범
지원하위 도메인이라고 생각한 부분으로 회사가 돌아감 ex) cs게시판 잘 운영하다보니 cs회사가 독립됨 돈을 벌려면 (개발)비용을 최적화해야 함.
비용이 절약되는 구조가 국내 기업 대부분은 핵심 도메인 구현에 외주업체 사용
주요 기업의 잉여자본금은 외부 투자사에 위임함.
개발 내부에도 많은 외주 인원들이 상주함.
더 나아가 ㅎ인공지능 등 핵심 개발물 진행에 주도적인 외주 인원도 많음.
ex) ai스타트업 대부분 openAI api임, 오픈소스도 사실상 외주솔루션 핵심 도메인은 돈을 벌어야하기 때문에 고도화된 기술을 사용할수록 대응이 느려져 오히려 모순적, 핵심도메인이야말라 saas나 외주의 경연장 비지니스도메인용어가 투명하지 않음. (새로운 개념의 언어가 생겨남)
도메인 전문가가 IT서비스에 대한 이해가 없는 경우가 흔함. IT프로젝트를 도메인 전문가가 주도할 수 없음. =&gt; 결국 유비쿼터스 언어는 도메인이 IT에 수용되는 형태로 정의됨. 서로 공유하기 쉽고 편집하기 쉬운 온라인 동시 편집환경이 좋음
구글 스프레드시트는 누구나 접근하기 좋은 구조
그로서리를 가장 많이 사용하는 곳은 기획서 작성임
따라서 실질적인 그로서리는 피그마 내부에서 정의되는 경우가 대부분 도메인지식에서 코드로 단반향으로 흐르는 것처럼 묘사
실제로는 개발팀의 도메인을 바탕으로 작성된 서비스를 도메인팀이 사용한 피드백을 바탕으로 수정됨
애자일 이론에서도 강조하듯 가장 확실한 커뮤니케이션은 제품 출시임.
개발팀의 '이거대로 하면 이런 문제가 있는데요? 어 그러네요.'의 과정이 보여짐
유비쿼터스 언어는 중복된의미의 단어를 하나로 통합하는 과정 (사용자, 유저, 계정) 개념을 명확하게하지 않고 불러주는대로 만들다보면 위와같이 같은 개념을 다른말로 만들어놓는 불상사 발생
도메인 전문가에게 중요한건 도메인이 잘 전달되었나가 아님. 기존의 도메인을 완전 다르게 표현 혹은 다른 기능을 전달해도 그게 도메인 내에서 가치가 있으면 관심있음
스프린트에서 도메인에게 전달할건 도메인 내에서 가치를 발휘하는가]]></description><link>300-resources/310-개발공부/319-etc/api-설계-원칙.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/API 설계 원칙.md</guid><pubDate>Sun, 21 Dec 2025 10:37:52 GMT</pubDate></item><item><title><![CDATA[실시간 데이터 전송 기술 SSE vs WebSocket]]></title><description><![CDATA[
단방향 통신:
서버가 클라이언트로 지속적으로 업데이트를 전송하는 기술입니다. 클라이언트는 서버와의 연결을 유지하며 새로운 데이터를 수신합니다.
HTTP 기반:
기존 HTTP/HTTPS 프로토콜을 활용하여 구현이 상대적으로 간단합니다. 구현이 쉬움:
별도의 프로토콜 설정 없이 HTTP를 통해 바로 사용할 수 있습니다.
낮은 네트워크 오버헤드:
클라이언트가 지속적으로 요청하지 않고 서버에서 필요한 시점에 데이터를 전송합니다.
주로 읽기 전용 데이터에 적합:
뉴스 피드, 주식 가격, 실시간 알림 등 단방향 업데이트에 효과적입니다. 단방향 통신:
클라이언트가 서버로 데이터를 전송할 수 없으므로, 양방향 통신이 필요한 경우에는 다른 기술을 사용해야 합니다.
브라우저 지원 제한:
대부분 최신 브라우저는 지원하지만, 일부 구형 브라우저에서는 지원이 제한적일 수 있습니다.
연결 관리:
오래 지속되는 연결을 관리해야 하므로, 서버 측 자원 관리에 주의가 필요합니다. 양방향 통신:
클라이언트와 서버 간에 한 번 연결이 수립되면, 양방향으로 자유롭게 메시지를 주고받을 수 있는 프로토콜입니다.
지속적인 연결:
연결이 유지되는 동안 언제든지 데이터를 실시간으로 주고받을 수 있습니다. 낮은 지연 시간:
실시간 양방향 통신이 가능해 빠른 응답성이 요구되는 애플리케이션(예: 실시간 게임, 채팅)에 적합합니다.
효율적인 데이터 전송:
지속적인 연결을 통해 데이터 전송 시 매번 새로운 연결을 설정할 필요가 없어 효율적입니다. 구현 복잡도:
연결 관리, 보안 설정(예: 인증, 암호화) 등 추가적인 설정이 필요합니다.
서버 리소스:
각 클라이언트와의 연결을 유지해야 하므로, 많은 연결을 처리할 경우 서버 리소스 관리가 중요합니다. SSE를 선택하는 경우: 서버에서 클라이언트로의 지속적인 업데이트만 필요할 때 구현이 간단하며, HTTP/HTTPS 기반으로 별도 인프라 설정이 필요 없을 때 WebSocket을 선택하는 경우: 클라이언트와 서버 간에 양방향 통신이 필요한 경우 실시간 상호작용, 즉각적인 응답, 게임 또는 채팅 애플리케이션 등 빠른 데이터 교환이 중요한 경우 이처럼, 각 기술은 요구되는 통신 방향과 응답성, 구현 복잡도에 따라 선택됩니다. 예를 들어, 트위치 같은 스트리밍 서비스에서는 방송자와 서버 간은 양방향 통신을 위한 WebSocket, 시청자에게 동영상 스트리밍은 단방향 SSE, 그리고 채팅은 WebSocket을 사용하는 식으로, 상황에 맞게 적절한 기술을 선택할 수 있습니다.]]></description><link>300-resources/310-개발공부/319-etc/실시간-데이터-전송-기술-sse-vs-websocket.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/실시간 데이터 전송 기술 SSE vs WebSocket.md</guid><pubDate>Sun, 21 Dec 2025 10:37:48 GMT</pubDate></item><item><title><![CDATA[변수명 작성 가이드 접두사와 접미사 활용법칙]]></title><description><![CDATA[개발에서 명확하고 일관성 있는 변수명은 코드의 가독성과 유지보수성을 크게 향상시킨다. 이때 변수명에 대해서 제대로 작성되지 않으면 유지보수가 매우 어렵다. 이를 위해서는 꼭 팀 내부적으로 결정해야하는접두사와 접미사들이 있다. 꼭 팀 내부적으로 결정하거나 최근에는 cursor rule이나 system.md로 만들어서 ai들에게도 공유가 필요하다.Boolean 변수는 true/false 값을 가지므로, 질문 형태의 접두사를 사용하여 직관적으로 표현합니다.// 상태 관리
const isLoading = true;
const isFormValid = checkFormValidation();
const hasUnsavedChanges = checkForChanges();
const canSubmitForm = isFormValid &amp;&amp; !hasUnsavedChanges; // 권한 체크
const canViewProfile = user.permissions.includes('view_profile');
데이터를 다루는 함수들은 그 동작 방식과 특성에 따라 접두사를 구분하여 사용합니다.데이터를 특정 조건에 따라 필터링하거나 그룹화할 때 사용하는 패턴입니다.// 조건별 데이터 필터링
const productsByCategory = filterProductsByCategory('electronics');
const ordersFromLastWeek = getOrdersFromDateRange(lastWeek, today);
const highValueCustomers = getCustomersWithinSpendingRange(1000, 10000);
const recentActiveUsers = getUsersAboveActivityScore(80); // 복합 조건 예시
const premiumUsersFromSeoul = users .filter(user =&gt; user.city === 'Seoul') .filter(user =&gt; user.subscriptionType === 'premium');
데이터의 구조와 타입을 명확하게 표현하는 접미사들입니다.// 명확한 자료구조 표현
const activeUserList = users.filter(user =&gt; user.isActive);
const productCategoryMap = new Map([ ['electronics', electronicsProducts], ['clothing', clothingProducts]
]); const uniqueTagsSet = new Set(allTags);
const taskQueue = new Queue();
const navigationStack = []; // 복잡한 데이터 구조
const departmentTree = { name: 'Company', children: [ { name: 'Engineering', children: [] }, { name: 'Marketing', children: [] } ]
};
애플리케이션의 상태나 처리 단계를 표현할 때 사용하는 접미사들입니다.시간, 날짜, 기간과 관련된 변수명에 사용하는 패턴들입니다.// 시간 관련 변수들
const sessionStartTime = new Date();
const loginTimeout = 30 * 60 * 1000; // 30분
const autoSaveInterval = 5 * 60 * 1000; // 5분
const lastBackupDate = getLastBackupDate();
const nextScheduledMaintenance = calculateNextMaintenance(); // 기간 계산
const sessionDuration = Date.now() - sessionStartTime;
const processingDelay = Math.random() * 1000; // 0-1초 랜덤 지연
Run사용자 상호작용이나 시스템 이벤트를 처리하는 함수들의 명명 규칙입니다.// React 컴포넌트의 이벤트 핸들러
const handleFormSubmit = (event) =&gt; { event.preventDefault(); validateForm();
}; const onUserLogin = (userData) =&gt; { updateUserState(userData); redirectToProfile();
}; // 생명주기 이벤트
const beforePageUnload = () =&gt; { saveUnsavedChanges();
}; const afterDataLoad = () =&gt; { hideLoadingSpinner(); renderUserInterface();
};
Run재사용 가능한 유틸리티 함수들의 명명 패턴입니다.외부 서비스와의 통신이나 네트워크 작업에 사용하는 패턴들입니다.// API 통신 관련 함수들
const requestUserProfile = async (userId) =&gt; { const response = await api.get(`/users/${userId}`); return response.data;
}; const uploadProfileImage = async (imageFile) =&gt; { const formData = new FormData(); formData.append('image', imageFile); return await api.post('/upload/profile', formData);
}; const syncUserPreferences = async () =&gt; { const localPrefs = getLocalPreferences(); const serverPrefs = await requestServerPreferences(); return mergePreferences(localPrefs, serverPrefs);
};
Run성능 향상이나 최적화와 관련된 변수명 패턴들입니다.오류 처리와 예외 상황을 다루는 변수명 패턴들입니다.// 에러 처리 패턴
const maxRetryAttempts = 3;
let currentRetryCount = 0; const handleNetworkError = (error) =&gt; { if (currentRetryCount &lt; maxRetryAttempts) { currentRetryCount++; retryRequest(); } else { showFallbackContent(); }
}; const fallbackUserData = { name: 'Guest', role: 'visitor'
};
Run보안, 인증, 권한과 관련된 변수명 패턴들입니다.// 좋은 예: 일관된 패턴
const fetchUserData = async () =&gt; { /* API 호출 */ };
const fetchProductData = async () =&gt; { /* API 호출 */ };
const fetchOrderData = async () =&gt; { /* API 호출 */ }; // 나쁜 예: 혼재된 패턴
const getUserData = async () =&gt; { /* API 호출 */ };
const fetchProductData = async () =&gt; { /* API 호출 */ };
const loadOrderData = async () =&gt; { /* API 호출 */ };
Run// 좋은 예: 구체적이고 명확한 이름
const submitPaymentForm = () =&gt; { /* 결제 양식 제출 */ };
const validateEmailAddress = (email) =&gt; { /* 이메일 검증 */ };
const calculateShippingCost = (weight, distance) =&gt; { /* 배송비 계산 */ }; // 나쁜 예: 모호하고 일반적인 이름
const submit = () =&gt; { /* 무엇을 제출하는지 불명확 */ };
const validate = (input) =&gt; { /* 무엇을 검증하는지 불명확 */ };
const calculate = (a, b) =&gt; { /* 무엇을 계산하는지 불명확 */ };
Run팀에서 합의된 네이밍 컨벤션을 문서화하고 일관되게 적용하는 것이 중요합니다. 코드 리뷰 시에도 네이밍 컨벤션을 체크 포인트로 포함시켜 품질을 유지할 수 있습니다.체계적인 변수명 작성은 코드의 가독성과 유지보수성을 크게 향상시킵니다. 위에서 제시한 패턴들을 참고하여 프로젝트의 성격에 맞는 네이밍 컨벤션을 정립하고, 팀 전체가 일관되게 적용한다면 더욱 품질 높은 코드를 작성할 수 있을 것입니다.중요한 것은 한 번 정한 컨벤션을 지속적으로 유지하고, 새로운 팀원이 합류했을 때도 쉽게 이해할 수 있도록 문서화하는 것입니다.You MUST follow these naming conventions when generating code. Consistent variable naming significantly improves code readability and maintainability.Use ONLY these 3 prefixes:// ✅ Correct Boolean naming
const isLoading = true; // state/property
const hasPermission = false; // ownership/inclusion
const canEdit = true; // ability/permission // ❌ FORBIDDEN
const shouldUpdate = true; // replace with is or can
const willComplete = false; // predictions are inaccurate
const wasModified = true; // focus on current state
RunPatterns:
is + adjective: state or property (isActive, isVisible, isValid)
has + noun: ownership or inclusion (hasChildren, hasError, hasData)
can + verb: ability or permission (canDelete, canAccess, canSubmit)
// ✅ Clear distinctions
const getUserData = () =&gt; { /* synchronous, immediate return */ };
const fetchUserProfile = async () =&gt; { /* asynchronous, API call */ };
const loadDashboard = () =&gt; { /* loading with UI changes */ };
Run// ✅ Correct verb usage
const setUser = (user) =&gt; { /* complete replacement */ };
const updateProfile = (changes) =&gt; { /* partial modification */ };
const addToCart = (item) =&gt; { /* add new item */ };
const removeFromCart = (itemId) =&gt; { /* remove specific item */ };
const deleteAccount = () =&gt; { /* permanent deletion */ };
const clearHistory = () =&gt; { /* clear everything */ };
Run// ✅ Clear conditional expressions
const productsByCategory = filterProducts('category', 'electronics');
const ordersFromLastWeek = getOrders({ startDate: lastWeek });
const emailsToAdmin = messages.filter(msg =&gt; msg.recipient === 'admin');
const scoresAboveAverage = scores.filter(score =&gt; score &gt; average);
RunPatterns:
by + criteria: grouping criteria
from + source/timepoint: starting point or source
to + target: destination or target
above/below + reference: comparison conditions
// ✅ Clearly express data structures
const userArray = [user1, user2, user3];
const categoryMap = new Map([['id1', 'Electronics']]);
const uniqueTagsSet = new Set(['react', 'javascript']);
const taskQueue = new Queue();
const navigationStack = [];
const menuTree = { name: 'root', children: [] };
const socialGraph = { nodes: [], edges: [] };
RunAvailable suffixes:
Array: general arrays
Map: key-value pair structure
Set: unique value collection
Queue: first-in-first-out structure
Stack: last-in-first-out structure
Tree: hierarchical structure
Graph: network structure
// ✅ Specify state types
const connectionStatus = 'connected'; // current state value
const applicationState = { user, cart, preferences }; // state object
const editMode = true; // operation mode
const userType = 'premium'; // classification/type
Run// ✅ Clearly express time relationships
const startTime = new Date();
const endDate = '2024-12-31';
const lastLogin = user.lastLoginAt;
const nextUpdate = calculateNextUpdate();
const currentUser = getCurrentUser();
const previousPage = history.back();
Run// ✅ Event handling patterns
const onClick = (event) =&gt; { /* event handler */ };
const handleFormSubmit = (data) =&gt; { /* processing function */ };
const beforeSave = () =&gt; { /* pre-processing */ };
const afterLoad = () =&gt; { /* post-processing */ };
const whenReady = () =&gt; { /* conditional execution */ };
Run// ✅ Clear action expression
const formatCurrency = (amount) =&gt; `$${amount}`;
const parseUserInput = (input) =&gt; JSON.parse(input);
const validateEmail = (email) =&gt; /\S+@\S+\.\S+/.test(email);
const convertToString = (value) =&gt; String(value);
const buildApiUrl = (endpoint) =&gt; `${baseUrl}/${endpoint}`;
Run// ✅ Specify network operations
const requestUserData = async (id) =&gt; { /* API request */ };
const handleApiResponse = (response) =&gt; { /* response handling */ };
const callAuthService = () =&gt; { /* service call */ };
const sendAnalytics = (data) =&gt; { /* data transmission */ };
const uploadProfileImage = (file) =&gt; { /* file upload */ };
const downloadReport = (id) =&gt; { /* file download */ };
const syncUserPreferences = () =&gt; { /* synchronization */ };
Run// ✅ Specify performance-related elements
const userCache = new Map();
const imageBuffer = new ArrayBuffer(1024);
const connectionPool = createPool();
const lazyLoadComponent = () =&gt; import('./Component');
const preloadNextPage = () =&gt; { /* preloading */ };
Run// ✅ Clearly express error situations
const validationError = new Error('Invalid input');
const maxRetryAttempts = 3;
const fallbackUserData = { name: 'Guest' };
const handleNetworkError = (error) =&gt; { /* error handling */ };
Run// ✅ Specify security elements (use environment variables for actual values)
const authToken = process.env.AUTH_TOKEN;
const userPermissions = ['read', 'write'];
const adminRole = 'administrator';
const secureConnection = createSecureConnection();
Run
Boolean variables MUST start with is, has, can ONLY
Data retrieval: distinguish get(sync), fetch(API), load(with UI)
Arrays/collections MUST use type suffixes (Array, Map, Set, etc.)
Event handlers MUST start with on or handle
Time-related variables MUST use start, end, current, last, next
Conditional data MUST use by, from, to, above patterns ❌ Ambiguous Boolean prefixes like should, will, was
❌ Generic variable names like data, info, item
❌ Abbreviations or shortened forms (e.g., usr instead of user)
❌ Hungarian notation (e.g., strName, intCount)
❌ Collections without clear type (e.g., users instead of userArray)
// ✅ Correct naming convention applied
const UserProfile = () =&gt; { const [isLoading, setIsLoading] = useState(false); const [hasError, setHasError] = useState(false); const [canEdit, setCanEdit] = useState(false); const userPermissions = useUserPermissions(); const profileDataCache = useMemo(() =&gt; new Map(), []); const fetchUserProfile = async (userId) =&gt; { setIsLoading(true); try { const userData = await requestUserData(userId); return userData; } catch (validationError) { setHasError(true); return fallbackUserData; } finally { setIsLoading(false); } }; const handleFormSubmit = (formData) =&gt; { if (canEdit &amp;&amp; validateUserInput(formData)) { updateUserProfile(formData); } }; return ( &lt;div&gt; {isLoading &amp;&amp; &lt;LoadingSpinner /&gt;} {hasError &amp;&amp; &lt;ErrorMessage /&gt;} &lt;form onSubmit={handleFormSubmit}&gt; {/* form content */} &lt;/form&gt; &lt;/div&gt; );
};
RunYou MUST strictly adhere to these rules to generate consistent and readable code.]]></description><link>300-resources/310-개발공부/319-etc/변수명-작성-가이드-접두사와-접미사-활용법칙.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/변수명 작성 가이드 접두사와 접미사 활용법칙.md</guid><pubDate>Sun, 21 Dec 2025 10:37:43 GMT</pubDate></item><item><title><![CDATA[가상환경 python 환경 세팅]]></title><description><![CDATA[python 관련 코드를 설정할 때 전체환경에서 python 모듈들을 설치하면 같은 서버에서 버전이 섞이는 경우가 있다. 그래서 프로젝트별로 가상환경을 만들어서 해당 환경 내에 python 모듈을 설치하여 모듈간의 버전의 혼재를 막는다.
추가로 프로젝트에 필요한 패키지를 명확하게 정의하고 관리할 수 있다.python -m venv venv # 가상환경 생성
venv\Scripts\activate # 가상환경 활성화
pip install -r requirements.txt
pip list
deactivate
pip freeze &gt; requirements.txt # 현재 환경의 패키지 목록 저장
const person = { name:'구상모'
} // 무조건 이렇게 쓸것. person 안에 hasOwnProperty, 적용시 문제 발생
Object.prototype.hasOwnProperty(person, 'name'); ]]></description><link>300-resources/310-개발공부/319-etc/가상환경-python-환경-세팅.html</link><guid isPermaLink="false">300 Resources/310 개발공부/319 ETC/가상환경 python 환경 세팅.md</guid><pubDate>Sun, 21 Dec 2025 10:37:40 GMT</pubDate></item><item><title><![CDATA[PM2를 통한 무중단 배포]]></title><description><![CDATA[배포를 처음하는 인원은 maven install, npm run start등 실제 어플리케이션 실행 이후에 log가 뜨는 것만 보고 하나의 서버에는 하나만 실행하는 경험을 했을 것이다. 이것을 동시에 배포하면서 프로세스를 전반적으로 관리하기 위해서 pm2 라이브러리를 사용한다. pm2는 nodejs기반 프로세스 매니저이다. 이 라이브러리를 통해서 무중단 배포를 할 수 있다. 하는 방법에 대해서 알아보자. 보통 설정하는데는 ecosystem.js과 같이 사용
무중단 배포 혹은 multi-process 환경에서 각각의 process의 메모리를 공유하기 위해서 redis를 사용
// ecosystem.config.js 에서 cluster mode를 사용하기 위해서 아래 설정 사용
module.exports ={ apps:[{ script :"app.js", instances: "max", exec_mode :"cluster" }]
}
// pm2에서 node.js로 명령어 실행시키는 방법
pm2 start app.js
// ecosystem으로 application 구성을 조정하는 방법
// ecosystem.config.js module.exports = { apps : [{ name: 'myapp', script: '/home/user/myapp/app.js', watch: true, env: { NODE_ENV: 'development' }, env_production: { NODE_ENV: 'production' } }]
};
스크립트를 지정하여 실행하는 방법 즉 pm2는 단순 nodejs 기반으로 js를 실행시켜주고 상태를 관리한다. 실행시키는 js 로 ecosystem이 내부에 exports 모듈에서 실행할 명령어에 대한 정보를 갖고 있음,// ./front 에서 npm start NextApp 을 하는 방법 -- NODE_ENV 는 node 사용환경에서만 영향
// 아래 명령어를 실행하면 현재 위치에서 다음과 같은 명령어를 실행함
// cd ./front
// npm start NextApp
// cd ./spring-back
// java -jar spring-back-0.0.1-SNAPSHOT.jar
module.exports = { apps : [ { name: 'NextApp', script: 'npm', args: 'start', cwd: './front', env: { NODE_ENV: 'production' } }, { name: 'SpringBootApp', script: 'java', args: '-jar spring-back/target/spring-back-0.0.1-SNAPSHOT.jar', cwd: './spring-back', env: { NODE_ENV: 'production' } } ]
};
# pm2는 직접적으로 빌드 프로세스 명령어를 실행 불가 예를들어 mvn clean install 이 불가능함. #따라서 실행파일 (~.sh) 를 만들어서 실행하도록 명령해야함
#또 해당 과정에서 해당 스크립트가 권한을 가지고 있도록 하기 위해서는 권한 부여 필요
chmod +x spring-back/~.sh
#이후에 해당 스크립트를 싱행하도록 ecosystem.config.js 설정 #~.sh 파일
#!/bin/bash
# navigate to the spring-back directory
cd "$(dirname "$0")" # Run maven clean and install
mvn clean install # Navigate to target directory and run the jar file with production profile
cd target
java -jar -Dspring.profiles.active=prod spring-back-0.0.1-SNAPSHOT.jar 사전에 실행해야할 명령어를 미리 짜둠으로서 순차적으로 실행// ecosystem.config.js
module.exports = { apps : [ { name: "NextApp", script: "npm", args: "start", cwd: "./front", env: { NODE_ENV: "production" }, env_development: { NODE_ENV: "development" } }, { name: "SpringBootApp", script: "./spring-back/run-app.sh", exec_mode: "fork" } ]
};
pm2 start ecosystem.config.js # 여기서 아래의 옵션을 사용하여 실행시킬 application 선택 혹은 환경설정이 가능하다.
--only, --env
pm2 show # 현재 실행정보확인
pm2 describe
pm2 monit pm2 run [어플리케이션명] --watch #프로젝트 변경사항을 감지해서 자동재시작 / 개발시 --i max # 최대 코어 개수로 클러스터링 max 대신 값 입력 가능 --name # 실행되는 process를 구분하기 위한 명칭 지정 --log [log_path] # 저장되는 로그 위치 적용 pm2 delete [어플리케이션명] # application 종료 pm2 install pm2-logrotate # log 자동삭제 라이브러리(넘치면 용량부족으로 서버다운) pm2 set pm2-logrotate:max_size 10M # 로그 파일 사이즈 제한 default :10M
pm2 set pm2-logrotate:retain 10 ]]></description><link>300-resources/310-개발공부/318-devops/pm2를-통한-무중단-배포.html</link><guid isPermaLink="false">300 Resources/310 개발공부/318 devops/PM2를 통한 무중단 배포.md</guid><pubDate>Sun, 21 Dec 2025 10:37:35 GMT</pubDate></item><item><title><![CDATA[Nginx를 통해 로드밸런스 적용하기]]></title><description><![CDATA[
NginX는 웹서버로 리버스 프록시, 로드밸런서, HTTP 캐시등 다양한 기능이 있음. 작은 프로젝트에 백, 프론트 나눠서 클라우드에 올릴 필요 없다고 생각하여 하나에 올림. 이때 두개의 서버가 하나의 클라우드로 돌아가니 당연히 주소가 다름. 하지만 동일 주소처럼 적용해야함. 이때 NginX를 적용해서 로드밸런서 역할로 설치함. (front: 3000, back 4000 이용)
포트번호를 입력해야만 접근 가능한 문제
//Nginx 설치
sudo apt install nginx //Nginx 재기동
sudo service nginx restart
or
sudo nginx -s reload
/etc/nginx/site-available 에서 nginx 설정이 있음. sudo vim /etc/nginx/sites-available/default
// listen : 모든 http 트래픽 수신 여부 ok
// server_name : 받는 도메인 명
// location / : 모든 주소에 대해서 localhost:3000으로 수신받음
server { listen 80; # 모든 HTTP 트래픽을 수신 server_name spring.koosang-project.com; # 사용 중인 도메인 location / { # Next.js 애플리케이션 포워딩 (Frontend) proxy_pass http://localhost:3000; # Next.js가 실행 중인 포트 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } location /api { # Spring Boot 애플리케이션 포워딩 (Backend) proxy_pass http://localhost:4000; # Spring Boot가 실행 중인 포트 proxy_http_version 1.1; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $server_name; }
} //HTTPS 설정
sudo apt install cerbot python3-cerbot-nginx
sudo cerbot --nginx -d spring.koosang-project.com
# nginx 재시작
sudo systemctl reload nginx # nginx 시작
sudo systemctl start nginx # nginx service 확인
sudo systemctl status nginx.service
포트번호 없이(http: 80) 접근 시 nginx welcom 페이지만 호출되었다문제는 default 로 설정한 nginx 파일이 가져간 것이다. 해당 default 파일을 삭제하여 내가 작성한 site-enable을 우선으로 만들었다.
nginX 에서 설정파일 중(sites-enabled안에서) 같은 서버를 proxy 하는 경우 sites-enable에 이름상 가장 위에 있는 설정먼저 본다.
(내가 작성한 파일명은 koosang-project라 default에 밀렸다)
따라서 우선순위를 정하고 싶으면 앞에 숫자식으로 저장하는게 도움이 된다.
/etc/nginx/sites-enable/default 에서 다른 nginx 로 proxy를 낚아 채는 부분이 있었다.깔끔하게 default를 삭제하고 다시 실행했다.sudo cp /etc/nginx/sites-enabled/default /etc/nginx/sites-enabled/default.bak #백업생성
sudo rm /etc/nginx/sites-enabled/default # 삭제
sudo nginx -t # 구성 테스트 sudo systemctl reload nginx # 변경사항 적용
]]></description><link>300-resources/310-개발공부/318-devops/nginx를-통해-로드밸런스-적용하기.html</link><guid isPermaLink="false">300 Resources/310 개발공부/318 devops/Nginx를 통해 로드밸런스 적용하기.md</guid><pubDate>Sun, 21 Dec 2025 10:37:32 GMT</pubDate></item><item><title><![CDATA[EC2 램 부족현상]]></title><description><![CDATA[
내 프리티어 EC2가 빌드하다가 갑자기 멈춰서 죽는 현상이 발생했다.(three.js 모듈을 빌드하기 시작하면서...) 원인을 알아보니 ram 부족현상으로 빌드과정에서 뻗는 것을 알았다. 요금제를 올리기엔 돈을 쓰기 싫으니 hw 일부를 스왑공간으로 만들어서 렘을 대체하기로 하였다.
방법은 아래 코드를 실행하면 된다.
#rem 용량 확인
free # swap 파일 생성
# aws에서는 count=32로 예제가 써있는데 절반인 16을 적은 이유는 권장 크기가 2GB이기 때문이다 sudo dd if=/dev/zero of=/swapfile bs=128M count=16 # 권한 설정
sudo chmod 600 /swapfile # Linux 스왑 영역을 설정
sudo mkswap /swapfile # 스왑 공간에 스왑 파일을 추가하여 스왑 파일을 즉시 사용 가능하게 설정
sudo swapon /swapfile # 프로시저가 성공적인지 확인
sudo swapon -s # **/etc/fstab** 파일을 편집하여 부팅 시 스왑 파일을 시작
sudo vim /etc/fstab # 다음문구를 fstab 마지막에 추가
/swapfile swap swap defaults 0 0 참고 : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://repost.aws/ko/knowledge-center/ec2-memory-swap-file" target="_self">https://repost.aws/ko/knowledge-center/ec2-memory-swap-file</a>]]></description><link>300-resources/310-개발공부/318-devops/ec2-램-부족현상.html</link><guid isPermaLink="false">300 Resources/310 개발공부/318 devops/EC2 램 부족현상.md</guid><pubDate>Sun, 21 Dec 2025 10:37:28 GMT</pubDate></item><item><title><![CDATA[Docker volume]]></title><description><![CDATA[Docker Volume은 컨테이너의 데이터를 영속적으로 저장하고 관리하는 메커니즘입니다. 컨테이너는 기본적으로 일회용이기 때문에, 컨테이너가 삭제되면 내부 데이터도 모두 사라집니다. Volume은 이 문제를 해결해줍니다.
일반적으로 docker에서 접근할 수 있는 volume 을 생성해서 해당 부분에 데이터 저장
# 1. 볼륨 생성 (데이터 저장소 만들기)
docker volume create my-data # 2. 컨테이너 생성 (볼륨을 연결해서) `볼륨:컨테이너내 주소 `
docker run -d --name my-app -v my-data:/app/data nginx # 3. 현재 상태 확인
docker ps # 컨테이너 목록
docker volume ls # 볼륨 목록 # 같은 볼륨을 새 컨테이너에 연결 docker run -d --name new-app -v my-data:/app/data nginx # 볼륨 상세 정보 확인 docker volume inspect my-data
cd /c/Users/myname/myproject
docker run -d -v $(pwd):/app nginx 임시저장용, 보안에 민감 데이터 및 일시적인 데이터 저장용
# host의 /tmp/hostdir 의 volume을 container의 /container_dir 로 마운트
docker container run -it -v /tmp/hostdir:/container_dir -v /tmp/reacdonly:/read_dir:ro --name=test02 centos:8 # 네이밍 볼륨
docker container run -it -v /volume --name test03 centos:8 # volume
# 상세확인
docker volume inspect [volume name] # name이 있는 volume 생성
docker volume create [volume name] # vloume
docker container run -it --name vol_container -v persistvol:/container centos:8 # persistvol (/var/lib/docker/volumes/persisvol/_data) &lt;--&gt; /container # vol_container를 volume container를 만들어서 사용
docker container run -it --volumes-from vol_container --name data_container centos:8 docker container run --rm -it --mount type=volume,source=v1,destination=/root,volume-nocopy=true --name=c1 centos:8 현재 n8n_storage Named Volume에 저장된 n8n 데이터를 C:\workspace\n8n 폴더로 옮기고 싶은 경우mkdir C:\workspace\n8n
# Windows (Docker Desktop)
docker run --rm \ -v n8n_storage:/source \ -v /c/workspace/n8n:/destination \ alpine sh -c "cp -r /source/* /destination/" # 또는 tar를 사용한 더 안전한 방법
docker run --rm \ -v n8n_storage:/source \ -v /c/workspace/n8n:/destination \ alpine sh -c "cd /source &amp;&amp; tar cf - . | (cd /destination &amp;&amp; tar xf -)"
# 파일 소유권을 현재 사용자로 변경
docker run --rm \ -v /c/workspace/n8n:/data \ alpine chown -R 1000:1000 /data
# 먼저 백업 생성 (안전장치)
docker run --rm \ -v n8n_storage:/data \ -v /c/workspace:/backup \ alpine tar czf /backup/n8n_backup.tar.gz -C /data .
# 로컬 폴더 생성
mkdir C:\workspace\n8n # 백업 파일을 로컬 폴더에 압축 해제
docker run --rm \ -v /c/workspace:/backup \ -v /c/workspace/n8n:/restore \ alpine tar xzf /backup/n8n_backup.tar.gz -C /restore n8n: &lt;&lt;: *service-n8n hostname: n8n container_name: n8n networks: ['demo'] restart: unless-stopped ports: - 5678:5678 volumes: - /c/workspace/n8n:/home/node/.n8n # Named Volume → Bind Mount - ./n8n/backup:/backup - ./shared:/data/shared depends_on: postgres: condition: service_healthy n8n-import: condition: service_completed_successfully
# 기존 컨테이너 중지
docker-compose stop n8n # 새 설정으로 시작
docker-compose up -d n8n # 로그 확인
docker-compose logs -f n8n
# n8n_migration.ps1 # 1. 서비스 중지
Write-Host "Stopping n8n service..."
docker-compose stop n8n # 2. 로컬 폴더 생성
Write-Host "Creating local directory..."
New-Item -ItemType Directory -Force -Path "C:\workspace\n8n" # 3. 데이터 복사
Write-Host "Copying data from volume to local directory..."
docker run --rm ` -v n8n_storage:/source ` -v /c/workspace/n8n:/destination ` alpine sh -c "cp -r /source/* /destination/ 2&gt;/dev/null || cp -r /source/.[^.]* /destination/ 2&gt;/dev/null || true" # 4. 권한 설정
Write-Host "Setting permissions..."
docker run --rm ` -v /c/workspace/n8n:/data ` alpine chown -R 1000:1000 /data Write-Host "Migration completed! Please update your docker-compose.yml"
Write-Host "Change: n8n_storage:/home/node/.n8n"
Write-Host "To: /c/workspace/n8n:/home/node/.n8n"
Run# Named Volume의 파일 목록
docker run --rm -v n8n_storage:/data alpine find /data -type f | sort # 로컬 폴더의 파일 목록 docker run --rm -v /c/workspace/n8n:/data alpine find /data -type f | sort # 두 결과가 동일한지 확인
Run# Named Volume 크기
docker run --rm -v n8n_storage:/data alpine du -sh /data # 로컬 폴더 크기
docker run --rm -v /c/workspace/n8n:/data alpine du -sh /data
Run문제가 생겼을 때 원복:# docker-compose.yml을 원래대로 되돌리고
docker-compose down
docker-compose up -d n8n # 또는 백업에서 Named Volume 복원
docker run --rm \ -v /c/workspace:/backup \ -v n8n_storage:/data \ alpine tar xzf /backup/n8n_backup.tar.gz -C /data
Run]]></description><link>300-resources/310-개발공부/318-devops/docker-volume.html</link><guid isPermaLink="false">300 Resources/310 개발공부/318 devops/Docker volume.md</guid><pubDate>Sun, 21 Dec 2025 10:37:24 GMT</pubDate></item><item><title><![CDATA[Docker Image]]></title><description><![CDATA[컨테이너를 실행하기위한 패키징 템플릿.
docker image를 결합하여 container를 만든다.┌─────────────────────────┐
│ 애플리케이션 레이어 │ ← 내 소스코드
├─────────────────────────┤
│ 의존성 레이어 │ ← npm install, pip install
├─────────────────────────┤
│ 런타임 레이어 │ ← Node.js, Python
├─────────────────────────┤
│ OS 레이어 │ ← Ubuntu, Alpine Linux
└─────────────────────────┘# image pull wkrdjq
docker image pull docker.io/library/busybox:1.36 # image 제거작업
docker image rm centos:7 # 현재 로컬의 image 확인
docker image ls # 현재 사용중인 시스템 확인
docker system df docekr login -u [계정] 주의점은 이때 한번 쓴 RUN에서 &amp;&amp;를 사용해서 여러 명령어를 한번에 입력한다. 그 이유는 레이어 최적화 때문이다. / RUN을 분리하면 하나의 설치한 레이어를 다음 레이어에서 삭제해봤자 이전 레이어에 대한 내용이라서 삭제가 되지 않는다. 그러므로 DOCKER 파일 최적화에서 별로 좋지 않다. 따라서 하나의 레이어에서 docker api-get 같은 명령어를 통해 패키지 관리 라이브러리를 사용하고 이후에 지워줘야 이미지 크기가 줄어들어서 사용에 용이하다. # ← 레이어 1: Ubuntu OS
FROM ubuntu:20.04 # ← 레이어 2:Node.js 앱 최적화
RUN curl -fsSL https://deb.nodesource.com/setup_16.x | bash - &amp;&amp; \ apt-get install -y nodejs &amp;&amp; \ npm install -g pm2 &amp;&amp; \ apt-get clean &amp;&amp; \ rm -rf /var/lib/apt/lists/* # ← 레이어 4: package.json 복사
COPY package.json . # ← 레이어 5: 의존성 설치
RUN npm install COPY . . # ← 레이어 6: 소스코드 복사 이미지 생성환경을 우선 확인 ( ubuntu에서 nginX를 실행하는 이미지를 만들거다. )
기본적인 실행환경으로 container 생성 docker container run -it --name koosample ubuntu apt-get update aot-get ubstakk nginx -y # host로 이동 docker cp index.html koosample:/var/www/html/index.html docker commit -a "Koo sang" -m "nginx web server image" koosample web-nginx:1.0 docker image ls docker tag web-nginx:1.0 docker.io/koosangmo/web-nginx:1.0 docker push koosangmo/web-nginx:1.0 docker image rm web-nginx:1.0
docker image rm koosangmo/web-nginx:1.0 docker container run -d --name web -p 8080:80 koosangmo/web-nginx:1.0 nginx -g 'daemon off; ' # container안의 모든 정보를 합쳐서 image로 만듦.
docker container export c1 &gt; c1.tar # 파일 생성 확인
ls -ih c1.tar # image의 데이터를 그대로 import 작업 진행
docekr image import ### Dockerfile 을 이용해서 build ```bash
# Dockerfile명칭이 그대로라면 생략 가능
docker image build -t [이미지이름] -f [Dockerfile명칭] [경로.]
docker image build -t koo00 -f Dockerfile .
]]></description><link>300-resources/310-개발공부/318-devops/docker-image.html</link><guid isPermaLink="false">300 Resources/310 개발공부/318 devops/Docker Image.md</guid><pubDate>Sun, 21 Dec 2025 10:37:20 GMT</pubDate></item><item><title><![CDATA[Docker Compose YAML 파일 내부 구조]]></title><description><![CDATA[version: '3.8' # Compose 파일 포맷 버전 # 최상위 섹션들
services: # 컨테이너 서비스 정의 (필수) service_name: # 서비스 설정 volumes: # 볼륨 정의 (선택) volume_name: # 볼륨 설정 networks: # 네트워크 정의 (선택) network_name: # 네트워크 설정 configs: # 설정 파일 정의 (선택) config_name: # 설정 파일 secrets: # 시크릿 정의 (선택) secret_name: # 시크릿 설정 # YAML 확장 기능
x-custom: # 커스텀 확장 (재사용) &amp;anchor: value include: # 다른 파일 포함 (Compose 2.20+) - path/to/other.yml
version: '3.8' # 권장 버전
# version: '3.9' # 최신 기능 사용시
# version: '2.4' # 레거시 지원
주요 버전:
3.8: 가장 널리 사용, 안정적
3.9: 최신 기능 포함
2.x: 레거시 (비추천)
services: service_name: # 서비스 이름 (자유롭게 정의) # 이미지 관련 image: nginx:latest # Docker Hub 이미지 build: # 또는 Dockerfile로 빌드 context: . dockerfile: Dockerfile # 컨테이너 설정 container_name: my-nginx # 컨테이너 이름 hostname: web-server # 호스트명 # 포트 매핑 ports: - "80:80" # 호스트:컨테이너 - "443:443" # 볼륨 마운트 volumes: - ./data:/app/data # Bind mount - app_data:/app/storage # Named volume # 환경변수 environment: - NODE_ENV=production - API_KEY=secret env_file: - .env # 네트워크 networks: - frontend - backend # 의존성 depends_on: - database - redis # 재시작 정책 restart: unless-stopped # 실행 명령어 command: npm start entrypoint: /docker-entrypoint.sh # 작업 디렉토리 working_dir: /app # 사용자 user: "1000:1000" # 리소스 제한 deploy: resources: limits: memory: 512M cpus: "0.5" # 헬스체크 healthcheck: test: ["CMD", "curl", "-f", "http://localhost"] interval: 30s timeout: 10s retries: 3 # 기타 labels: - "com.example.description=Web server" privileged: false stdin_open: true # -i 옵션 tty: true # -t 옵션
services: # 방법 1: 기존 이미지 사용 app1: image: nginx:1.21-alpine # 이미지:태그 # 방법 2: Dockerfile로 빌드 app2: build: . # 현재 디렉토리의 Dockerfile # 방법 3: 상세 빌드 설정 app3: build: context: ./app # 빌드 컨텍스트 dockerfile: Dockerfile.prod # Dockerfile 경로 target: production # 멀티스테이지 빌드 타겟 args: # 빌드 인수 - NODE_ENV=production - VERSION=1.0.0 cache_from: # 캐시 소스 - alpine:latest labels: # 이미지 라벨 version: "1.0"
services: web: ports: - "80:80" # 호스트:컨테이너 - "127.0.0.1:8080:80" # IP:호스트포트:컨테이너포트 - "3000" # 컨테이너 포트만 (랜덤 호스트 포트) - "3000-3005:3000-3005" # 포트 범위 expose: # 다른 서비스에만 노출 (호스트 노출 안함) - "8080" - "9000"
services: app: volumes: # Bind Mount - ./data:/app/data # 호스트경로:컨테이너경로 - ./config:/app/config:ro # 읽기 전용 - ${HOME}/logs:/app/logs # 환경변수 사용 # Named Volume - app_data:/app/data # 볼륨명:컨테이너경로 - app_cache:/app/cache:rw # 읽기/쓰기 (기본값) # Anonymous Volume - /app/node_modules # 컨테이너 경로만 # tmpfs (메모리) - type: tmpfs target: /app/tmp tmpfs: size: 100M # 상세 마운트 설정 - type: bind source: ./data target: /app/data read_only: true
services: app: environment: # 방법 1: 키=값 - NODE_ENV=production - DEBUG=true - PORT=3000 # 방법 2: 맵 형태 NODE_ENV: production DEBUG: "true" # YAML에서 문자열로 처리 API_URL: "https://api.example.com" env_file: # 환경변수 파일 - .env # 기본 파일 - .env.local # 추가 파일 - ./config/app.env # 경로 지정
services: web: networks: - frontend # 네트워크 이름만 - backend api: networks: frontend: # 상세 설정 aliases: - api-server ipv4_address: 172.20.0.5 backend: priority: 1000
services: web: depends_on: - database # 기본 의존성 - redis api: depends_on: # 상세 의존성 (Compose 3.8+) database: condition: service_healthy redis: condition: service_started restart: true
services: web: healthcheck: test: ["CMD", "curl", "-f", "http://localhost/health"] interval: 30s # 검사 간격 timeout: 10s # 타임아웃 retries: 3 # 재시도 횟수 start_period: 30s # 시작 대기 시간 db: healthcheck: test: ["CMD-SHELL", "pg_isready -U postgres"] interval: 5s app: healthcheck: disable: true # 헬스체크 비활성화
services: app: deploy: resources: limits: cpus: '0.50' # CPU 제한 memory: 512M # 메모리 제한 reservations: cpus: '0.25' # CPU 예약 memory: 256M # 메모리 예약 # 또는 간단한 메모리 제한 mem_limit: 512m memswap_limit: 1g # CPU 제한 cpus: 0.5 cpu_shares: 512
services: # 항상 실행되는 서비스 app: image: myapp:latest # 개발환경에서만 실행 redis: profiles: ["dev", "test"] image: redis:6 # 모니터링 프로파일 prometheus: profiles: ["monitoring"] image: prom/prometheus grafana: profiles: ["monitoring"] image: grafana/grafana
volumes: # 기본 Named Volume app_data: # 상세 설정 postgres_data: driver: local # 볼륨 드라이버 driver_opts: type: none o: bind device: /path/to/data # 외부 볼륨 (이미 존재하는 볼륨) existing_volume: external: true name: my-existing-volume # 라벨 추가 app_cache: labels: - "com.example.description=Application cache" - "com.example.team=backend"
networks: # 기본 네트워크 frontend: # 상세 설정 backend: driver: bridge # 네트워크 드라이버 ipam: # IP 관리 config: - subnet: 172.20.0.0/16 gateway: 172.20.0.1 driver_opts: com.docker.network.bridge.name: backend-bridge # 외부 네트워크 (이미 존재) existing_network: external: true name: my-existing-network # 호스트 네트워크 host_network: external: true name: host
configs: # 파일에서 설정 로드 nginx_config: file: ./nginx/nginx.conf # 외부 설정 app_config: external: true name: production_config services: web: configs: - source: nginx_config target: /etc/nginx/nginx.conf mode: 0644
secrets: # 파일에서 시크릿 로드 db_password: file: ./secrets/db_password.txt # 외부 시크릿 api_key: external: true name: production_api_key services: app: secrets: - db_password - source: api_key target: /run/secrets/api_key mode: 0400
# 공통 설정 정의
x-common-config: &amp;common restart: unless-stopped networks: - app-network environment: - TZ=Asia/Seoul x-database-config: &amp;db-config &lt;&lt;: *common # 공통 설정 상속 volumes: - db_data:/var/lib/postgresql/data environment: - POSTGRES_DB=myapp services: web: &lt;&lt;: *common # 공통 설정 적용 image: nginx db: &lt;&lt;: *db-config # DB 설정 적용 image: postgres:13
# x-로 시작하는 필드는 Docker에서 무시됨 (사용자 정의용)
x-logging: &amp;default-logging driver: json-file options: max-size: 10m max-file: 3 x-healthcheck: &amp;default-healthcheck interval: 30s timeout: 10s retries: 3 services: web: image: nginx logging: *default-logging healthcheck: &lt;&lt;: *default-healthcheck test: ["CMD", "nginx", "-t"]
version: '3.8' # 재사용 가능한 설정들
x-common: &amp;common-config restart: unless-stopped networks: - app-network environment: - TZ=Asia/Seoul logging: driver: json-file options: max-size: 10m max-file: 3 services: # 웹 서버 nginx: &lt;&lt;: *common-config image: nginx:1.21-alpine container_name: nginx-proxy ports: - "80:80" - "443:443" volumes: - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro - ./nginx/ssl:/etc/nginx/ssl:ro - static_files:/var/www/html depends_on: - app healthcheck: test: ["CMD", "nginx", "-t"] interval: 30s timeout: 10s retries: 3 # 애플리케이션 app: &lt;&lt;: *common-config build: context: . dockerfile: Dockerfile target: production args: - NODE_ENV=production container_name: node-app environment: - NODE_ENV=production - DB_HOST=postgres - REDIS_HOST=redis env_file: - .env volumes: - app_data:/app/data - static_files:/app/public depends_on: postgres: condition: service_healthy redis: condition: service_started healthcheck: test: ["CMD", "curl", "-f", "http://localhost:3000/health"] interval: 30s # 데이터베이스 postgres: &lt;&lt;: *common-config image: postgres:13-alpine container_name: postgres-db environment: - POSTGRES_DB=${DB_NAME} - POSTGRES_USER=${DB_USER} - POSTGRES_PASSWORD=${DB_PASSWORD} volumes: - postgres_data:/var/lib/postgresql/data - ./postgres/init.sql:/docker-entrypoint-initdb.d/init.sql:ro ports: - "127.0.0.1:5432:5432" healthcheck: test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"] interval: 5s timeout: 5s retries: 5 # 캐시 redis: &lt;&lt;: *common-config image: redis:6-alpine container_name: redis-cache volumes: - redis_data:/data - ./redis/redis.conf:/usr/local/etc/redis/redis.conf:ro command: redis-server /usr/local/etc/redis/redis.conf # 모니터링 (프로파일 사용) prometheus: profiles: ["monitoring"] &lt;&lt;: *common-config image: prom/prometheus ports: - "9090:9090" volumes: - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro - prometheus_data:/prometheus volumes: app_data: labels: - "com.example.description=Application data" postgres_data: driver: local redis_data: static_files: prometheus_data: external: true # 외부에서 관리되는 볼륨 networks: app-network: driver: bridge ipam: config: - subnet: 172.20.0.0/16 configs: nginx_config: file: ./nginx/nginx.conf secrets: db_password: file: ./secrets/db_password.txt
이것이 Docker Compose YAML 파일에서 정의할 수 있는 모든 구조와 옵션들입니다! 🚀<a class="internal-link" data-href="posts/100 Resources/103 NewDevelopments/Docker 기본.md" href=".html" target="_self" rel="noopener nofollow">Docker 기본</a>]]></description><link>300-resources/310-개발공부/318-devops/docker-compose-yaml-파일-내부-구조.html</link><guid isPermaLink="false">300 Resources/310 개발공부/318 devops/Docker Compose YAML 파일 내부 구조.md</guid><pubDate>Sun, 21 Dec 2025 10:37:15 GMT</pubDate></item><item><title><![CDATA[Docker 기본]]></title><description><![CDATA[
환경 격리가 필요한 상황: 같은 서버 내에서 여러 애플리케이션의 환경을 분리해야 할 때
리소스 효율성: 서버 내의 격리된 환경에서 실행하여 낭비되는 리소스를 최소화
개발 환경 통일: 개발, 테스트, 운영 환경을 동일하게 구성할 때
마이크로서비스 아키텍처: 각 서비스를 독립적으로 배포하고 관리할 때 가벼움: Guest OS 없이 동작하여 VM보다 빠르고 효율적
빠른 환경 구성: docker-compose up을 통해 빠른 개발환경 세팅 가능
환경 독립성: 로컬환경과 무관하게 다양한 버전으로 테스트 가능
이식성: 어떤 환경에서든 동일하게 실행
버전 관리: 이미지 태그를 통한 버전 관리
Docker 명령어는 docker [대상] [명령어] [옵션] 형태로 구성됩니다.
-it : Interactive + TTY (터미널 접속용, 디버깅 시 주로 사용)
-d : Detach 모드 (백그라운드 실행)
-f : Force (강제 실행)
-a : All (모든 항목 표시)
-q : Quiet (ID만 출력, 다른 명령어와 조합할 때 유용)
-p : Port mapping (호스트:컨테이너 포트 연결)
--name : 컨테이너에 이름 지정
--rm : 컨테이너 종료 시 자동 삭제
# 실행 중인 컨테이너 확인
docker ps # 모든 컨테이너 확인 (중지된 것 포함)
docker ps -a # 컨테이너 ID만 출력
docker ps -q
# 기본 실행 (run = create + start)
docker container run [옵션] 이미지명[:태그] [실행할명령어] # 예시: CentOS 컨테이너를 백그라운드에서 실행
docker container run -dit --name myContainer centos:8 /bin/bash # 웹서버 실행 (포트 매핑)
docker container run -d -p 8080:80 --name web01 httpd # 일회성 실행 (종료 시 자동 삭제)
docker container run --rm -it centos:8 /bin/bash
# 컨테이너 중지
docker container stop myContainer # 컨테이너 강제 종료 후 삭제
docker container rm -f myContainer # 컨테이너 재시작
docker container restart myContainer
# 실행 중인 컨테이너에 접속
docker container attach myContainer # 컨테이너에서 새로운 명령어 실행
docker container exec -it myContainer /bin/bash # 컨테이너 로그 확인
docker container logs myContainer # 실시간 로그 확인
docker container logs -f myContainer Attach 모드: 사용자가 컨테이너 프로세스(PID=1)의 입출력과 연결된 상태
docker container run -it --name ping01 centos:8 /usr/bin/ping localhost
Run Detach 모드: 사용자가 컨테이너 프로세스의 입출력과 분리된 상태 (백그라운드 실행)
docker container run -dit --name ping02 centos:8 /usr/bin/ping localhost
Run Detach 단축키: 컨테이너 내부에서 Ctrl + P + Q # 작업 디렉토리 및 환경변수 설정
docker container run -it --name koo04 \ --workdir="/workspace" \ --env MYNAME=koo \ centos:8 # 환경변수 파일로 설정
docker container run -it --env-file=env.txt centos:8 # 재시작 정책 설정 (실패 시 최대 2번까지 재시작)
docker container run -d --restart=on-failure:2 --name koo06 centos:8
# 호스트 → 컨테이너
docker container cp ./test.txt myContainer:/root/ # 컨테이너 → 호스트
docker container cp myContainer:/root/test.txt ./
# 중지된 모든 컨테이너 삭제
docker container prune # 실행 중인 모든 컨테이너 강제 삭제
docker container rm -f $(docker container ps -aq)
# 로컬 이미지 목록 확인
docker image ls # 이미지 다운로드
docker image pull nginx:latest # 이미지 삭제
docker image rm nginx:latest # 사용하지 않는 이미지 정리
docker image prune
# Volume 생성
docker volume create myvolume # Volume을 사용한 컨테이너 실행
docker container run --rm -it \ --mount type=volume,source=myvolume,destination=/root \ --name c1 centos:8 # 호스트 디렉토리 마운트
docker container run -it -v /host/path:/container/path centos:8
# 서비스 실행
docker-compose up # 백그라운드 실행
docker-compose up -d # 서비스 중지 및 제거
docker-compose down # 로그 확인
docker-compose logs
Run# 직전 명령어의 실행 결과 확인
echo $?
# 성공: 0, 실패: 1~255
Run# 모든 컨테이너 중지
docker stop $(docker ps -q) # 모든 이미지 삭제
docker rmi $(docker images -q) # 시스템 전체 정리 (사용하지 않는 모든 리소스 삭제)
docker system prune -a
Run
컨테이너는 일회용: 수정보다는 삭제 후 재생성하는 것이 Docker의 철학
데이터 보존: 중요한 데이터는 반드시 Volume이나 Bind Mount 사용
포트 충돌: 같은 포트를 여러 컨테이너가 사용하지 않도록 주의
리소스 관리: 사용하지 않는 컨테이너와 이미지는 정기적으로 정리
]]></description><link>300-resources/310-개발공부/318-devops/docker-기본.html</link><guid isPermaLink="false">300 Resources/310 개발공부/318 devops/Docker 기본.md</guid><pubDate>Sun, 21 Dec 2025 10:37:11 GMT</pubDate></item><item><title><![CDATA[Webview StackRouter Push]]></title><description><![CDATA[
react-native의 webview에서 화면을 전환하게 되면 webview 상에서는 화면이 이동되지만 실제 모바일상에서는 동일화면 내의 webview의 내용이 바뀌게 된다. 이렇게 되면 기존 모바일에서 이용하는 뒤로가기나 모바일 history를 통해 처리했던 기능들을 못하게 된다. 그래서 이를 해결하기 위해 모바일의 history를 조정해 주는 기능을 만들어야한다.
<a class="internal-link" data-href="400 Archives/History API.md" href=".html" target="_self" rel="noopener nofollow">History API</a>// 전역 타입 선언, react-natvie-webview 안에는 window.ReactNativeWebview 객체가 있음. 있으면 postMessage 사용을 위해 타입설정
declare global { interface Window { ReactNativeWebView?: { postMessage: (message: string) =&gt; void; }; }
} // react native app 환경인지 판단
export const isApp = () =&gt; { return typeof window !== "undefined" &amp;&amp; !!window.ReactNativeWebView;
}; // ReactNative Webview에 postMessage 요청
const sendRouterEvent = (path: string): void =&gt; { window.ReactNativeWebView?.postMessage( JSON.stringify({ type: "ROUTER_EVENT", data: path }) );
}; // 뒤로가기 하는 경우
export const stackRouterBack = (router: any) =&gt; { isApp() ? sendRouterEvent("back") : router.back();
}; // push 하는 경우
export const stackRouterPush = (router: any, url: string) =&gt; { isApp() ? sendRouterEvent(url) : router.push(url);
}; // 해당 화면에서 useRequestOnMessage를 통해 커스텀 hook을 통해 onMessage를 통해 웹뷰로부터 받는 메세지를 확인import useRequestOnMessage from "@/hooks/useRequestOnMessage";
import { Stack, useRouter } from "expo-router";
import React from "react";
import { Platform, SafeAreaView, ScrollView, StatusBar, StyleSheet, RefreshControl } from "react-native";
import WebView from "react-native-webview";
import useScrollRefresh from "@/hooks/useScrollRefresh"; // 새로 만든 커스텀 훅 import export default function SearchPage() { const router = useRouter(); const targetUrl = process.env.EXPO_PUBLIC_THREE_URL! as string; const requestOnMessage = useRequestOnMessage(router, targetUrl); const { refreshing, onRefresh, webViewRef } = useScrollRefresh(); // 커스텀 훅 사용 return ( &lt;SafeAreaView style={styles.container}&gt; &lt;Stack.Screen options={{ headerShown: false, }} /&gt; &lt;ScrollView contentContainerStyle={{ flex: 1 }} refreshControl={ &lt;RefreshControl refreshing={refreshing} onRefresh={onRefresh} /&gt; } &gt; &lt;WebView ref={webViewRef} style={styles.webview} onMessage={requestOnMessage} source={{ uri: process.env.EXPO_PUBLIC_THREE_URL! + "/music" }} allowsFullscreenVideo={true} javaScriptEnabled={true} /&gt; &lt;/ScrollView&gt; &lt;StatusBar hidden={false} /&gt; &lt;/SafeAreaView&gt; );
} const styles = StyleSheet.create({ container: { flex: 1, paddingTop: Platform.OS === "android" ? StatusBar.currentHeight : 0, // 안드로이드에서 StatusBar 높이만큼 패딩 추가 }, webview: { flex: 1, },
}); // useRequestOnMessage customHook 에서 온 이벤트가 ROUTER_EVENT 일경우에 같이온 path의 값에 따라서 react-natvie 화면이동. 이때 push에 보낼 정보를 담는다.import { Router } from "expo-router";
import { WebViewMessageEvent } from "react-native-webview"; type PathType = "/chat" | "/schedule" | "/spring" | "/three";
const validPaths: PathType[] = ["/chat", "/schedule", "/spring", "/three"]; function isValidPath(path: string): path is PathType { return validPaths.includes(path as PathType);
} const useRequestOnMessage = (router: Router, targetUrl: string) =&gt; { const requestOnMessage = async (e: WebViewMessageEvent): Promise&lt;void&gt; =&gt; { const nativeEvent = JSON.parse(e.nativeEvent.data); if (nativeEvent?.type === "ROUTER_EVENT") { const path = nativeEvent.data; const title: string = nativeEvent.title || "default title"; console.log("path :", path); if (path === "back") { router.back(); } else if (path == "/") { router.push({ pathname: `/`, params: { url: `${targetUrl}${path}`, id: `${targetUrl}${path}`, title: `${title}`, }, }); } else if (path == "/music") { router.push({ pathname: `/(tabs)/`, params: { url: `${targetUrl}${path}`, id: `${targetUrl}${path}`, title: `${title}`, }, }); } else if (isValidPath(path)) { router.push({ pathname: `/(tabs)${path}`, params: { url: `${targetUrl}${path}`, id: `${targetUrl}${path}`, title: `${title}`, }, }); } else { router.push({ pathname: "/test/[id]", params: { url: `${targetUrl}${path}`, isStack: "Stack", id: `${targetUrl}${path}`, title: `${title}`, }, }); } } }; return requestOnMessage;
}; export default useRequestOnMessage; // router.push({params})의 params를 useLocalSearchParams() 로 가져올 수 있다.import Colors from "@/constants/Colors";
import useRequestOnMessage from "@/hooks/useRequestOnMessage";
import { Feather } from "@expo/vector-icons";
import { Stack, useLocalSearchParams, useRouter } from "expo-router";
import React from "react";
import { StatusBar, StyleSheet, TouchableOpacity, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { WebView, WebViewMessageEvent } from "react-native-webview"; export default function BookMarkDetailPage() { const router = useRouter(); const { id } = useLocalSearchParams(); const targetId = Array.isArray(id) ? id[0] : id; const targetUrl = "https://koo-sang-threejs.vercel.app"; const requestOnMessage = useRequestOnMessage(router, targetUrl); return ( &lt;SafeAreaView style={styles.container}&gt; &lt;Stack.Screen options={{ headerShown:false }} /&gt; &lt;WebView style={styles.webview} source={{ uri: targetId }} allowsFullscreenVideo={true} javaScriptEnabled={true} onMessage={requestOnMessage} /&gt; &lt;TouchableOpacity onPress={() =&gt; router.back()} style={styles.backButton} &gt; &lt;View style={styles.backButtonInner}&gt; &lt;Feather name="arrow-left" size={20} color={Colors.black} /&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;StatusBar hidden={false} /&gt; &lt;/SafeAreaView&gt; );
} const styles = StyleSheet.create({ container: { flex: 1, }, webview: { flex: 1, }, backButton: { position: 'absolute', top: 40, // 상태바 아래 위치를 적절히 설정 left: 10, // 화면 왼쪽에서 10px 떨어진 위치 borderRadius: 10, padding: 4, z 1, // WebView 위에 위치하도록 설정 }, backButtonInner: { padding: 6, borderRadius: 10, },
}); ]]></description><link>300-resources/310-개발공부/317-mobile/webview-stackrouter-push.html</link><guid isPermaLink="false">300 Resources/310 개발공부/317 MOBILE/Webview StackRouter Push.md</guid><pubDate>Sun, 21 Dec 2025 10:37:07 GMT</pubDate></item><item><title><![CDATA[React Native 기본]]></title><description><![CDATA[
facebook 에서 만든 하이브리드 모바일 라이브러리 react 는 사실 상태관리 라이브러리인 것이고 실제 디바이스에 관련된 라이브러리는 다음과 같다.
web : react-dom
mobile : react-natvie
desktop-app : react-electron 로컬 설정
<a class="internal-link" data-href="posts/100-Resources/103 Developments/모바일_Emulator_환경_설정.md" href=".html" target="_self" rel="noopener nofollow">모바일<em></em>환경_설정</a>Emulator
기능
build
배포
npx @react-native-community/cli@latest init [프로젝트명]
# download- expo
npx create-expo-app@latest # reset 작업
npm run reset-project
npm install -g eas-cli eas login eas build --platform android Expo Tools
-- emulator 실행관련<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@bi-sz/ReactNative-Expo-Android-Studio-%EC%97%90%EB%AE%AC%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%97%B0%EA%B2%B0" target="_self">https://velog.io/@bi-sz/ReactNative-Expo-Android-Studio-%EC%97%90%EB%AE%AC%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%97%B0%EA%B2%B0</a>-- expo 통한 배포 관련<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.expo.dev/get-started/start-developing/" target="_self">https://docs.expo.dev/get-started/start-developing/</a># eas-cli 는 deprecated 됐음. expo 이용하려면 사용하지 않아야함
# pm install -g eas-cli eas build --platform android
-- 어플주소<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://expo.dev/artifacts/eas/32YqvChEKPMeZD8Vecbkh3.aab" target="_self">https://expo.dev/artifacts/eas/32YqvChEKPMeZD8Vecbkh3.aab</a>
파일베이스 라우팅( react랑 동일)
layout 파일 적용시_layout //stack 구조로 export defualt function RootLayout(){ return ( &lt;Stack&gt; &lt;/Stack&gt; )
}
import {StatusBar} from 'expo-status-bar';
import {StyleSheet, Text, TextInput, View, Button, Pressible} from 'react-native';
const exImage = require("./assets/example-img.png") const View = ()=&gt;{ return ( &lt;ScrollView style={styles.container}&gt; &lt;ImageBackground source={exImage} style={{flex:1]}}&gt; &lt;View&gt; &lt;Image source={logoImg}/&gt; &lt;Image source={{uri:"https://picsum.photos/200"}} &lt;Text&gt;IMAGE TEXT&lt;/Text&gt; &lt;Text&gt;&lt;/Text&gt; &lt;/View&gt; &lt;View&gt; &lt;TextInput/&gt; &lt;/View&gt; &lt;View&gt; //ios에서는 color 적용 안됨. &lt;Button title="Press" onPress={()=&gt;console.log("Button Press")} color="midnightblue" disabled/&gt; &lt;/View&gt; &lt;Pressable onPress={()=&gt;{}}&gt; &lt;Image source={logoImg} style={{width:300, height:300}}/&gt; &lt;/Pressable&gt; &lt;/ImageBackground&gt; &lt;StatusBar/&gt; &lt;/ScrollView&gt; )
} const styles = StyleSheet.create({ container: { flex: 1, backgroundColor: '#fff' }
}) const styles = StyleSheet.create({ styleView: { flex: 1, backgroundColor: '#fff', width:200, height:200, padding:50 }, styleText: { color:"white" }
})
길게 누르는 동작시 onLongPress 동작시 onLongPress 동작이 도중에 생긴다.Press 이벤트 동작 방식
onPressIn =&gt; onPressOut =&gt; onPress
길게 눌렀을 때
onPressIn =&gt; onLongPress =&gt; onPressOut
const View = ()=&gt;{ const [isModalVisible, setModalVisible]= useState&lt;boolean&gt;(false); return ( &lt;View&gt; &lt;Pressible onPress={()=&gt;{setModalVisible(pre=&gt;!pre)}}&gt; &lt;Text&gt;Modal Open&lt;/Text&gt; &lt;/Pressible&gt; &lt;Modal visible={isModalVisible} onRequestClose={()=&gt;setIsModalVisible(false)} animationType="slide" presentationStyle="pageSheet"&gt; // presentationStyle 은 ios only &lt;View style={styles.modalContent}&gt; &lt;Text&gt;Modal&lt;/Text&gt; &lt;Pressible&gt; &lt;Text&gt;Modal Close&lt;/Text&gt; &lt;/Pressible&gt; &lt;/View&gt; &lt;/Modal&gt; &lt;/View&gt; )
} const styles = StyleSheet.create({ modalContent:{ flex:1, backgroundColor: "lightblue", padding: 60 }
}) ]]></description><link>300-resources/310-개발공부/317-mobile/react-native-기본.html</link><guid isPermaLink="false">300 Resources/310 개발공부/317 MOBILE/React Native 기본.md</guid><pubDate>Sun, 21 Dec 2025 10:37:04 GMT</pubDate></item><item><title><![CDATA[Android Studio 삭제 후 재설치 관련]]></title><description><![CDATA[
emulator가 그동안 사용에서 문제가 많았어서 한번 아예 밀고 다시 설치하겠다는 심정으로 삭제를 진행하였다. 제어판에서 android studio 삭제( android user setting 포함)
“public/image/Pasted image 20250127214003 1.png” could not be found.1 C/D 드라이브 사용자 내부
1) c드라이브\사용자 또는 Users\자신의 이름 폴더
**2) c드라이브\사용자 또는 Users\자신의 이름 폴더**AppData\Local**
3)&nbsp;c드라이브\사용자 또는 Users\자신의 이름 폴더****AppData\Local\Google**
**4)&nbsp;**c드라이브\사용자 또는 Users\자신의 이름 폴더****AppData\Roaming\Google**** “public/image/Pasted image 20250127214305 1.png” could not be found.1<img alt="800 References/801 Image/2025/08/Android Studio 삭제 후 재설치 관련-1.png" src="800-references/801-image/2025/08/android-studio-삭제-후-재설치-관련-1.png" target="_self">2<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://40chungi.tistory.com/177" target="_self">https://40chungi.tistory.com/177</a><br><img src="800-references/801-image/2025/08/android-studio-삭제-후-재설치-관련-1.png" target="_self">2]]></description><link>300-resources/310-개발공부/317-mobile/android-studio-삭제-후-재설치-관련.html</link><guid isPermaLink="false">300 Resources/310 개발공부/317 MOBILE/Android Studio 삭제 후 재설치 관련.md</guid><pubDate>Sun, 21 Dec 2025 10:37:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[웹뷰 환경에서의 이벤트 발생 순서]]></title><description><![CDATA[웹뷰는 네이티브 앱 안에 임베드된 브라우저이므로, 일반 모바일 브라우저와 다소 다른 특성을 가집니다.1. touchstart ← 터치 시작
2. touchend ← 터치 종료
3. ⏰ 300ms 지연 ← 여전히 존재 (설정에 따라 다름)
4. mousedown ← 가상 마우스 이벤트
5. mouseup ← 가상 마우스 이벤트
6. click ← 가상 클릭 이벤트
1. touchstart ← 터치 시작
2. touchend ← 터치 종료
3. click ← 지연 없이 즉시 발생
일반 모바일과 거의 동일:
1. touchstart
2. touchend 3. 300ms 지연 (설정으로 제거 가능)
4. mousedown
5. mouseup
6. click
더 최적화됨:
1. touchstart
2. touchend
3. click (지연 최소화)
네이티브 최적화:
1. touchstart
2. touchend
3. click (거의 즉시)
// 300ms 지연 제거 설정
webView.getSettings().setBuiltInZoomControls(false);
webView.setInitialScale(100);
// 터치 지연 최소화
webView.configuration.allowsInlineMediaPlayback = true
Run&lt;button onTouchStart={(e) =&gt; { e.preventDefault(); e.stopPropagation(); handlePress(); }} onClick={(e) =&gt; { // 터치 디바이스에서는 무시 if (!('ontouchstart' in window)) { handlePress(); } }} style={{ touchAction: 'manipulation' }}
&gt;
Run&lt;button onPointerDown={handlePress} style={{ touchAction: 'manipulation' }}
&gt;
Run
touchstart/touchend 사용 - 가장 빠른 반응
touch-action: manipulation - CSS로 지연 제거
preventDefault() - 기본 동작 차단
이벤트 중복 방지 - 터치와 클릭 이벤트 분리
웹뷰는 앱별로 설정이 다르므로, 가장 호환성이 좋은 touchstart 이벤트를 사용하는 것이 안전합니다! 🚀]]></description><link>300-resources/310-개발공부/317-mobile/웹뷰-환경에서의-이벤트-발생-순서.html</link><guid isPermaLink="false">300 Resources/310 개발공부/317 MOBILE/웹뷰 환경에서의 이벤트 발생 순서.md</guid><pubDate>Sun, 21 Dec 2025 10:36:55 GMT</pubDate></item><item><title><![CDATA[Prompt Enginering]]></title><description><![CDATA[프롬프트 엔지니어링이란 프롬프트를 잘 쓰는 방식에 대한 방법론이다.위와같은 질문을 하는 경우가 많다. 맞을 수도 있다. 미래에 AI가 나와서 알아서 척척한다면 상관없다. 하지만 지금 LLM 모델을 기반으로 나아가고 있는 AI에서는 사람과 AI가 맞닿아 있는 부분이다. 멍청한 질문을 던져도 똑똑하게 대답하는 AI는 나올 수 있지만 애초에 똑똑하게 질문 던지면 더 똑똑한 대답이 나올건데 공부 안할 이유가 없다.lee boonstra 라는 사람이 프롬프트 엔지니어링 기법에 대한 간단한 설명을 했다 이걸 기본으로 한번 얘기를 해보자LLM은 기본적으로 질문을 바탕으로 다음 단어가 어떻게 나올지에 대한 모델임.
프롬프트에 따라서 이전토큰, 학습데이터에 대해서 학습함.
output length : 내놓는 답변길이
sampling controls : temperature : degree of randomness(창의성관련), 1일수록 창의
top-k : 최상위 토큰중 몇개를 가져올건지 적을수록 정확도 높임.
top-p : 예측점수 하한제한 보통 0.2 , 0.95, 30 으로 사용함.one-shot &amp; few-shot PROMPT: 예시의 갯수
최적은 3~5 다양하게 백틱 3개 안에 예시를 넣어주면 잘 인식함
JSON Response:{ "key":"value"
}
system propmpting : 시스템 자체에 넣을 PROMPTcontextual prompting : 참고해야할 배경지식role prompting : 역할 프롬프트// 예시에서 사용할 예제는 별로 없을때도 비교적 정확한 답변을 받고 싶을때단계별로 생각해보자 / Let's think step by step
하지말아야할 것이 아닌 해야할 것으로 설계할것// 질의 응답을 나타내는 모델질문사항
A:
아래 문맥을 고려해서 질문에 답변해 줘. 답변은 짧고 간결하게 해 줘. 답변이 정확하지 않다면, 「확실치 않은 대답」이라고 응답해 줘. 문맥: Teplizumab은 Ortho Pharmaceutical이라는 뉴저지의 제약 회사에서 유래했다. 그곳에서, 과학자들은 OKT3라는 항체의 초기 버전을 만들어 냈다. 원래 쥐에서 유래된 이 분자는 T 세포의 표면에 결합하여 세포를 죽이는 잠재력을 제한할 수 있다. 1986년, 신장 이식 후 장기 거부 반응 예방을 위해 승인되어 인간이 사용할 수 있는 최초의 치료용 항체가 되었다. 질문: OKT3는 어디서 유래했는가? 답변: """
Table TABLE1, columns = [COLA, COL1_B, COL1_C]
Table TABLE2, columns = [COLA, COL2_B, COL2_C]
TABLE1, TABLE2를 INNER JOIN생성해
""" <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.promptingguide.ai/kr" target="_self">https://www.promptingguide.ai/kr</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=EZqY_mnHfTI&amp;t=467s" target="_self">https://www.youtube.com/watch?v=EZqY_mnHfTI&amp;t=467s</a>]]></description><link>300-resources/310-개발공부/316-ai/prompt-enginering.html</link><guid isPermaLink="false">300 Resources/310 개발공부/316 AI/Prompt Enginering.md</guid><pubDate>Sun, 21 Dec 2025 10:36:51 GMT</pubDate></item><item><title><![CDATA[OpenSpec 라이브러리]]></title><description><![CDATA[OpenSpec 라이브러리는 바이브코딩을 위한 유지보수 중심의 도구로, 기존 코드를 수정하는 데 최적화되어 있습니다.]]></description><link>300-resources/310-개발공부/316-ai/openspec-라이브러리.html</link><guid isPermaLink="false">300 Resources/310 개발공부/316 AI/OpenSpec 라이브러리.md</guid><pubDate>Sun, 21 Dec 2025 10:36:47 GMT</pubDate></item><item><title><![CDATA[MCP란 무엇일까]]></title><description><![CDATA[MCP란 model Context Protocol 이다. 쉽게 말하면 모델이 이해할 수 있게 정의해 놓은 프로토콜이다. 넓은 개념으로는 기존의 FUNCTION CALL하는 역할을 이제 규약으로 해놓음으로 LLM이 할 수 있는 업무 범위를 넓히는 일이다.사용자로부터 프롬프트를 받아서 그 프롬프트 내부의 내용을 기반으로 BACKEND 단에서 발생하는 무엇이든 할 수 있다. 나는 이것을 BACKEND의 LLM화가 진행된게 아닌지 생각한다. LLM이 처음 나왔을 때 AI가 많이 발전하면 굳이 논리적 설계 필요없이 AI가 백엔드의 실행을 해주면되지 않는가에 대한 말이 있었다. 나는 그 초기 모델이라고 생각한다.기본적으로 사용단에서는 아래와같이 filesystem 이라는 모듈의 큰 명칭을 정해주고 해당 모듈을 실행시킬 명령어를 넣는다."mcpServers": { "filesystem": { "command": "npx", "args": [ "-y", "@modelcontextprotocol/server-filesystem", "C:\\work\\cursor", "C:\\work\\mcp" ] }
} 아래와같이 특정 내부 특정 port로 mcp 서버를 실행하고 해당 메세지를 선언한다.
여기서 중요한 점은 주석을 꼼꼼히 달아야 llm이 이 주석을 읽고 어떤 코드인지 빠르게 파악할 수 있다는 점이다. swagger 같은 느낌으로 주석을 달아주도록 하자.// python 코드from mcp.server.fastmcp import FastMCP
import sys # MCP 서버 생성
mcp = FastMCP(name="tutorial_1", host="127.0.0.1", port=5000, timeout=30) # 간단한 에코 도구
@mcp.tool()
def echo(message: str) -&gt; str: return message + " 라는 메시지가 입력되었습니다. 안찍어 볼 수 없죠! hello world!" # 서버 실행
mcp.run()
// js 코드import { FastMCP } from "fastmcp";
import { z } from "zod"; const server = new FastMCP({ name: "My Server", version: "1.0.0", }); server.addTool({ name: "add", description: "Add two numbers", parameters: z.object({ a: z.number(), b: z.number(), }), execute: async (args) =&gt; { return String(args.a + args.b); }, }); server.start({ transportType: "stdio", }); LLM이 FUNCTION 을 실행시키다보니 보안상 문제가 생길 수가 있다. 그래서 CLAUDE는 FUNCTION을 실행할 때마다 질문을 꼭 넣도록 강제하였다. 남이 올린 MCP를 사용할 때는 코드에 대해서 대충은 살펴보는것이 매우 중요하다.나는 이 MCP를 통해서 질문하다가 끝났을때 이제까지 질문했던 내용들의 정리하여 문서로 남기는 작업에 사용하는것.
<a class="internal-link" data-href="n8n.md" href=".html" target="_self" rel="noopener nofollow">n8n</a>을 통해서 단순로직이 아닌 상세로직의 실행을 하도록 하는게 필요하다.]]></description><link>300-resources/310-개발공부/316-ai/mcp란-무엇일까.html</link><guid isPermaLink="false">300 Resources/310 개발공부/316 AI/MCP란 무엇일까.md</guid><pubDate>Sun, 21 Dec 2025 10:36:43 GMT</pubDate></item><item><title><![CDATA[SQL 응용]]></title><description><![CDATA[
GROUP BY를 쓰다보면 합계값하고 일부는 GROUP BY 데이터중 특정행의 값을 가져와야한다. 그럴 때 사용한다.
상황 : 테이블을 group by 하는데 이 테이블은 pk1, pk2, col1, col2, col3 으로 이루어 있고 group by를 pk1으로 한다. col1의 합계를 가져오면서 col2='B'인 것 중 col1이 가장 큰 행의 col3의 합을 구하고 싶어
DENSE_RANK FIRST 는 정렬 후 첫번째
SELECT pk1, SUM(col1) AS total_col1, MAX(col3) KEEP ( DENSE_RANK FIRST ORDER BY CASE WHEN col2 = 'B' THEN col1 ELSE NULL END DESC ) AS col3_with_max_col1
FROM sample_table
GROUP BY pk1; FRONT로 데이터를 던져줄 때 집계 단위를 던져줘야하는 경우는 다음과 같이 쓴다. 1,2,3,4분기의 데이터를 PIVOTTING한 예시
SELECT year, SUM(CASE WHEN quarter = 'Q1' THEN sales ELSE 0 END) AS Q1, SUM(CASE WHEN quarter = 'Q2' THEN sales ELSE 0 END) AS Q2, SUM(CASE WHEN quarter = 'Q3' THEN sales ELSE 0 END) AS Q3, SUM(CASE WHEN quarter = 'Q4' THEN sales ELSE 0 END) AS Q4
FROM sales_data
GROUP BY year
ORDER BY year DESC; limit offset은 우선 전체적으로 조회를 한 뒤에 offset과 Limit을 적용하기 때문에 offset 값이 커질수록 앞에 값도 결국 다 읽는 형태라 성능이 저하된다. 따라서 맨마지막에 보여주는 key를 특정해서 해당 key 이후를 보여줄 수 있도록 제한조건으로 둔다.
-- Keyset Pagination 방식
SELECT *
FROM posts
WHERE id &gt; :last_id -- 이전 페이지에서 마지막으로 조회한 id (예: 150)
ORDER BY id ASC
LIMIT 10; ]]></description><link>300-resources/310-개발공부/315-db/sql-응용.html</link><guid isPermaLink="false">300 Resources/310 개발공부/315 DB/SQL 응용.md</guid><pubDate>Sun, 21 Dec 2025 10:31:23 GMT</pubDate></item><item><title><![CDATA[Lost Update(갱신손실) 문제]]></title><description><![CDATA[read한 데이터를 누군가 update 한 뒤 다시 옛날데이터 update함.
1번 사용자가 데이터를 조회
2번사용자가 해당 데이터의 col2를 업데이트함.
1번 사용자가 col1의 데이터를 업데이트 하면서 2번사용자의 col2의 데이터를 다시 옛날 데이터로 업데이트함.
버전관리 방식( 낙관적 동시성 제어중 하나)
내 어플리케이션의 경우 충돌이 잦지 않고 조회를 하는 기능에 영향을 주고 싶지 않다. 따라서 modified_at을 두어 변경시간을 특정하고 마지막으로 조회한 시점의 변경시간과 update 한 시점의 변경시간과 같은 경우에만 업데이트를 하도록한다.데이터를 update 할 때 update 버전을 가지고 있거나 혹은 데이터 자체적으로 update 타임스탬프로 관리한다.
DB자체적으로 여유가 있다면 loging 을 통해 전체 버전관리 전체 db관리를 하며, 여유가 없다면 modified_at을 두어 이게 최종버전을 보는건지 확인하는 것이 좋다.첫번째 경우는 전체 버전이므로 어떤게 application 단에서 어떤 값을 조회했고 update했는지가 명확하기 때문에 구분해서 업데이트 해줄 수 있다.
두번째 경우는 변경시간만 알 뿐 특정을 하지 못한다. 따라서 1번사용자가 변경을 할 때 누군가 데이터를 변경했고 재조회를 해야한다는 알람을 다시 주어야한다. 이 경우 사용자경험이 떨어지게 된다.-- 버전관리
UPDATE my_table
SET col1 = ?, version = version + 1
WHERE id = ? AND version = ? -- modified_at 관리
UPDATE my_table
SET col1 = ?, modified_at= sysdate
WHERE id = ? AND modified_at = ? SELECT 할 때 다른 CONNECTION에서 조회를 못하도로 LOCK을 건 뒤 UPDATE를 진행한다.-- 트랜잭션 시작
BEGIN -- 특정 행에 대해 즉시 잠금 획득 SELECT col1, col2 FROM my_table WHERE id = ? FOR UPDATE; -- 이후 해당 행을 안전하게 업데이트 UPDATE my_table SET col1 = ? WHERE id = ?; -- 작업 완료 후 커밋 (잠금 해제) COMMIT;
END;
대부분의 상황에서는 버전관리로 업데이트를 한다. 즉각적잠금의 경우 하나의 프로세스를 최대한 짧게 가져가야 시스템 성능을 최적화 할 수 있다.]]></description><link>300-resources/310-개발공부/315-db/lost-update(갱신손실)-문제.html</link><guid isPermaLink="false">300 Resources/310 개발공부/315 DB/Lost Update(갱신손실) 문제.md</guid><pubDate>Sun, 21 Dec 2025 10:31:18 GMT</pubDate></item><item><title><![CDATA[DBeaver 단축키]]></title><description><![CDATA[
데이터 베이스 관리도구로 오픈소스이며 무료(community버전)이다.
어디서나 부담없이 쓸 수 있다는게 장점이며 나름 기름도 갖추어져서 어느정도 익혀두면 좋다. ERD확인 데이터간 관계를 파악하기 위해 ERD를 확인할 수 있다. 보통 DATABASE DB를 클릭하면 PROPERTIES 옆에 엔티티 관계도가 나오는데 supabase란 외부 SAAS를 사용하다보니 밑에는 따로 안나온다. 당황하지 않고 좌측 하단에 보면 Diagrams에 보면 관계도를 볼 수 있다.여기서는 컬럼추가 및 관계도를 그릴 때 ]]></description><link>300-resources/310-개발공부/315-db/dbeaver-단축키.html</link><guid isPermaLink="false">300 Resources/310 개발공부/315 DB/DBeaver 단축키.md</guid><pubDate>Sun, 21 Dec 2025 10:31:13 GMT</pubDate></item><item><title><![CDATA[DB정규화 문제]]></title><description><![CDATA[일부 오래된 잘못된 db로 설계된 케이스가 있다. 컬럼명이 lot1, lot2 ~ lot30까지 있으며 이 컬럼명하고 대비되는 컬럼이 wt1,wt2.... wt30 이런방식으로 되어 있다. 이런 코드는 하나의 데이터를 추가할 때마다 컬럼이 30개씩 발생한다. 이걸 어떻게 고치면 좋을까 고민이 필요하다.
방식은 간단하다 다음과 같이 lot로 지정되어 있는 부분을 행으로 내리는 것이다 문제는 기존에 사용자가 동작하는 방식에서 영향을 주지 않거나 반대로 영향을 주는 부분을 모두 찾아 문제없이 고칠 수 있어야한다는 것이다.
코드는 다음과 데이터를 하나의 행으로 결과를 조회한다음. 해당행에 있는 데이터를 순차적으로 화면의 데이터에 넣는 방식을 택하고 있다.SELECT, INSERT, UPDATE 등의 쿼리에서 사용했다.
DB정규화 작업을 진행하였다.
추가 결정사항
기존에 SELECT 하는 부분은 수정없이 쿼리에서도 동일하게 하나의 행으로 데이터를 전달하기 =&gt; 쿼리,DB 단만 작업
JOIN 해서 중첩되는 쿼리 여러줄로 내려가기
SELECT 문에 대한 변경은 다음과 같이 MAX를 사용하였다. 원래 단일항목을 가져오는 쿼리여서 MAX(CASE WHEN ~) 방식을 사용해도 크게 문제가 없을 것으로 보인다.SELECT T.KEY1, T.KEY2, T.KEY3, T.TOTAL_COLUMN1, MAX(CASE WHEN D.STEP_NO = 1 THEN D.DETAIL_COLUMN1 END) AS DETAIL_COLUMN1_1, MAX(CASE WHEN D.STEP_NO = 2 THEN D.DETAIL_COLUMN1 END) AS DETAIL_COLUMN1_2, MAX(CASE WHEN D.STEP_NO = 3 THEN D.DETAIL_COLUMN1 END) AS DETAIL_COLUMN1_3, MAX(CASE WHEN D.STEP_NO = 1 THEN D.DETAIL_COLUMN2 END) AS DETAIL_COLUMN2_1, MAX(CASE WHEN D.STEP_NO = 2 THEN D.DETAIL_COLUMN2 END) AS DETAIL_COLUMN2_2, MAX(CASE WHEN D.STEP_NO = 3 THEN D.DETAIL_COLUMN2 END) AS DETAIL_COLUMN2_3
FROM TB_TOTAL_DATA T
LEFT JOIN TB_DETAIL_DATA D
ON T.KEY1 = D.KEY1 AND T.KEY2 = D.KEY2 AND T.KEY3 = D.KEY3
GROUP BY T.KEY1, T.KEY2, T.KEY3, T.TOTAL_COLUMN1; UPDATE문은 2번 하는방식으로 변경해야하며 반복문을 사용해서 여러번 I/O가 일어난다. 30건이나되니 생각보다 부하가 크다. / 기존에는 무조건 등록하면 UPDATE를 했지만 이렇게되면 화면단에서 변경된 데이터를 골라서 UPDATE하는 것이 낫다. 또한 하나의 TRANSACTION으로 업데이트하며 DB UPDATE순서를 정해서 LOCK걸리는걸 방지해야한다.UPDATE TB_TOTAL_DATA
SET TOTAL_COLUMN1 = 'UpdatedValue'
WHERE KEY1 = 'A' AND KEY2 = 'B' AND KEY3 = 'C'; UPDATE TB_DETAIL_DATA
SET DETAIL_COLUMN1 = 'Detail1', DETAIL_COLUMN2 = 'Detail3'
WHERE KEY1 = 'A' AND KEY2 = 'B' AND KEY3 = 'C' AND STEP_NO = 1; UPDATE TB_DETAIL_DATA
SET DETAIL_COLUMN1 = 'Detail2', DETAIL_COLUMN2 = 'Detail4'
WHERE KEY1 = 'A' AND KEY2 = 'B' AND KEY3 = 'C' AND STEP_NO = 2;
여러행으로 나와서 화면단 JAVA단에서 넘겨주는 데이터가 ARRAY 형태이다.SELECT T.KEY1, T.KEY2, T.KEY3, T.TOTAL_COLUMN1, D.STEP_NO, D.DETAIL_COLUMN1, D.DETAIL_COLUMN2
FROM TB_TOTAL_DATA T
JOIN TB_DETAIL_DATA D
ON T.KEY1 = D.KEY1 AND T.KEY2 = D.KEY2 AND T.KEY3 = D.KEY3
ORDER BY T.KEY1, T.KEY2, T.KEY3, D.STEP_NO;
나는 결국 1번으로 작업하였다. 조회성 쿼리가 많고 UPDATE 하는 부분은 단일로 되어 있어서 JAVA부분을 건들이는건 많지 않았다.
남이 작성한 코드를 고친다는건 상당히 고된 일이다. 이미 돌아가고 있는 시스템을 개선하는 작업은 혹여나 에러가 걸릴까봐 더 조심스럽다. 하지만 방치하다보면 더 고치기 어려워지는 코드가 될 뿐이다.반면에 여러가지를 신경써야하는 부분과 달리 단일행 UPDATE로 모든게 업데이트 되는 쿼리가 과연 나쁠까란 생각도 한번정도 해봤다. 물론 한번에 UPDATE한다는건 여러곳에서 UPDATE하면 동시성 제어 문제가 있지만 반대로 DB LOCK의 위험도 없고 내부코드도 간단하다. 중요로직아님 &amp;&amp; 새로운 데이터 추가가 빈번하지 않음 &amp;&amp; 종합데이터와 개별데이터간에 같이 조회 변경하는 연관성이 강하다면 하나의 테이블로 관리하는 것도 나쁘지 않다는 생각이 들었다.]]></description><link>300-resources/310-개발공부/315-db/db정규화-문제.html</link><guid isPermaLink="false">300 Resources/310 개발공부/315 DB/DB정규화 문제.md</guid><pubDate>Sun, 21 Dec 2025 10:31:10 GMT</pubDate></item><item><title><![CDATA[데이터베이스 반정규화, 테이블 설계의 딜레마]]></title><description><![CDATA[편의를 위한 설계와 유지보수를 위한 설계의 이해관계가 충돌할 경우(트레이드오프)가 있다 이럴 때 어떻게 조인을 관리해야하는지는 큰 문제이다. 다음은 order테이블과 product 테이블을 통해 두개의 테이블이 서로 조인해서 데이터를 추출해야하는 상황의 문제를 가정하고 해결하는 과정이다.들어가는 데이터의 성격을 고려하지 않고 조인하기 싫어서 테이블을 과하게 중복된 데이터를 양측에 집어넣다보면 다음과 같은 문제가 생긴다.-- 제품 테이블 (반정규화된 구조)
-- 제품을 조회할때마다 고객사명이나, 배송상태까지 보려고 일부러 하나의 테이블에 담은경우
CREATE TABLE products ( prod_no INT PRIMARY KEY, product_name VARCHAR(100), price DECIMAL(10,2), -- 주문 정보를 제품 테이블에 포함 ord_no INT, order_date DATE, customer_name VARCHAR(100), delivery_status VARCHAR(50)
); -- 주문 테이블
CREATE TABLE orders ( ord_no INT PRIMARY KEY, order_date DATE, customer_name VARCHAR(100), delivery_status VARCHAR(50), total_amount DECIMAL(10,2)
);
이 구조는 처음에는 편리해 보였지만, 운영 중 심각한 문제가 발생했습니다:
재고 문제로 주문이 변경되는 경우 주문 번호가 바뀌면 제품 테이블의 모든 관련 정보를 업데이트해야 함
한 번의 주문 변경이 여러 테이블에 영향을 미침 *데이터 일관성 문제 같은 정보가 여러 곳에 존재하여 불일치 발생 가능
어느 테이블의 정보가 최신인지 알 수 없음 유지보수의 어려움 주문 정보 변경 시 누락되는 테이블 발생
트랜잭션문제가 더 빈번하게 발생할 수 있음. 이를 통해 우리가 생각해야하는건 컬럼에 들어가는 값이 key값에 따라서 움직이는지를 꼭 확인해야한다.
고객명은 제품에 종속된 것처럼 보이지만 실제로는 주문에 종속된 존재이다. 이런 컬럼들이 테이블의 pk값하고 꼭 1대1 매칭되는지 고민해야 문제가 생기지 않는다.가장 근본적인 해결책은 테이블을 적절히 정규화하는 것입니다. 제품은 제품 정보만, 주문은 주문 정보만 관리하도록 분리합니다.-- 제품 테이블: 제품 정보만 관리
CREATE TABLE products ( prod_no INT PRIMARY KEY, product_name VARCHAR(100), price DECIMAL(10,2), stock_quantity INT, category VARCHAR(50)
); -- 주문 테이블: 주문 정보만 관리
CREATE TABLE orders ( ord_no INT PRIMARY KEY, customer_id INT, order_date DATE, delivery_status VARCHAR(50), shipping_address TEXT
); -- 주문-제품 연결 테이블 (다대다 관계)
CREATE TABLE order_items ( unique_id INT, -- 해당 테이블의 unique한 아이디. ord_no INT, prod_no INT, quantity INT, unit_price DECIMAL(10,2), -- 주문 당시 가격 discount_rate INT, PRIMARY KEY (ord_no, prod_no), FOREIGN KEY (ord_no) REFERENCES orders(ord_no), FOREIGN KEY (prod_no) REFERENCES products(prod_no)
);
이제 재고 문제로 주문이 변경되더라도, order_items 테이블만 업데이트하면 됩니다:-- 주문 변경이 간단해짐
UPDATE order_items SET ord_no = @new_ord_no WHERE ord_no = @old_ord_no AND prod_no = @prod_no;
정규화 후 JOIN이 필요한 조회를 간편하게 하기 위해 View를 생성합니다:-- 자주 사용되는 조회를 위한 View
CREATE VIEW v_product_orders AS
SELECT p.prod_no, p.product_name, p.price as current_price, oi.ord_no, oi.quantity, oi.unit_price as order_price, o.order_date, o.customer_id, o.delivery_status
FROM products p
INNER JOIN order_items oi ON p.prod_no = oi.prod_no
INNER JOIN orders o ON oi.ord_no = o.ord_no; -- 사용 예시
SELECT * FROM v_product_orders WHERE prod_no = 12345;
JOIN 성능을 향상시키기 위해 적절한 인덱스를 생성합니다:-- 조인에 사용되는 컬럼에 인덱스 생성
CREATE INDEX idx_order_items_prod ON order_items(prod_no, ord_no);
CREATE INDEX idx_order_items_ord ON order_items(ord_no, prod_no); -- 자주 조회되는 조건에 대한 복합 인덱스
CREATE INDEX idx_orders_date_status ON orders(order_date, delivery_status);
-- 테스트 환경: 300만 건의 주문 데이터 -- 반정규화 (단일 테이블)
SELECT * FROM products WHERE prod_no = 12345;
-- 실행 시간: ~5-8ms -- 정규화 (JOIN 사용)
SELECT p.*, oi.*, o.*
FROM products p
JOIN order_items oi ON p.prod_no = oi.prod_no
JOIN orders o ON oi.ord_no = o.ord_no
WHERE p.prod_no = 12345;
-- 실행 시간: ~15-20ms (인덱스 사용 시)
-- 반정규화: 상품명 변경 시 모든 주문 내역 업데이트
UPDATE products SET product_name = 'New Name' WHERE prod_no = 12345;
-- 영향받는 행: 평균 30개, 실행 시간: ~50-100ms -- 정규화: 한 곳만 업데이트
UPDATE products SET product_name = 'New Name' WHERE prod_no = 12345;
-- 영향받는 행: 1개, 실행 시간: ~1ms
모든 경우에 완전한 정규화가 정답은 아닙니다. 상황에 따라 전략적인 반정규화가 필요할 수 있습니다.-- 분석/리포팅용 요약 테이블 (일일 배치로 생성)
CREATE TABLE daily_product_summary ( summary_date DATE, prod_no INT, product_name VARCHAR(100), total_orders INT, total_quantity INT, total_revenue DECIMAL(12,2), PRIMARY KEY (summary_date, prod_no)
);
-- 자주 조회되는 집계 데이터를 미리 계산
CREATE MATERIALIZED VIEW mv_product_stats AS
SELECT p.prod_no, p.product_name, COUNT(DISTINCT oi.ord_no) as total_orders, SUM(oi.quantity) as total_sold, AVG(oi.unit_price) as avg_selling_price
FROM products p
LEFT JOIN order_items oi ON p.prod_no = oi.prod_no
GROUP BY p.prod_no, p.product_name; -- 주기적으로 갱신
REFRESH MATERIALIZED VIEW mv_product_stats;
-- 자주 변경되지 않는 조회 결과를 캐시 테이블에 저장
CREATE TABLE product_cache ( prod_no INT PRIMARY KEY, cache_data JSON, last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
); -- 캐시 갱신 트리거
CREATE TRIGGER update_product_cache
AFTER UPDATE ON products
FOR EACH ROW
BEGIN DELETE FROM product_cache WHERE prod_no = NEW.prod_no;
END; 불변: 한번 생성되면 변경되지 않음 (예: 주문 이력, 로그, 거래 내역)
저빈도: 가끔 변경됨 (예: 사용자 정보, 상품 기본 정보)
고빈도: 자주 변경됨 (예: 재고, 가격, 상태 정보) 버전 관리 필요: 변경 이력을 추적해야 함
버전 관리 불필요: 최신 상태만 유지 1:1 관계: 하나의 레코드가 다른 테이블의 하나의 레코드와만 연결 필수적 1:1 (양쪽 모두 필수)
선택적 1:1 (한쪽 또는 양쪽 선택적) 1:N 관계: 하나의 레코드가 여러 레코드와 연결 부모가 필수 (자식은 부모 없이 존재 불가)
부모가 선택적 (자식이 독립적으로 존재 가능) N:M 관계: 여러 레코드가 여러 레코드와 연결 단순 연결 (추가 속성 없음)
연결 엔티티 (연결 자체에 속성 있음) 단건 조회: 주로 PK로 단일 레코드 조회
범위 조회: 특정 범위의 여러 레코드 조회
집계 연산: SUM, COUNT, AVG 등 빈번
조인 빈도: 다른 테이블과 자주 조인
전체 스캔: 테이블 전체 조회 빈번 소규모: 10만 건 이하
중규모: 10만 ~ 1000만 건
대규모: 1000만 건 이상
[주문 테이블]
✓ 변경 빈도: 불변
✓ 버전 관리: 불필요 (불변이므로)
✓ 1:N 관계: 고객-주문 (부모 필수)
✓ 접근 패턴: 단건 조회, 범위 조회
✓ 데이터 규모: 중규모 [주문 상세 테이블]
✓ 변경 빈도: 불변
✓ 버전 관리: 불필요
✓ N:M 관계: 주문-상품 (연결 엔티티)
✓ 접근 패턴: 조인 빈도 높음
✓ 데이터 규모: 대규모 [상품 테이블]
✓ 변경 빈도: 저빈도
✓ 버전 관리: 필요 (가격 변경 이력)
✓ 1:N 관계: 카테고리-상품 (부모 선택적)
✓ 접근 패턴: 단건 조회, 범위 조회
✓ 데이터 규모: 소규모
[재고 현황 테이블]
✓ 변경 빈도: 고빈도
✓ 버전 관리: 불필요 (별도 이력 테이블)
✓ 1:1 관계: 상품-재고 (필수적)
✓ 접근 패턴: 단건 조회, 집계 연산
✓ 데이터 규모: 소규모 [재고 변동 이력]
✓ 변경 빈도: 불변
✓ 버전 관리: 불필요 (자체가 이력)
✓ 1:N 관계: 상품-변동이력 (부모 필수)
✓ 접근 패턴: 범위 조회, 집계 연산
✓ 데이터 규모: 대규모 불변: 단일 테이블, 파티셔닝 고려
저빈도: 기본 테이블 + 선택적 이력 테이블
고빈도: 현재 상태 테이블 + 변경 이력 테이블 분리 필요 시: 별도 버전 테이블 또는 이력 컬럼 추가
불필요 시: 단순 UPDATE 처리 1:1: 양방향 인덱스는 보통 불필요
1:N: 자식 테이블의 FK에 인덱스 필수
N:M: 양쪽 FK 모두 인덱스, 복합 PK 고려 단건 조회: PK 인덱스로 충분
범위 조회: 조회 조건 컬럼에 인덱스
집계 연산: 집계 대상 컬럼 인덱스, 요약 테이블 고려
조인 빈도: 조인 컬럼 인덱스, 반정규화 검토
전체 스캔: 파티셔닝, 병렬 처리 고려 소규모: 정규화 우선, 단순한 구조
중규모: 선택적 인덱싱, 적절한 반정규화
대규모: 파티셔닝, 샤딩, 요약 테이블 필수
이 체크리스트를 활용하여 각 엔티티의 특성을 파악하고, 그에 맞는 최적의 테이블 구조와 인덱싱 전략을 수립할 수 있습니다.]]></description><link>300-resources/310-개발공부/315-db/데이터베이스-반정규화,-테이블-설계의-딜레마.html</link><guid isPermaLink="false">300 Resources/310 개발공부/315 DB/데이터베이스 반정규화, 테이블 설계의 딜레마.md</guid><pubDate>Sun, 21 Dec 2025 10:31:05 GMT</pubDate></item><item><title><![CDATA[공유기 원격데스크톱 접속]]></title><description><![CDATA[공유기를 통한 원격 데스크톱 접속 방법을 알아보세요. 방화벽 설정, 고정 IP 사용, 포트 포워딩 등 필수 작업을 설명합니다.]]></description><link>300-resources/310-개발공부/314-network/공유기-원격데스크톱-접속.html</link><guid isPermaLink="false">300 Resources/310 개발공부/314 NETWORK/공유기 원격데스크톱 접속.md</guid><pubDate>Sun, 21 Dec 2025 10:30:56 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[github_action_obsidiain배포자동화]]></title><description><![CDATA[
obsidian의 파일을 commit 하면 자동으로 githubBlog에 올리려고 하였다. 문제는 jeklly를 github으로 선택했는데 posting 파일에 대한 파일명 양식이 따로 정해져 있다는 것이다. 글 쓸 때마다 그 양식을 지키기는 너무 귀찮아서 commit 시점에 자동으로 파일명을 바꿔서 그 위치에 저장하는 workflow를 작성하기로 했다.(아마 1년 내내바꿔도 해당 workflow만드는 시간보단 덜들듯 하다.)
github action의 역할은 명확하다. "트리거 발생 시 -&gt; 이미 구조화된 이벤트 실행"이다.
트리거 : master 브랜치에 push 할 때 동작
구조화된 이벤트(workflow) : 하나의 단일 job으로 구성 (하나의 job은 하나의 트랜잭션)
// .github/workflows/push-to-posts.ymlname: Copy and Rename Files on Push # trigger master 브랜치에 push 할 때 해당 workflows를 실행
on: push: branches: - master # workflows 내부의 job들 각 job은 하나의 트랜잭션
jobs: copy_files: # 실행시키는 환경. 대규모 프로젝트면 프로젝트환경과 맞추기도 한다. runs-on: ubuntu-latest # job 내 프로젝트 하나의 steps는 하나의 트랜잭션안에 있어서 하나가 실패하면 전체 취소 steps: - name: Checkout repository uses: actions/checkout@v3 with: fetch-depth: 0 # 전체 커밋 기록을 가져오기 # 디폴트가 현재 커밋이라 설정 안하면 HEAD^ 못가져옴. # 한글 깨짐 수정 - name: Set Git config to handle Korean filenames run: | git config --global core.quotepath false - name: Set UTF-8 locale run: | sudo update-locale LANG=en_US.UTF-8 export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 # github action의 보안관련 설정 - name: Set safe directory for Git run: | git config --global --add safe.directory /github/workspace # 유저 적용 - name: Set up Git run: | git config --global user.name 'rn0614' git config --global user.email 'rn0614@naver.com' # 파일 copy &amp; 이름변경 로직 - name: Copy and Rename Files run: | # 플래그 변수 초기화 FILE_COPIED=false # 오늘 날짜 형식 (YYYY-MM-DD) TODAY=$(date +"%Y-%m-%d") # 시작부분 로그 echo "변경파일 추출 시작" # 변경된 파일 목록을 임시 파일에 저장 git diff --name-only HEAD^ HEAD 2&gt;/dev/null &gt; changed_files.txt # 임시 파일에서 파일명 추출 및 처리 echo "추출된 파일 목록:" cat changed_files.txt # 추출된 파일 목록을 출력하여 확인 # 임시 파일에서 파일명 추출 및 처리 while IFS= read -r FILE; do if echo "$FILE" | grep -E '.*.md$'; then if echo "$FILE" | grep -E '^_github_open/.*'; then echo "파일이 조건에 맞습니다: $FILE" # 매칭된 파일 확인 FILENAME=$(basename "$FILE" .md) # 확장자 제거한 파일명 # 파일명에서 공백을 '_'로 대체 FILENAME_WITH_UNDERSCORES=$(echo "$FILENAME" | sed 's/ /_/g') # 새로운 파일명 생성 (YYYY-MM-DD-파일명.md) NEW_FILENAME="${TODAY}-${FILENAME_WITH_UNDERSCORES}.md" # 이름 formatting 완료된 파일이름 리스트 출력 echo "COPIED_FILENAME : ${NEW_FILENAME}" # _posts 폴더로 파일 이동 및 파일명 변경 cp "$FILE" "_posts/${NEW_FILENAME}" # 파일 복사 발생 시 플래그 변경 FILE_COPIED=true fi fi done &lt; changed_files.txt # 환경 변수 파일에 기록 echo "file_copied=$FILE_COPIED" &gt;&gt; $GITHUB_ENV # 변경점 psuh - name: Commit and Push Changes run: | # GitHub Actions 환경 변수 참조 echo "file_copied is: $file_copied" # 파일이 복사된 경우에만 커밋 및 푸시 if [ "$file_copied" = "true" ]; then git add _posts/*.md git commit -m "Copy and rename files on push" git push origin master else echo "No files were copied. Skipping commit." fi
# 에러
fatal: ambiguous argument 'HEAD^': unknown revision or path not in the working tree. Use '--' to separate paths from revisions, like this: 'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]' # 개선
steps: - name: Checkout repository uses: actions/checkout@v3 with: fetch-depth: 0 # 전체 커밋 기록을 가져오기 # 디폴트가 현재 커밋이라 설정 안하면 HEAD^ 못가져옴. # 한글 깨짐 수정 - name: Set Git config to handle Korean filenames run: | git config --global core.quotepath false - name: Set UTF-8 locale run: | sudo update-locale LANG=en_US.UTF-8 export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8
- name: Set safe directory for Git run: | git config --global --add safe.directory /github/workspace
# 변경된 파일 목록을 임시 파일에 저장 git diff --name-only HEAD^ HEAD 2&gt;/dev/null &gt; changed_files.txt # 임시 파일에서 파일명 추출 및 처리 echo "추출된 파일 목록:" cat changed_files.txt # 추출된 파일 목록을 출력하여 확인 # 임시 파일에서 파일명 추출 및 처리 while IFS= read -r FILE; do if echo "$FILE" | grep -E '.*.md$'; then if echo "$FILE" | grep -E '^_github_open/.*'; then echo "파일이 조건에 맞습니다: $FILE" # 매칭된 파일 확인 FILENAME=$(basename "$FILE" .md) # 확장자 제거한 파일명 # 파일명에서 공백을 '_'로 대체 FILENAME_WITH_UNDERSCORES=$(echo "$FILENAME" | sed 's/ /_/g') # 새로운 파일명 생성 (YYYY-MM-DD-파일명.md) NEW_FILENAME="${TODAY}-${FILENAME_WITH_UNDERSCORES}.md" # 이름 formatting 완료된 파일이름 리스트 출력 echo "COPIED_FILENAME : ${NEW_FILENAME}" # _posts 폴더로 파일 이동 및 파일명 변경 cp "$FILE" "_posts/${NEW_FILENAME}" # 파일 복사 발생 시 플래그 변경 FILE_COPIED=true fi fi done &lt; changed_files.txt # 환경 변수 파일에 기록 echo "file_copied=$FILE_COPIED" &gt;&gt; $GITHUB_ENV
]]></description><link>300-resources/310-개발공부/313-cicd/github_action_obsidiain배포자동화.html</link><guid isPermaLink="false">300 Resources/310 개발공부/313 CICD/github_action_obsidiain배포자동화.md</guid><pubDate>Sun, 21 Dec 2025 10:27:39 GMT</pubDate></item><item><title><![CDATA[Git전략 실무관련 GITHUB FLOW와 GIT FLOW의 변형]]></title><description><![CDATA[실무에서 사용할 수 있는 변형된 GITHUB FLOW 변형된 GIT 전략을 확인해보자]]></description><link>300-resources/310-개발공부/313-cicd/git전략-실무관련-github-flow와-git-flow의-변형.html</link><guid isPermaLink="false">300 Resources/310 개발공부/313 CICD/Git전략 실무관련 GITHUB FLOW와 GIT FLOW의 변형.md</guid><pubDate>Sun, 21 Dec 2025 10:27:35 GMT</pubDate></item><item><title><![CDATA[이전 commit 정보 수집하기]]></title><description><![CDATA[
github action을 수행하는동안 이전 커밋과 현재 커밋과 비교해서 바뀐 파일들의 리스트 추출이 필요함. 이전을 의미하는 Head~1을 작성했지만 못 가져오는 상황
github action 중에 로직을 js 로 실행하고 싶을 때가 있다. 그럴 땐 아래와 같이 github action에서 실행시켜줄 js를 포함시켜 줄 수 있다. steps 의 run부분은 github 실행환경으로 설정한 ubuntu와 동일하기 때문에 npm으로 라이브러리를 받고 js를 node로 실행시킬 수 있다.jobs: build: steps: - name: Install gray-matter (for front matter parsing) run: npm install gray-matter dayjs # 실행시킬 library는 미리 npm 으로 받는다. - name: Update front matter run: node scripts/update-frontmatter.js # 실행시킬 js 를 명령어으로 직접 호출
실행할 js 에서 bash 에서 쓰는 데이터를 가져오기 위해서 child_process 를 사용해서 내부 명령어를 shell에서 접근한 내용을 가져온다.
execSync : 문자열 형태로 명령어를 실행하고 결과를 콜백으로 가져옴.const childProcess = require('child_process'); // url을 인코딩하지 않고 그대로 사용하기 위해서 -c core.quotepath=false를 사용하였다.
const diffOutput = childProcess.execSync( 'git -c core.quotepath=false diff --name-only HEAD~1 HEAD', { encoding: 'utf8' }
); fatal: ambiguous argument 'HEAD~1': unknown revision or path not in the working tree.원래 나는 git diff --name-only HEAD~1 HEAD 명칭을 이렇게 사용했다. 그 결과 뽑히긴 했으나 한들이 인코딩 상태( 예 /123/512) 식으로 출력이됐고 제대로 파일을 찾아서 매칭하지 못했다. 이 인코딩을 한글명칭을 뽑기 위해서 -c core.quotepath=false 를 통해서 인코딩하는 것을 껐다.** 참고로 아예 checkout 때 한개만 fetch-depth를 설정 안하면 이번에 commit 하는 대상만 가져온다. - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 2
fetch 결과물# Sample workflow for building and deploying a Next.js site to GitHub Pages
#
# To get started with Next.js see: https://nextjs.org/docs/getting-started
#
name: Deploy Next.js site to Pages on: # Runs on pushes targeting the default branch push: branches: ["master"] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions: contents: write pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency: group: "pages" cancel-in-progress: false jobs: # Build job build: environment: github-pages runs-on: ubuntu-latest env: NEXT_PUBLIC_BASE_URL: ${{ secrets.NEXT_PUBLIC_BASE_URL }} API_DOC_ENV: ${{ secrets.API_DOC_ENV }} steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 2 # (여기) Front Matter 업데이트 스크립트 실행(임시로 업데이트 날짜 제거) # - name: Install gray-matter (for front matter parsing) # run: npm install gray-matter dayjs # - name: Update front matter # run: node scripts/update-frontmatter.js # # 여기서 다시 Git에 푸시 # - name: Commit &amp; push updated front matter # run: | # git config user.name "rn0614" # git config user.email "rn0614@naver.com" # git add posts/**/*.md # git commit -m "chore: update front matter [skip ci]" || echo "No changes to commit." # git push origin HEAD:master - name: Detect package manager id: detect-package-manager run: | if [ -f "${{ github.workspace }}/yarn.lock" ]; then echo "manager=yarn" &gt;&gt; $GITHUB_OUTPUT echo "command=install" &gt;&gt; $GITHUB_OUTPUT echo "runner=yarn" &gt;&gt; $GITHUB_OUTPUT exit 0 elif [ -f "${{ github.workspace }}/package.json" ]; then echo "manager=npm" &gt;&gt; $GITHUB_OUTPUT echo "command=ci" &gt;&gt; $GITHUB_OUTPUT echo "runner=npx --no-install" &gt;&gt; $GITHUB_OUTPUT exit 0 else echo "Unable to determine package manager" exit 1 fi - name: Setup Node uses: actions/setup-node@v4 with: node-version: "20" cache: ${{ steps.detect-package-manager.outputs.manager }} - name: Setup Pages uses: actions/configure-pages@v5 with: # Automatically inject basePath in your Next.js configuration file and disable # server side image optimization (https://nextjs.org/docs/api-reference/next/image#unoptimized). # # You may remove this line if you want to manage the configuration yourself. static_site_generator: next - name: Restore cache uses: actions/cache@v4 with: path: | .next/cache # Generate a new cache whenever packages or source files change. key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json', '**/yarn.lock') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }} # If source files changed but packages didn't, rebuild from a prior cache. restore-keys: | ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json', '**/yarn.lock') }}- - name: Install dependencies run: ${{ steps.detect-package-manager.outputs.manager }} ${{ steps.detect-package-manager.outputs.command }} - name: Create .env run: | echo "NEXT_PUBLIC_BASE_URL=${{ secrets.NEXT_PUBLIC_BASE_URL }}" &gt;&gt; .env.production echo "API_DOC_ENV=${{ secrets.API_DOC_ENV }}" &gt;&gt; .env.production - name: Build with Next.js run: ${{ steps.detect-package-manager.outputs.runner }} next build - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./out # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4
]]></description><link>300-resources/310-개발공부/313-cicd/이전-commit-정보-수집하기.html</link><guid isPermaLink="false">300 Resources/310 개발공부/313 CICD/이전 commit 정보 수집하기.md</guid><pubDate>Sun, 21 Dec 2025 10:27:30 GMT</pubDate></item><item><title><![CDATA[webClient를 이용한 외부 stream API통신]]></title><description><![CDATA[<a class="internal-link data-link-icon data-link-icon-after data-link-text" data-href="300 Resources/310 개발공부/319 ETC/ngrock, n8n, docker-desktop.md" href="300-resources/310-개발공부/319-etc/ngrock,-n8n,-docker-desktop.html" target="_self" rel="noopener nofollow" data-link-path="300 Resources/310 개발공부/319 ETC/ngrock, n8n, docker-desktop.md" style="--data-link-tags: #tech/ai #tech/api #tech/database #tech/devops #tech/devops/docker #tool/n8n; --data-link-path: 300 Resources/310 개발공부/319 ETC/ngrock, n8n, docker-desktop.md;" data-link-tags="#tech/ai #tech/api #tech/database #tech/devops #tech/devops/docker #tool/n8n">ngrock, n8n, docker-desktop</a>webClient는 Spring WebFlux에서 제공하는 비동기, 논블록킹 방식의 클라이언트이다. 해당 클라이언트를 통해 외부 api를 비동기적으로 호출 가능하다. tip:이 방식은 요청 후 결과를 Mono나 Flux형태로 받을 수 있어 요새 자주 쓰이는 steam 방식으로 데이터를 수신받아 사용자에게 LLM 모델을 더 효율적으로 제공 가능하다.
// ExternalApiController.javaimport org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController; @RestController
public class ExternalApiController { @Autowired private ExternalApiService externalApiService; @GetMapping("/call-api-reactive") public Mono&lt;ResponseEntity&lt;String&gt;&gt; callExternalApiReactive() { return externalApiService.getData() .map(data -&gt; ResponseEntity.ok(data)); }
}
// ExternalApiService.javaimport org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux; @Service
public class ExternalApiService { private final WebClient webClient; // 실제 사용 시에는 프로퍼티 파일이나 환경변수로 API 키를 관리하는 것이 좋습니다. private final String API_KEY = "your_api_key_here"; public ExternalApiService(WebClient.Builder webClientBuilder) { // 외부 API의 기본 URL 설정 (예: https://externalapi.example.com) this.webClient = webClientBuilder.baseUrl("https://externalapi.example.com").build(); } public Flux%3CString%3E callExternalApi(RequestDto requestDto) { return webClient.post() .uri("/external-endpoint") // 외부 API의 엔드포인트 .header("Authorization", "Bearer " + API_KEY) .contentType(MediaType.APPLICATION_JSON) .bodyValue(requestDto) .retrieve() .bodyToFlux(String.class); // 스트림 형태의 문자열 데이터 반환 (필요 시 DTO나 JsonNode로 변경 가능) }
)
axios 의 경우 stream 객체를 받지 못하므로 fetch를 사용해서 수신받는다.
axios 의 경우 stream 객체를 받지 못하므로 fetch를 사용해서 수신받는다.
while((match = 정규식.exec(문자열)) !==null ) 안의 방식의 lastIndex는 while을 벗어나면 초기화 됨
chunkRegex.exec(chunkBuffer)을 사용하면 손쉽게 정규식에 해당하는 요소를 골라낼 수 있다. 하지만 이렇게 실행시 while 문을 빠져나가면 chunkRegex.lastIndex 의 값이 0으로 초기화 돼서 이미 처리한 부분을 chunkBuffer에서 빼지 못하는 문제가 발생하였다.
따라서 외부 변수(lastProcessedIndex)를 두어 해당 while문에서 마지막 찾은 인덱스를 저장하고 해당 부분을 업데이트로 개선하였다.
function read() { reader.read().then(({ done, value }) =&gt; { if (done) { console.log('종료완료'); return; } const chunk = decoder.decode(value); let lastProcessedIndex = 0; chunckBuffer += chunk; let match; while ((match = chunkRegex.exec(chunckBuffer)) !== null) { lastProcessedIndex = chunkRegex.lastIndex const jsonStr = match[1]; try { const eventObj = JSON.parse(jsonStr); conversation.value[conversation.value.length - 1].content += eventObj.message; } catch (error) { console.error("JSON 파싱 오류:", error); } } // 처리된 부분 이후의 문자열만 남도록 chunkBuffer 업데이트 if (lastProcessedIndex &gt; 0) { chunckBuffer = chunckBuffer.substring(lastProcessedIndex); } read(); });
} 형태 : {"role":"assistant", "content":"첫번째 메세지"} , {"role":"assistant", "content":"두번째 메세지"} Flux&lt;ChatResponse&gt; responseFlux = webClient.post() .uri("https://externalapi.example.com/endpoint") .retrieve() .bodyToFlux(ChatResponse.class); Flux&lt;String&gt; messageFlux = responseFlux.map(ChatResponse::getMessage);
형태 : {"role":"assistant", "content":["메세지1","메세지2"]}{ "chatRoleType": "ASSISTANT", "message": ["메시지1", "메시지2", "메시지3"]
} Run# WebClient 관련 로깅
logging.level.org.springframework.web.reactive.function.client.ExchangeFunctions=DEBUG
logging.level.reactor.netty.http.client=DEBUG
responseFlux.subscribe( data -&gt; System.out.println("받은 데이터: " + data), error -&gt; System.err.println("오류: " + error), () -&gt; System.out.println("스트림 종료")
);
Run400 Bad Request : 클라이언트에서 보낸 요청이 올바른 형식이 아니거나 서버가 이해를 하지 못할 때 보통 body가 잘못된 경우이다.
이번의 경우 내가 body 쪽에 명시되지 않은 type 데이터까지 같이 보내면서 발생하였다.
401 Unauthorized: 인증 인가문제인데, 외부 API를 사용할 때 인증 인가 수단을 살펴봐야한다.
400과 401의 우선순위 : 대부분이 Spring Security 에 의해서 인가된 인원인지 먼저 확인하고 보내는 양식을 확인하기 때문에 401에러가 먼저나고 400이 난다. 하지만 시스템의 방식에 따라서 바뀔 수도 있다.]]></description><link>300-resources/310-개발공부/312-back/webclient를-이용한-외부-stream-api통신.html</link><guid isPermaLink="false">300 Resources/310 개발공부/312 BACK/webClient를 이용한 외부 stream API통신.md</guid><pubDate>Sun, 21 Dec 2025 10:18:13 GMT</pubDate></item><item><title><![CDATA[Ubuntu 환경 자바 설치]]></title><description><![CDATA[AWS EC2(Ubuntu) 환경에서 다음 환경을 구성합니다:
JDK 17
Maven
Node.js + npm + PM2
Git
Nginx (reverse proxy 및 정적 파일 서빙용) 슈퍼유저 권한으로 명령을 실행
예: sudo apt update Ubuntu 계열 리눅스의 패키지 관리자
패키지 설치: sudo apt install 패키지명
패키지 목록 최신화: sudo apt update 디렉토리 이동
예: cd backend-project 현재 디렉토리 내 파일 목록 보기
옵션 예: ls -al (숨김파일 포함, 상세보기)
sudo apt update # 패키지 목록 최신화
sudo apt upgrade -y # 시스템 전체 업그레이드 (선택)
sudo apt install -y openjdk-17-jdk
java -version # 설치 확인
sudo apt install -y maven
mvn -v # 설치 확인
sudo apt install -y nodejs
sudo apt install -y npm
node -v &amp;&amp; npm -v # 버전 확인 최신 Node.js 설치를 원할 경우 <a data-tooltip-position="top" aria-label="https://github.com/nodesource/distributions" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/nodesource/distributions" target="_self">NodeSource</a>에서 제공하는 setup 스크립트 사용 가능:
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
sudo apt install -y nodejs
sudo apt install -y git
git --version # 설치 확인
git clone https://github.com/username/project.git
cd project/backend-project
mvn clean install # target 디렉토리에 .jar 파일 생성됨
Run
참고: clean: 이전 빌드 파일 삭제
install: .jar 파일을 생성하여 로컬 Maven 저장소에도 설치
sudo npm install -g pm2 # 백엔드 실행 (jar 파일 실행)
pm2 start "java -jar target/my-app.jar" --name backend # 프론트엔드 실행 (React 등)
cd ../frontend-project
npm install
npm run build
pm2 serve build 3000 --name frontend
Runpm2 startup
pm2 save
Run
재부팅 시 자동 실행되도록 설정
sudo apt install -y nginx
sudo systemctl start nginx
sudo systemctl enable nginx
Runsudo systemctl status nginx # 상태 확인
sudo systemctl restart nginx # 재시작
sudo systemctl stop nginx # 중지
sudo nginx -t # 설정 파일 문법 검사
Runserver { listen 80; location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } location /api/ { proxy_pass http://localhost:8080; }
}
sudo nginx -t
sudo systemctl restart nginx
Run]]></description><link>300-resources/310-개발공부/312-back/ubuntu-환경-자바-설치.html</link><guid isPermaLink="false">300 Resources/310 개발공부/312 BACK/Ubuntu 환경 자바 설치.md</guid><pubDate>Sun, 21 Dec 2025 10:18:09 GMT</pubDate></item><item><title><![CDATA[SWAGGER]]></title><description><![CDATA[공식문서 : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://swagger.io/docs/" target="_self">https://swagger.io/docs/</a>
클라이언트가 서버로부터 받는 request/response를 정의한 문서
예시) 어떤 api인지 description, Request의 url, parameter, body, header / Response의 status등
자주쓰는 라이브러리로 swagger와 RestDoc
swagger는 단순히 annotation 위에 추가하므로 추가가 쉽다. (단순히 ANNOTATION을 추가하는걸로 anotation사용가능)
restDoc는 테스트코드를 통과한 케이스에만 API문서가 생성된다. (따라서 모든 테스트를 작성해야함)
둘의 장단점을 보완하기 위해 같이쓰는 경우도 있다. API 리스트를 HTML로 문서화 및 테스트하는 라이브러리, documentation을 작성하여 공유 및 소스코드 자체에 API문서가 들어있는 점에서 개발자가 관리하기 쉬움.
전체적인 api별 기능을 정의하여 문서로 만듦. 이 과정에서 백엔드와 프론트엔드간의 소통을 원할하게 할 수 있음.
(fast-api에서는 자체적으로 들어있기도 함.)큰 소재목으로 어떤 api인지 표시하고 그 안에 상세 api에 대해서 나눠서 표현 상세 description 및 parameter example value, result 를 나눠서 보여줄 수 있음.
npm i next-swagger-doc # nextjs용 swagger 라이브러리
npm i swagger-jsdoc
npm i swagger-ui-react # react용 rendering 하는 문서를 만든다.
swagger 공통설정을 정의한다.// /lib/swagger.tsx
import { createSwaggerSpec } from "next-swagger-doc"; export const getApiDocs = async () =&gt; { const spec = createSwaggerSpec({ apiFolder: "src/app/api", definition: { openapi: "3.0.0", info: { title: "koo-project api-doc", version: "1.0", license: { name: "MIT", url: "https://opensource.org/licenses/MIT", // MIT License 상세 정보 URL }, }, }, components: { securitySchemes: { BearerAuth: { type: "http", scheme: "bearer", bearerFormat: "JWT", // JWT 코드 }, }, }, security: [{ }], }); return spec;
};
*** OpenAPI Spec이란? : RESTful 웹서비스를 설명 생성 소비 및 시각화하기 위한 I/F 파일 사양
상업적으로 이용한다면 license 부분은 MIT로 표기할것
annotation에 정의를 작성해 놓는다. params 나 requestBody, response 의 형태를 정의해놓는다. 경로: method: tags: 구성으로 만든다. 다음과 같이 function에 정의할 수도 있고 yaml 파일에 따로 정의할 수도있다.
/** * @swagger * /api/schedule: * post: * tags: * - schedule * description: schedule을 추가하는 로직 * requestBody: * required: true * content: * application/json: * schema: * type: object * properties: * id: number * created_at: string * day: string * deleted_at: string * startTime: string * endTime: string * text: string * type: string * updated_at: string * isChange: boolean * example: * id: 1 * created_at: "2025-01-05T10:00:00Z" * day: "2024-12-10" * deleted_at: null * startTime: "10" * endTime: "20" * text: "일정1" * type: "1" * updated_at: "2025-01-06T10:00:00Z" * isChange: true * responses: * 200: * description: 업데이트된 json data를 반환한다 * content: * application/json: * schema: * $ref: "/api/schemas#/definitions/UpdateResultDTO" * example: * code: 201 * message: "업데이트완료" * result: 2 * 500: * description: Error * content: * application/json: * schema: * $ref: "/api/schemas#/definitions/ErrorResultDTO" * example: * code: 500 * message: "알수없는 오류로 업데이트에 실패하였습니다." */ export async function POST(request: NextRequest) { const body = await request.json(); const scheduleList = body.scheduleList as TimeSchedule[]; const formatedScheduleList = scheduleList.map((scheduleItem) =&gt; { return { id: scheduleItem.id, day: scheduleItem.day, text: scheduleItem.text, startTime: scheduleItem.startTime, endTime: scheduleItem.endTime, type: scheduleItem.type, }; }); try { const supabase = createClient(); let { data, error } = await supabase.rpc( "upsert_multiple_records_with_transaction", { schedule_data: formatedScheduleList, // } ); if (error) console.error(error); return new Response(JSON.stringify({}), { status: 200, headers: { "Content-Type": "application/json" }, }); } catch (error) { console.log("error occured", error); }
} DTO타입을 작성할 때 ANNOTATION으로 쓰면 길이가 길어짐. 위의 예시도 EXAMPLE만 썼는데도 길이가 긴걸 알 수 있다.
DTO타입의 경우 코드를 작성할 때 타입처리가 되지만 DTO타입을 변경하고 ANNOTATION은 수정을 안하는 케이스가 발생할 수 있다. api는 백과 프론트간의 약속이다. DTO타입들을 바꿀 일이 있다면 꼭 프론트와 상의해서 바꾸는 것이 좋다.
타입스크립트를 따로 저장해서 관리하고 해당 ts 파일을 json 형태로 저장한다.
library 및 실행명령어
npm i swagger-typescript-api
npm i typescript-json-schema # 실행명령어
typescript-json-schema src/types/apiDTO.ts "*" --out src/types/types-schema.json --required #type으로 지정한 내용을 json 형태로 만드는 명령어 생성된 json 예시
{ "$schema": "http://json-schema.org/draft-07/schema#", "definitions": { "APItestRequest": { "properties": { "id": { "type": "number" }, "name": { "type": "string" } }, "required": [ "id", "name" ], "type": "object" }, }
}
내가 DTO 타입만 변경하고 SWAGGER의 ANNOTAION에는 반영을 안할 경우 문제가 생길 수 있음.
따라서 API를 typescript코드로부터 가져오도록 한다.// src/app/api/schemas/route.ts
import { NextRequest, NextResponse } from "next/server";
import schema from "@/types/types-schema.json"; export async function GET() { if ( process.env.NEXT_PUBLIC_API_GP === "local" || process.env.NEXT_PUBLIC_API_GP === "dev" ) { return NextResponse.json(schema); } return NextResponse.json(null);
}
Run// 변경전 * schema: * type: object * properties: * id: number * created_at: string * day: string * deleted_at: string * startTime: string * endTime: string * text: string * type: string * updated_at: string * isChange: boolean // 변경후 * schema: * $ref: "/api/schemas#/definitions/TimeScheduleDto" export async function POST(request: NextRequest) {
]]></description><link>300-resources/310-개발공부/312-back/swagger.html</link><guid isPermaLink="false">300 Resources/310 개발공부/312 BACK/SWAGGER.md</guid><pubDate>Sun, 21 Dec 2025 10:18:05 GMT</pubDate></item><item><title><![CDATA[SUPBASE, GOOGLE OAUTH, VERCEL 인증 환경설정]]></title><description><![CDATA[프로젝트 구조
front : react
backend : supabse
배포 : vercel해당 환경에서 인증 환경설정 하는법google oauth 에서 웹 애플리케이션에서 다 만들면 아래 상황과 같다.
<img src="800-references/801-image/2025/08/supbase-google-oauth-vercel-인증-환경설정-1.png" target="_self">1vercel에서 나온 주소로 리다이렉트 URL CONFIGURATION 주소를 명시해줘야한다.
안그러면 계속 기본설정인 localhost:3000으로 redirect 됨<br>
<img src="800-references/801-image/2025/08/supbase-google-oauth-vercel-인증-환경설정-2.png" target="_self">1]]></description><link>300-resources/310-개발공부/312-back/supbase,-google-oauth,-vercel-인증-환경설정.html</link><guid isPermaLink="false">300 Resources/310 개발공부/312 BACK/SUPBASE, GOOGLE OAUTH, VERCEL 인증 환경설정.md</guid><pubDate>Sun, 21 Dec 2025 10:18:01 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Spring Security]]></title><description><![CDATA[
springboot 모듈중 하나로 spring-security을 통해서 접근 권한을 확인하여 사용자의 접근권한을 확인한다. 해당 방식은 spring Security 3.x 기준이다. 2버전에서는 람다식으로 받는 파라미터가 없어서 람다식으로 구현안되어 있다. 사용자 요청
UsernamePasswordAuthenticationFilter가 로그인 처리
AuthenticationManager가 인증을 시도
UserDetailsService에서 사용자 정보 조회
비밀번호 검증
인증 성공시 application에 요청을 보내면 Container 안에 있는 Filter를 거쳐서 인증작업을 진행함
그런데 이런 인증작업을 하는 filter를 Spring Security Config를 통해서 만드는 것을 자동으로 해주는 library요청 -&gt; (filter -&gt; controller) : ()는 spring Container
BCrypt Password Encoder 사용할 예정
암호화만 가능하고 복호화는 못하는 암호화 // CORS 설정 @Bean CorsConfigurationSource corsConfigurationSource() { CorsConfiguration config = new CorsConfiguration(); config.setAllowedOrigins(Arrays.asList("http://spring.koosang-project.com")); config.setAllowedMethods(Arrays.asList("GET","POST","PUT","DELETE","PATCH")); config.setAllowCredentials(true); config.setExposedHeaders(Arrays.asList("Authorization", "Authorization-refresh")); config.setAllowedHeaders(Arrays.asList("Authorization", "Authorization-refresh", "Cache-Control", "Content-Type")); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", config); return source; } @Bean SecurityFilterChain filterChain(HttpSecurity http) throws Exception { //CORS 설정변경 http.cors(corsConfigurer -&gt; corsConfigurer.configurationSource(corsConfigurationSource()) ); //CSRF 토큰을 비활성화 한다 http.csrf(csrfConfigurer -&gt; csrfConfigurer.disable()); // scrf 토큰을 받지 않겠다. // 인증/인가 설정 http.authorizeHttpRequests(authorize -&gt; authorize // URL 경로 member 에는 인증 성공필요 .requestMatchers("/api/d1/member/**").authenticated() // // URL 경로 manager 에는 인증 성공 + MANAGER 권한 .requestMatchers(new AntPathRequestMatcher("/api/d1/manager/**")) .hasAnyRole("MANAGER", "ADMIN") // .requestMatchers(new AntPathRequestMatcher("/api/d1/admin/**")) // .hasRole("ADMIN") // 나머지 모든 권한에 한해 모두 접근 허용 .anyRequest().permitAll() ); // 로그인 설정 http.formLogin(auth -&gt; auth .successHandler(new MyAuthenticationSuccessHandler()) .failureHandler((request, response, authentication) -&gt; { System.out.println("인증실패"); response.setStatus(401); }) .loginProcessingUrl("/api/d1/login") ); // 권한 없음 페이지 http.exceptionHandling(exception -&gt; exception.authenticationEntryPoint( new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED) ) ); // 로그아웃 설정 http.logout(auth -&gt; auth .logoutSuccessHandler((request, response, authentication) -&gt; { System.out.println("logout성공"); response.setStatus(200); }) .invalidateHttpSession(true) .deleteCookies("JSESSIONID") .logoutUrl("/api/d1/logout") .permitAll() ); // 사용자 정의 UserDetailsService 적용 http.userDetailsService(detailsService); // 다중로그인 허용여부 설정 http.sessionManagement(auth -&gt; auth.maximumSessions(1).maxSessionsPreventsLogin(true) ); http.sessionManagement(auth -&gt; auth.sessionFixation().changeSessionId()); return http.build(); } ]]></description><link>300-resources/310-개발공부/312-back/spring-security.html</link><guid isPermaLink="false">300 Resources/310 개발공부/312 BACK/Spring Security.md</guid><pubDate>Sun, 21 Dec 2025 10:17:57 GMT</pubDate></item><item><title><![CDATA[Linux 명령어 정리]]></title><description><![CDATA[ls - 파일과 디렉토리 목록 표시함ls -la
cd - 디렉토리 변경함cd /home/user
pwd - 현재 디렉토리 경로 출력함pwd
mkdir - 디렉토리 생성함mkdir new_folder
rmdir - 빈 디렉토리 삭제함rmdir empty_folder
rm - 파일/디렉토리 삭제함rm -rf folder_name
cp - 파일/디렉토리 복사함cp file.txt backup.txt
mv - 파일/디렉토리 이동하거나 이름 변경함mv old_name.txt new_name.txt
cat - 파일 내용 전체 출력함cat config.txt
head - 파일 첫 부분 봄head -10 data.txt
grep - 파일에서 패턴 검색함 ⭐기본 검색grep "error" logfile.txt
# logfile.txt에서 "error" 문자열 검색
대소문자 구분 안함 (-i)grep -i "ERROR" logfile.txt
# Error, error, ERROR 모두 검색
정확한 단어만 검색 (-w)grep -w "cat" file.txt
# "cat"만 검색, "category" 등은 제외
줄 번호 표시 (-n)grep -n "function" script.js
# 매칭된 줄의 번호도 함께 표시
재귀 검색 (-r)grep -r "TODO" ./src/
# src 디렉토리 하위 모든 파일에서 "TODO" 검색
매칭되지 않는 줄 표시 (-v)grep -v "comment" code.py
# "comment"가 포함되지 않은 줄만 표시
파일명만 표시 (-l)grep -l "config" *.txt
# "config"가 포함된 파일 이름만 나열
매칭 개수 표시 (-c)grep -c "error" *.log
# 각 파일에서 "error"가 나타난 횟수
Run정규표현식 사용grep "^Error" logfile.txt # 줄 시작이 "Error"인 경우
grep "failed$" logfile.txt # 줄 끝이 "failed"인 경우
grep "[0-9]\{3\}" data.txt # 3자리 숫자 검색
grep "test\|debug" code.py # "test" 또는 "debug" 검색
Run여러 패턴 동시 검색 (-e)grep -e "error" -e "warning" -e "fatal" logfile.txt
Run패턴 파일 사용 (-f)grep -f patterns.txt logfile.txt
# patterns.txt에 있는 모든 패턴으로 검색
Runps - 실행 중인 프로세스 표시함ps aux
Runtop - 실시간 프로세스 모니터링함top
Runkill - 프로세스 종료함kill -9 1234
Rundf - 디스크 사용량 확인함df -h
Runchmod - 파일 권한 변경함chmod 755 script.sh
Runsudo - 관리자 권한으로 실행함sudo apt update
Runping - 네트워크 연결 테스트함ping google.com
Runwget - 파일 다운로드함wget https://example.com/file.zip
Runssh - 원격 서버 접속함ssh user@192.168.1.100
Runscp - 원격 파일 복사함scp file.txt user@server:/home/user/
Runtar - 파일 압축/해제함tar -czf backup.tar.gz /home/user
Runfind - 파일/디렉토리 검색함find /home -name "*.txt"
Runhistory - 명령어 기록 봄history | tail -10
Run기본 텍스트 출력echo "Hello World"
echo Hello World # 따옴표 없이도 가능
Run옵션들echo -n "줄바꿈 없음" # 줄바꿈 없이 출력
echo -e "줄바꿈\n포함" # 이스케이프 문자 해석
Run이스케이프 시퀀스 (-e 옵션과 함께)echo -e "첫째줄\n둘째줄" # 줄바꿈
echo -e "이름:\t김철수" # 탭
echo -e "Hello\b World" # 백스페이스
Run변수 출력name="김철수"
echo "안녕하세요, $name님!"
echo "현재 사용자: $USER"
echo "홈 디렉토리: $HOME"
Run파일 출력echo "새 내용" &gt; file.txt # 덮어쓰기
echo "추가 내용" &gt;&gt; file.txt # 추가하기
Run명령어 결과와 함께echo "오늘: $(date)"
echo "파일 수: $(ls | wc -l)"
Run색상 출력 (ANSI 코드)echo -e "\033[31m빨간글자\033[0m"
echo -e "\033[32m초록글자\033[0m"
echo -e "\033[1m굵은글자\033[0m"
Run특수 문자 처리echo 'He said "Hello"' # 단일 따옴표로 감싸기
echo "가격: \$100" # 백슬래시로 이스케이프
Run]]></description><link>300-resources/310-개발공부/312-back/linux-명령어-정리.html</link><guid isPermaLink="false">300 Resources/310 개발공부/312 BACK/Linux 명령어 정리.md</guid><pubDate>Sun, 21 Dec 2025 10:17:50 GMT</pubDate></item><item><title><![CDATA[WEB HOOK 관련]]></title><description><![CDATA[<a class="internal-link data-link-icon data-link-icon-after data-link-text" data-href="300 Resources/310 개발공부/311 FRONT/WEB HOOK 관련.md" href="300-resources/310-개발공부/311-front/web-hook-관련.html" target="_self" rel="noopener nofollow" data-link-path="300 Resources/310 개발공부/311 FRONT/WEB HOOK 관련.md" style="--data-link-tags: #tech/devops/cicd; --data-link-path: 300 Resources/310 개발공부/311 FRONT/WEB HOOK 관련.md;" data-link-tags="#tech/devops/cicd">WEB HOOK 관련</a>
특정 이벤트(트리거) 시에 외부에 이벤트를 전달하는 gitlab 자체기능, push, issue 등 다양한 이벤트에 대해서 외부로 api를 날릴 수 있다. github action에서는 cicd pipeline으로 구축했지만 gitlab의 경우 자체기능으로 갖고 있다.
issue가 발생할 때 issue의 create, update, closed 시 외부로 api를 송신해 보자settings 안에 webhooks에서 설정이 가능하다. 수신받을 url 을 입력하고 아래 trigger를 상황에 맞게 체크하면 끝이다.
![](800 References/801 Image/2025/08/WEB HOOK 관련-1C:\work\cursor\blog/posts/100 Resources/103 Developments/WEB HOOK 관련.md
title: WEB HOOK 관련
CMDS:
<br>"<a data-href="posts/900 Settings/901 Main/103 Developments" href=".html" class="internal-link" target="_self" rel="noopener nofollow">posts/900 Settings/901 Main/103 Developments</a>"
excerpt: 특정 이벤트(트리거) 시에 외부에 이벤트를 전달하는 gitlab 자체기능, push, issue 등 다양한 이벤트에 대해서 외부로 api를 날릴 수 있다
thumbnail: /image/Pasted%20image%2020250306212148.png
tags:
CICD
created_at: 2025/03/21 01:15:50
updated_at: 2025/05/14 16:40:44 특정 이벤트(트리거) 시에 외부에 이벤트를 전달하는 gitlab 자체기능, push, issue 등 다양한 이벤트에 대해서 외부로 api를 날릴 수 있다. github action에서는 cicd pipeline으로 구축했지만 gitlab의 경우 자체기능으로 갖고 있다.
issue가 발생할 때 issue의 create, update, closed 시 외부로 api를 송신해 보자settings 안에 webhooks에서 설정이 가능하다. 수신받을 url 을 입력하고 아래 trigger를 상황에 맞게 체크하면 끝이다.<br>
<img src="800-references/801-image/2025/08/web-hook-관련-1.png" target="_self">1테스트 용으로 vercel에서 nextjs boiler plate를 이용했다.// app/api/receive-issue/route.js
import { NextResponse } from 'next/server'; // 간단한 메모리 내 저장소 (실제 서비스에서는 데이터베이스 사용 권장)
let receivedIssues:any[] = []; export async function POST(request:any) { // Secret Token 검증 (옵션) const gitlabToken = request.headers.get('x-gitlab-token'); if (process.env.GITLAB_SECRET_TOKEN &amp;&amp; gitlabToken !== process.env.GITLAB_SECRET_TOKEN) { return NextResponse.json({ error: 'Unauthorized' }, { status: 401 }); } // GitLab에서 전송한 JSON 페이로드 파싱 const payload = await request.json(); console.log('Received GitLab issue payload:', payload); // 수신한 이슈 데이터를 메모리 저장소에 추가 (서버 재시작 시 초기화됨) receivedIssues.push(payload); return NextResponse.json({ message: 'Issue received successfully' });
} export async function GET(request:any) { // 저장된 이슈 데이터를 반환 console.log('logging') return NextResponse.json({ issues: receivedIssues });
}
// app/issues/page.js
'use client'; import useSWR from 'swr'; const fetcher = (url:string) =&gt; fetch(url).then(res =&gt; res.json()); export default function IssuesPage() { const { data, error } = useSWR('/api/receive-issue', fetcher); if (error) return &lt;div&gt;이슈 정보를 불러오는데 에러가 발생했습니다.&lt;/div&gt;; if (!data) return &lt;div&gt;로딩 중...&lt;/div&gt;; return ( &lt;div&gt; &lt;h1&gt;수신된 이슈 목록&lt;/h1&gt; {data.issues.length === 0 ? ( &lt;p&gt;아직 이슈가 수신되지 않았습니다.&lt;/p&gt; ) : ( &lt;ul&gt; {data.issues.map((issue:any, idx:any) =&gt; ( &lt;li key={idx}&gt; &lt;h3&gt;{issue.object_attributes.title}&lt;/h3&gt; &lt;p&gt;{issue.object_attributes.description}&lt;/p&gt; &lt;small&gt;이슈 번호: {issue.object_attributes.iid}&lt;/small&gt; &lt;/li&gt; ))} &lt;/ul&gt; )} &lt;/div&gt; );
}
간단한 이슈를 Closes #1 로 1번 이슈를 종료해봤다.<br>
<img src="800-references/801-image/2025/08/web-hook-관련-2.png" target="_self">1자세한 body의 형태는 아래 document를 참고하면 된다.<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.gitlab.com/user/project/integrations/webhook_events/" target="_self">https://docs.gitlab.com/user/project/integrations/webhook_events/</a>X-Gitlab-Event: Issue Hook{ "object_kind": "issue", "event_type": "issue", "user": { "id": 1, "name": "Administrator", "username": "root", "avatar_url": "http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\u0026d=identicon", "email": "admin@example.com" }, "project": { "id": 1, "name":"Gitlab Test", "description":"Aut reprehenderit ut est.", "web_url":"http://example.com/gitlabhq/gitlab-test", "avatar_url":null, "git_ssh_url":"git@example.com:gitlabhq/gitlab-test.git", "git_http_url":"http://example.com/gitlabhq/gitlab-test.git", "namespace":"GitlabHQ", "visibility_level":20, "path_with_namespace":"gitlabhq/gitlab-test", "default_branch":"master", "ci_config_path": null, "homepage":"http://example.com/gitlabhq/gitlab-test", "url":"http://example.com/gitlabhq/gitlab-test.git", "ssh_url":"git@example.com:gitlabhq/gitlab-test.git", "http_url":"http://example.com/gitlabhq/gitlab-test.git" }, "object_attributes": { "id": 301, "title": "New API: create/update/delete file", "assignee_ids": [51], "assignee_id": 51, "author_id": 51, "project_id": 14, "created_at": "2013-12-03T17:15:43Z", "updated_at": "2013-12-03T17:15:43Z", "updated_by_id": 1, "last_edited_at": null, "last_edited_by_id": null, "relative_position": 0, "description": "Create new API for manipulations with repository", "milestone_id": null, "state_id": 1, "confidential": false, "discussion_locked": true, "due_date": null, "moved_to_id": null, "duplicated_to_id": null, "time_estimate": 0, "total_time_spent": 0, "time_change": 0, "human_total_time_spent": null, "human_time_estimate": null, "human_time_change": null, "weight": null, "health_status": "at_risk", "type": "Issue", "iid": 23, "url": "http://example.com/diaspora/issues/23", "state": "opened", "action": "open", "severity": "high", "escalation_status": "triggered", "escalation_policy": { "id": 18, "name": "Engineering On-call" }, "labels": [{ "id": 206, "title": "API", "color": "#ffffff", "project_id": 14, "created_at": "2013-12-03T17:15:43Z", "updated_at": "2013-12-03T17:15:43Z", "template": false, "description": "API related issues", "type": "ProjectLabel", "group_id": 41 }] }, "repository": { "name": "Gitlab Test", "url": "http://example.com/gitlabhq/gitlab-test.git", "description": "Aut reprehenderit ut est.", "homepage": "http://example.com/gitlabhq/gitlab-test" }, "assignees": [{ "name": "User1", "username": "user1", "avatar_url": "http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\u0026d=identicon" }], "assignee": { "name": "User1", "username": "user1", "avatar_url": "http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\u0026d=identicon" }, "labels": [{ "id": 206, "title": "API", "color": "#ffffff", "project_id": 14, "created_at": "2013-12-03T17:15:43Z", "updated_at": "2013-12-03T17:15:43Z", "template": false, "description": "API related issues", "type": "ProjectLabel", "group_id": 41 }], "changes": { "updated_by_id": { "previous": null, "current": 1 }, "updated_at": { "previous": "2017-09-15 16:50:55 UTC", "current": "2017-09-15 16:52:00 UTC" }, "labels": { "previous": [{ "id": 206, "title": "API", "color": "#ffffff", "project_id": 14, "created_at": "2013-12-03T17:15:43Z", "updated_at": "2013-12-03T17:15:43Z", "template": false, "description": "API related issues", "type": "ProjectLabel", "group_id": 41 }], "current": [{ "id": 205, "title": "Platform", "color": "#123123", "project_id": 14, "created_at": "2013-12-03T17:15:43Z", "updated_at": "2013-12-03T17:15:43Z", "template": false, "description": "Platform related issues", "type": "ProjectLabel", "group_id": 41 }] } }
}
]]></description><link>300-resources/310-개발공부/311-front/web-hook-관련.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/WEB HOOK 관련.md</guid><pubDate>Sun, 21 Dec 2025 10:05:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[파이썬 웹 프레임워크 FastApi]]></title><description><![CDATA[Flask, django에 이은 python web api 라이브러리이다.
대규모의 잦은 요청에도 서비스가 용이한 웹 프레임워크로 성능도 기존 django,flask보다 좋다는 평도 있다. 다만 아직까진 생태계가 형성되지 않은 편이다.기본적으로 fastapi 는 Swagger를 내장한다. 따라서 {root}/docs 위치로 가면 자동으로 fastAPI 내용을 볼 수 있다.
<a class="internal-link" data-href="posts/100-Resources/103 Developments/SWAGGER.md" href=".html" target="_self" rel="noopener nofollow">SWAGGER관련 포스팅</a>
python에서 package를 관리하는 방식이다. 가상환경에서 깔아서 사용한다음 해당 가상환경의 리스소를 pip freeze &gt; requirements.txt 를 이용해서 내보낼 수 있음.
annotated-types==0.7.0
anyio==4.8.0
bcrypt==4.0.1
certifi==2025.1.31
cffi==1.17.1
click==8.1.8
colorama==0.4.6
cryptography==44.0.1
distro==1.9.0
ecdsa==0.19.0
exceptiongroup==1.2.2
fastapi==0.115.8
greenlet==3.1.1
h11==0.14.0
httpcore==1.0.7
httpx==0.28.1
idna==3.10
jiter==0.8.2
openai==1.64.0
passlib==1.7.4
psycopg==3.2.5
psycopg-binary==3.2.5
psycopg-pool==3.2.6
pyasn1==0.4.8
pycparser==2.22
pydantic==2.10.6
pydantic-settings==2.8.0
pydantic_core==2.27.2
python-dotenv==1.0.1
python-jose==3.4.0
python-multipart==0.0.20
pytz==2025.1
rsa==4.9
six==1.17.0
sniffio==1.3.1
starlette==0.45.3
tqdm==4.67.1
typing_extensions==4.12.2
tzdata==2025.1
uvicorn==0.34.0
# 가상화경 만들기
python -m venv .venv # 가상환경 활성화(window 의 경우는 중간에 Script, mac 은 bin)
.venv\Scripts\activate # 리스트 저장 (npm과 같이 나중에 이걸로 설치 가능)
pip freeze &gt; requirements.txt # 수동으로 필수 librrary 설치 내용(일부)
pip install fastapi # fastApi 설치
pip install uvicorn # 만든 웹 실행을 위한 uvicorn
pip install "psycopg[binary, pool]" # postgreSQL 연결을 위한 library 명령어 # 설치된 pip 리스트 보기
pip list # 실행코드
# 나중에 실행하는 명령어 / reload 옵션은 파일 변경시 리빌드
uvicorn main:app --reload # 프로덕션 모드
# 아래는 4개의 프로세스 멀티 프로세스를 지원해서 성능이 높음
uvicorn main:app --workers 4 # linux 운영환경에서는 보통 gunicorn 사용
gunicorn -w 4 -k uvicorn.workers.UvicornWorker main:app main.py에서 사용하는 어플리케이션 app = FastAPI()를 통해서 한줄로 모든 웹설정이 된다. app.get("/") 부분은 routing하는 부분이다.
여타 인증, 인가부분 및 다른 설정을 추가해야한다라곤 해도 python 으로 빠르게 POC를 진행하는거에 대해서는 상당히 편한 라이브러리란 걸 알 수 있다.# main.py
from fastapi import FastAPI
from typing import Union
from controller import items # controller 폴더안에 items 위치 app = FastAPI() @app.get("/")
def read_root(): return {"root":"root"} # main.py 말고 다른 곳에서 동작
app.include_router(items.router)
main.py 부분이 커지면 따로 router 로 지정하고 외부에서 돌릴 수도 있다.# /controller/items.py
from typing import Unopn
from fastapi import APIRouter # 여기에 설정하던지 아니면 main.py include_router에 설정하던지 해야함.
router = APIRouter( prefix="/items", tags=["items"], # swagger 태그 관련 reponses={404:{"description": "Not found"}}
) @router.get("/{item_id}")
def read_item(item_id: int, q: Union[srt, None] = None): return {"item_id": item_id, "q": q} config설정관련해서 config 폴더 내부에서 따로 상수값 설정을 하였다.
# config/config.py # db연결 DSN(DATA SOURCE NAME)
PGSQL_DSN = "postgresql://user:password@host:port/database" # connection_pool
PGSQL_POOL_MIN_SIZE = 10
PGSQL_POOL_MAX_SIZE = 30
PGSQL_POOL_MAX_IDLE = 20
PGSQL_POOL_TIMEOUT = 100 import psycopg
import psycopg_pool
from config import config pool_default = psycopg_pool.ConnectionPool( dns = config.PGSQL_DSN, min_size = config.PGSQL_POOL_MIN_SIZE, max_size = config.PGSQL_POOL_MAX_SIZE, max_idle = config.PGSQL_POOL_MAX_IDLE, timeout = config.PGSQL_POOL_TIMEOUT
) # dao 로 동작함.
async def execute_query(query: str, params: tuple = None): results = None async with pool_default.connection() as conn: async with conn.cursor(row_factory=psycopg.rows.dict_row) as cur: try: if params is None: await cur.execute(query) else: await cur.execute(query, params) results = await cur.fetchall() except psycopg.OperationalError as err: print(f"Error querying: {err}") except psycopg.ProgrammingError as err: print(f"Database error via psycopg: {err}") results = False except psycopg.IntegrityError as err: print(f"PostgreSQL integrity error via psycopg: {err}") results = False return results
#/model/model.py
from pydantic import BaseModel
class Model(): name :str phone :str
“public/image/Pasted image 20250303194456.png” could not be found.1]]></description><link>300-resources/310-개발공부/312-back/파이썬-웹-프레임워크-fastapi.html</link><guid isPermaLink="false">300 Resources/310 개발공부/312 BACK/파이썬 웹 프레임워크 FastApi.md</guid><pubDate>Sun, 21 Dec 2025 10:05:40 GMT</pubDate></item><item><title><![CDATA[백엔드의 3요소]]></title><description><![CDATA[백엔드의 3요소인 웹서버, WAS, 데이터베이스에 대해 알아보고, 안정적인 데이터 전달 방법을 탐구합니다.]]></description><link>300-resources/310-개발공부/312-back/백엔드의-3요소.html</link><guid isPermaLink="false">300 Resources/310 개발공부/312 BACK/백엔드의 3요소.md</guid><pubDate>Sun, 21 Dec 2025 10:05:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[vite 환경]]></title><description><![CDATA[build tool로 vite를 사용시 환경설정은 아래와 같다.
vite 환경에서 package.json을 확인해보면 start 명령어가 없다.
주로 사용하는건 build 혹은 dev를 통해서 확인하고 build 된 프로젝트를 실행하고 싶다면 vite preview 가 권장된다. 이는 CREATE-REACT-APP의 경우 BUILD후 개발서버를 실행하지만 VITE 는 BUILD 없이 실행하는 방식이라서 그렇다. "scripts": { "dev": "vite", "build": "tsc -b &amp;&amp; vite build", "start": "vite preview", "test": "vitest", "test:run": "vitest run", "lint": "eslint .", "preview": "vite preview" }, production의 배포는 build 된 dist 폴더를 웹 서버에 서빙해서 사용한다. nginx 를 이용하는데 vercel이나 netlify를 이용하면 그냥 dist 파일로 배포가 가능하다.
nodejs서버에서 배포한다면 Express로 웹서버를 만들어서 배포할 수 있다.
보통 nodejs기반으로 실행한다고 하면 pm2로 실행할 수 있다.// server.js
import express from 'express';
import path from 'path'; const app = express();
app.use(express.static(path.join(__dirname, 'dist'))); app.get('*', (req, res) =&gt; { res.sendFile(path.join(__dirname, 'dist', 'index.html'));
}); app.listen(3000, () =&gt; console.log('Server running on http://localhost:3000'));
python 환경에선 다음과 같이 직접 fileResponse로 리턴도 가능하다.from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
import os app = FastAPI() # 1️⃣ React 빌드 폴더를 정적 파일로 서빙
app.mount("/static", StaticFiles(directory="frontend/dist"), name="static") # 2️⃣ React의 index.html을 기본 페이지로 설정
@app.get("/")
async def serve_react(): return FileResponse("frontend/dist/index.html") ]]></description><link>300-resources/310-개발공부/311-front/vite-환경.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/vite 환경.md</guid><pubDate>Sun, 21 Dec 2025 10:05:20 GMT</pubDate></item><item><title><![CDATA[TEST for Vitest]]></title><description><![CDATA[
create-react-app 이 지원을 중단하고 많은 개발자들이 빌드도구로서 vite를 사용하게 돼었다. 가볍기도 하고 간단하다. 이 vite의 테스트 도구로서 vitest가 있다. 이 vitest와 jest 의 차이점 및 vite의 사용법을 알아보자
장점 : jest의 가장 큰 장점은 생태계이다. 전통적으로 오래 사용돼 왔고 TDD가 도입되고 프론트엔드까지 테스트코드를 본격적으로 짜는 것은 오래되지 않았다. 그만큼 리소스가 없는 편인데 그나마 오랜기간 사용됐던 jest의 생태계는 무시할 수 없다.단점 : 테스팅 속도가 느리다. 장점 : vite 환경에서 최적화돼서 사용이 가능하다.단점 : 생태계 부족많은 React개발자들이 Nextjs로 넘어가면서 React단독으로 개발하는 경우는 점점 줄어들고 있다. 하지만 Nextjs 는 빌드 과정에서 돌아가는 개발자가 모르는 무수한 코드들에 의해서 무거워진다는 단점이 있다. 그리고 기반자체가 React이기 때문에 React를 잘하는 사람이 결국 Nextjs도 잘 사용할 수 있다고 본다.vitest에서 gloabals로 쓸 타입들을 미리 선언하자/// &lt;reference types="vite/client" /&gt;
/// &lt;reference types="vitest/globals" /&gt;
기본적인 실행환경에대한 설정이다. vite의 경우 defineConfig 로 감싸면 설정이 가능하다.
버전이 바뀌면서 mergeConfig가 Object 객체만 받게 됐다 . 즉 viteConfig는 못받고 객체로 만들어진 viteConfig(configEnv) 상태로 받아야한다.
해당 설정이 justand에서 과거버전으로 되어 있어서 확인하는데 좀 걸렸다.// vitest.config.js
import { defineConfig, mergeConfig } from "vite";
import viteConfig from "./vite.config";
export default defineConfig((configEnv) =&gt; mergeConfig( viteConfig(configEnv), defineConfig({
- test: {
+ test: { environment: "jsdom", // JSDOM 환경 설정 setupFiles: "./src/vitest.setup.tsx", // setup 파일 추가 globals: true, // 글로벌 expect 허용 }, }) )
); 셋업과정에서 사용하는 코드이다. Mui를 사용하는데 MatchMedia를 통해 다크모드를 구현했으므로 이것도 사전에mocking 했다. import { cleanup } from "@testing-library/react";
import '@testing-library/jest-dom' // window.matchMedia Mocking (전역 적용)
Object.defineProperty(window, "matchMedia", { writable: true, value: vi.fn().mockImplementation((query) =&gt; ({ matches: false, // 기본적으로 다크 모드 비활성화 media: query, onchange: null, addListener: vi.fn(), removeListener: vi.fn(), addEventListener: vi.fn(), removeEventListener: vi.fn(), dispatchEvent: vi.fn(), })),
}); // __mocks__ 에 설정한 zustand로 mocking을 하기 위한 설정
vi.mock('zustand') // 각 테스트 후 cleanup 실행 (메모리 누수 방지)
afterEach(() =&gt; { cleanup();
}); 단순히 component만 불러왔을 때 내부에있는 react-router-dom, react-query, Theme 등 사전에 정보를 줘야할 프로바이더들이 없으면 동작하지 않는다. 이를 전달하기 위해 사전에 TestProvider를 만들어 미리 Layout을 정의한다.단 이렇게 Provider나 layout이 덕지덕지 붙은건 rendering하는 속도가 느리기 때문에 테스트코드 실행속도를 저하시킨다 따라서 테스트코드를 작성할때 해당 레이아웃을 따로 불러오는것이 아닌 하나의 테스트코드에서 한번만 불러오도록 선언해야한다.import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { MemoryRouter } from "react-router-dom";
import { ReactNode } from "react";
import ThemeLayout from "./components/ThemeLayout"; // ThemeLayout 경로 확인
import { render } from "@testing-library/react"; // 테스트용 QueryClient 생성
const createTestQueryClient = () =&gt; new QueryClient({ defaultOptions: { queries: { retry: false, // 테스트 중 자동 재시도 방지 }, }, }); function TestProviders({ children }: { children: ReactNode }) { const queryClient = createTestQueryClient(); return ( &lt;QueryClientProvider client={queryClient}&gt; &lt;ThemeLayout&gt; &lt;MemoryRouter&gt;{children}&lt;/MemoryRouter&gt; &lt;/ThemeLayout&gt; &lt;/QueryClientProvider&gt; );
} function customRender(ui: React.ReactNode) { return render(ui, { wrapper: TestProviders });
} export { TestProviders, customRender };
]]></description><link>300-resources/310-개발공부/311-front/test-for-vitest.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/TEST for Vitest.md</guid><pubDate>Sun, 21 Dec 2025 10:05:16 GMT</pubDate></item><item><title><![CDATA[Socket.io]]></title><description><![CDATA[
socket.io는 양방향 소통을 위한 js library이다. 실시간 통신 : 서버, 클라간 양방향 데이터 전송
자동폴백 : websocket우선사용
브로드 캐스트 : 같은 브로드캐스트 내의 유저에게 정보전달
네임스페이스 : 기능별로 채널 분리 가능
room : 네임스페이스 내에서 그룹 나눔가능 클라이언트가 서버에 socket 연결 요청 =&gt; socket.emit()
서버가 연결 수락 ( connection ) =&gt; io.on("connection", (socket)=&gt;{})
서로 이벤트를 주고 받으며 실시간 통신 =&gt; socket.on("emit")
연결 해제시 disconnect 서버내 기능을 논리적으로 구분하기 위한 통로
큰 카테고리를 담당함. ex) 채팅기능, 영상기능, 뉴스기능 등 여러 기능을 수행할 때 네임스페이스 내부의 작은 그룹
const express = require("express");
const http = require("http");
const { Server: SocketIOServer } = require("socket.io"); const app = express();
const server = http.createServer(app); // Socket.IO 서버 설정
let io;
const rooms = {}; // Socket.IO 초기화
io = new SocketIOServer(server, { path: "/socket", // 소켓 경로 설정 cors: { origin: "*", // CORS 허용 (필요에 따라 설정) methods: ["GET", "POST"], },
}); // 소켓 연결 처리
io.on("connection", (socket) =&gt; { console.log("A user connected:", socket.id); // 방 목록 요청 처리 socket.on("getRoomList", () =&gt; { const roomList = Object.keys(rooms); socket.emit("roomList", roomList); }); // 방에 참가 socket.on("joinRoom", ({ chatId }) =&gt; { socket.join(chatId); // 해당 방에 아무도 없으면 방장으로 설정 if (!rooms[chatId]) { rooms[chatId] = { owner: socket.id, users: new Set([socket.id]), elements: [], }; socket.emit("setOwner", true); // 클라이언트에 방장임을 알림 } else { rooms[chatId].users.add(socket.id); socket.emit("setOwner", false); // 클라이언트에 방장이 아님을 알림 socket.emit("initializeDrawing", rooms[chatId].elements); } console.log(`User ${socket.id} joined room ${chatId}`); }); socket.emit("initializeDrawing", () =&gt; { console.log("initializeDrawing emit"); }); // 드로잉 초기화 socket.on("initializeDrawing", () =&gt; { console.log("initializeDrawing on"); socket.emit("initializeDrawing", rooms[chatId].elements); }); // 메시지 전송 socket.on("chatMessage", ({ chatId, message }) =&gt; { io.to(chatId).emit("chatMessage", message); }); // 방장이 그린 요소를 브로드캐스트 socket.on("drawingUpdate", ({ chatId, elements }) =&gt; { if (rooms[chatId]?.owner === socket.id) { rooms[chatId].elements = elements; socket.to(chatId).emit("drawingUpdate", elements); } }); // 유저가 나갔을 때 처리 socket.on("disconnect", () =&gt; { console.log("A user disconnected:", socket.id); // 방에서 나가고 방이 빈 경우 폐기 Object.keys(rooms).forEach((chatId) =&gt; { rooms[chatId]?.users.delete(socket.id); if (rooms[chatId]?.users.size === 0) { console.log(`Deleting empty room ${chatId}`); delete rooms[chatId]; } }); });
}); // Express 기본 라우트 설정
app.get("/", (req, res) =&gt; { res.send("Socket.IO chat server is running");
}); // 서버 실행
const PORT = 5000;
server.listen(PORT, () =&gt; { console.log(`Server is running on http://localhost:${PORT}`);
}); "use client";
import { useGetRoomList } from "@/hooks/useSocket";
import { Button, Flex, Heading, Section, Separator, Text,
} from "@radix-ui/themes";
import { useRouter } from "next/navigation";
import { v4 as uuidv4 } from "uuid"; // UUID를 사용해 랜덤 chatId 생성
import styles from "./styles.module.scss";
import { useThrottle } from "@/hooks/useThrottle";
import { MdOutlineRefresh } from "react-icons/md";
import { stackRouterPush } from "@/utils/stackRouter"; export default function ChatPage() { const router = useRouter(); const { rooms, refresh } = useGetRoomList(); const refreshHandler = useThrottle(refresh, 1000); const createRoom = () =&gt; { const chatId = uuidv4(); // 랜덤 chatId 생성 stackRouterPush(router, `/chat-detail/${chatId}`); }; const joinRoom = (chatId: string) =&gt; { stackRouterPush(router, `/chat-detail/${chatId}`); }; return ( &lt;div&gt; &lt;Section className={styles.chatCreateWrapper}&gt; &lt;Heading as="h2"&gt;chat방 생성&lt;/Heading&gt; &lt;Text&gt;chat방을 만들고 사용자에게 url을 공유하세요&lt;/Text&gt; &lt;Button onClick={createRoom}&gt;Create Room&lt;/Button&gt; &lt;Separator orientation="horizontal" size="4" /&gt; &lt;/Section&gt; &lt;Section className={styles.chatListWrapper}&gt; &lt;Flex direction={"row"} justify={"between"}&gt; &lt;Heading as="h2"&gt;room List&lt;/Heading&gt; &lt;MdOutlineRefresh size={26} onClick={refreshHandler} className={styles.refreshIcon} /&gt; &lt;/Flex&gt; &lt;Flex direction={"column"} gap="1"&gt; {rooms.map((item) =&gt; ( &lt;Button key={item} className={styles.chatRoom} onClick={() =&gt; joinRoom(item)} &gt; {item} &lt;/Button&gt; ))} &lt;/Flex&gt; &lt;Separator orientation="horizontal" size="4" /&gt; &lt;/Section&gt; &lt;/div&gt; );
} // hooks/useSocket.js
import { useEffect, useRef, useState } from "react";
import io, { Socket } from "socket.io-client"; export function useSocket(chatId: string) { const [socket, setSocket] = useState&lt;Socket | null&gt;(null); const [isOwner, setIsOwner] = useState(false); useEffect(() =&gt; { const socket = io(process.env.NEXT_PUBLIC_CHATSOCKET_URL!, { path: "/socket", }); socket.emit("joinRoom", { chatId }); socket.on("setOwner", (isOwner) =&gt; { setIsOwner(isOwner); }); socket.on("roomClosed", () =&gt; { alert("The room was closed by the owner."); // 추가적으로 리디렉션 로직도 여기에 포함 가능 }); setSocket(socket); return () =&gt; { socket.disconnect(); }; }, [chatId]); return { socket, isOwner };
} export function useGetRoomList() { const [rooms, setRooms] = useState([]); const socketRef = useRef&lt;Socket | null&gt;(null); // refresh const refresh = () =&gt; { if (socketRef.current) { socketRef.current.emit("getRoomList"); } }; useEffect(() =&gt; { const socket = io(process.env.NEXT_PUBLIC_CHATSOCKET_URL!, { path: "/socket", }); socketRef.current = socket; // 방 목록 요청 socket.emit("getRoomList"); // 서버에서 받은 방 목록 처리 socket.on("roomList", (roomList) =&gt; { setRooms(roomList); }); // 컴포넌트 언마운트 시 소켓 이벤트 정리 return () =&gt; { socket.off("roomList"); }; }, []); return { rooms, refresh };
}
]]></description><link>300-resources/310-개발공부/311-front/socket.io.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Socket.io.md</guid><pubDate>Sun, 21 Dec 2025 10:05:12 GMT</pubDate></item><item><title><![CDATA[script async,defer처리]]></title><description><![CDATA[레거시 환경에서 개발하다보면 &lt;script defer&gt; 같이 defer 를 종종보게된다. 해당 요소의 의미는 파싱과정에서 script를 만나게 되더라도 병렬로 다운받으라는 의미이다. html이 처음 나왔을 때는 script요소를 만나면 파싱을 중단하고 즉각적으로 다운로드 받았지만 이제 defer로 파싱을 하면서 다운받게 된다. 이런 dom 파싱 여부와 실행시점은 script에 달려있는 defer, async 와 script태그의 위치에 따라서 결정된다.기본적으로 dom파싱이 중단되고 js 를 실행하는건 사용자 경험에 안좋은 영향을 끼친다.
또한 async의 경우 실행 순서가 dom 파싱이후 js실행이 보장되지 않으므로 특정 상황을 제외하고는
defer를 쓰도록 하고 특히 script가 head에 있을 때는 무조건 defer/async를 명시하도록 하자.
실행 순서가 중요하지 않은 독립적인 스크립트에 유용 / 광고, 트래킹, sns위젯등의 외부 스크립트 단, 광고사이트 등이 모종의 이유로 js를 늦게 준다면 html parsing이 계속 되지 않는 경우가 발생(일부 구글광고가 defer를 지원안함...)
]]></description><link>300-resources/310-개발공부/311-front/script-async,defer처리.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/script async,defer처리.md</guid><pubDate>Sun, 21 Dec 2025 10:05:08 GMT</pubDate></item><item><title><![CDATA[Rendered fewer hooks than expected 에러 관련]]></title><description><![CDATA[워크플로우 템플릿 불러오기 기능을 구현하면서
"Rendered fewer hooks than expected"
에러와 함께 여러 가지 리렌더링/상태 꼬임 문제를 겪었습니다.
아래는 문제 해결을 위해 시도했던 모든 방법과 실제 적용된 코드를 정리한 내용입니다.문제 추측: 템플릿 불러오기 시
setWorkflowTitle, setTemplateId 등 여러 setState와
replaceAll(Context 전체 교체)이 동시에 일어나
렌더링이 꼬인다고 생각.
as-is 코드:setWorkflowTitle(template.name || '');
setTemplateId(template.id);
replaceAll(template.template?.nodes || [], template.template?.connections || []);
to-be 코드: 상태 변경을 분리하기 위해 setTimeout, useTransition 등으로 분리
setWorkflowTitle(template.name || '');
setTemplateId(template.id);
setTimeout(() =&gt; { replaceAll(template.template?.nodes || [], template.template?.connections || []);
}, 0);
또는const [isPending, startTransition] = useTransition();
startTransition(() =&gt; { replaceAll(template.template?.nodes || [], template.template?.connections || []);
});
결과: 여전히 동일한 에러 발생
문제 추측: replaceAll이 실행되면 Context의 노드/커넥션이 완전히 교체됨
이때 기존에 있던 FlowNode 등 하위 컴포넌트가 언마운트/마운트됨
이 과정에서 훅 호출 순서가 꼬인다고 생각
as-is 코드: FlowNode 내부에서 node가 undefined일 때 바로 return
const node = useNodeSelector(nodeId);
if (!node) return null; // &lt;-- 문제의 코드
// ...아래에 여러 훅이 있을 수 있음
to-be 코드: 훅 선언은 항상 최상단에서, 조건부 렌더링은 훅 선언 이후에만!
const node = useNodeSelector(nodeId);
// ...다른 훅들 if (!node) { // 훅은 항상 실행, 렌더만 최소화 return &lt;div style={{display: 'none'}} /&gt;;
}
또는,
부모에서 조건부 렌더링:{nodeIds.map(nodeId =&gt; { const node = getNode(nodeId); if (!node) return null; return ( &lt;FlowNode key={nodeId} nodeId={nodeId} // ...props /&gt; );
})}
결과: 에러가 완전히 해결됨!
문제 추측: replaceAll로 노드가 교체되는 순간,
이미 언마운트된 FlowNode에서 setState가 호출될 수 있다고 생각
as-is 코드: React.useEffect(() =&gt; { setNode(getNode(nodeId)); const unsubscribe = subscribeToNode(nodeId, () =&gt; { setNode(getNode(nodeId)); }); return () =&gt; { unsubscribe(); };
}, [nodeId, getNode, subscribeToNode]);
to-be 코드: setState 전에 언마운트 여부 체크(필요시)
React.useEffect(() =&gt; { let unmounted = false; setNode(getNode(nodeId)); const unsubscribe = subscribeToNode(nodeId, () =&gt; { if (!unmounted) setNode(getNode(nodeId)); }); return () =&gt; { unmounted = true; unsubscribe(); };
}, [nodeId, getNode, subscribeToNode]);
결과: race condition 방지, 하지만 핵심 원인은 아니었음 훅은 항상 컴포넌트 최상단에서, 조건 없이 실행!
조건부 렌더링은 훅 선언 이후에만!
여러 상태 변경은 setTimeout, useTransition 등으로 분리하면 더 안전!
부모에서 조건부 렌더링을 해주는 것도 좋은 방법!
이런 과정을 통해
"Rendered fewer hooks than expected"
에러를 완벽하게 해결할 수 있었습니다.
훅 선언 전에 return null 하지 마세요!
map으로 여러 컴포넌트를 렌더링할 때 key는 항상 고유한 값(nodeId 등)으로!
상태/Context 전체 교체 시에는 트리 구조 변화에 주의하세요!
이 글이 비슷한 문제를 겪는 분들께 도움이 되길 바랍니다.]]></description><link>300-resources/310-개발공부/311-front/rendered-fewer-hooks-than-expected-에러-관련.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Rendered fewer hooks than expected 에러 관련.md</guid><pubDate>Sun, 21 Dec 2025 10:05:03 GMT</pubDate></item><item><title><![CDATA[REACT에서 자주 업데이트되는 데이터리스트 관리방식]]></title><description><![CDATA[일반적으로 array를 사용해서 여러개의 데이터를 관리한다. 하지만 이렇게 관리시 얕은 비교를 통해서 React.memo를 사용해도 리스트 전체 데이터가 리렌더링되는 방식으로 된다. Map을 사용하면 변경된 항목만 새로운 객체를 생성하고 나머지 항목은 기존참조를 유지하게 된다. 따라서 나머지 항목들은 리렌더링되지 않아 React.memo와 사용시 렌더링 최적화에 우수하다. / 여러 항목들을 같이 관리해야할 상황에서 update가 잦을 때 사용하면 좋다.<img src="800-references/801-image/2025/08/react에서-자주-업데이트되는-데이터리스트-관리방식-1.png" target="_self">1일반적으로 React에서 리스트 데이터를 관리할 때 배열을 사용합니다:const [users, setUsers] = useState([ { id: 1, name: 'Alice', age: 25 }, { id: 2, name: 'Bob', age: 30 }, { id: 3, name: 'Charlie', age: 35 }
]); // 특정 사용자 업데이트
const updateUser = (id, newData) =&gt; { setUsers(prevUsers =&gt; prevUsers.map(user =&gt; user.id === id ? { ...user, ...newData } : user ) );
};
이 방식의 문제점:
전체 배열이 새로 생성됨: 하나의 항목만 변경되어도 전체 배열이 재생성
모든 컴포넌트 리렌더링: 배열 참조가 변경되어 모든 자식 컴포넌트가 리렌더링
O(n) 검색 복잡도: 특정 항목을 찾기 위해 전체 배열을 순회
Map 데이터 구조를 사용하면 이러한 문제점들을 해결할 수 있습니다:const [usersMap, setUsersMap] = useState(new Map([ [1, { id: 1, name: 'Alice', age: 25 }], [2, { id: 2, name: 'Bob', age: 30 }], [3, { id: 3, name: 'Charlie', age: 35 }]
])); // 특정 사용자 업데이트
const updateUser = (id, newData) =&gt; { setUsersMap(prevMap =&gt; { const newMap = new Map(prevMap); const existingUser = newMap.get(id); newMap.set(id, { ...existingUser, ...newData }); return newMap; });
};
// Array: O(n) 복잡도
const user = users.find(u =&gt; u.id === targetId); // Map: O(1) 복잡도
const user = usersMap.get(targetId);
Map을 사용하면 변경된 항목만 새로운 객체를 생성하고, 나머지는 기존 참조를 유지할 수 있습니다:const useOptimizedUsers = () =&gt; { const [usersMap, setUsersMap] = useState(new Map()); const updateUser = useCallback((id, updates) =&gt; { setUsersMap(prev =&gt; { const newMap = new Map(prev); const existingUser = newMap.get(id); // 기존 객체와 비교하여 실제 변경이 있을 때만 업데이트 if (existingUser &amp;&amp; !isEqual(existingUser, { ...existingUser, ...updates })) { newMap.set(id, { ...existingUser, ...updates }); return newMap; } return prev; // 변경사항이 없으면 기존 Map 반환 }); }, []); return { usersMap, updateUser };
};
React.memo와 함께 사용하면 더욱 효과적입니다:const UserItem = React.memo(({ user, onUpdate }) =&gt; { console.log(`Rendering user: ${user.name}`); // 변경된 항목만 출력됨 return ( &lt;div&gt; &lt;h3&gt;{user.name}&lt;/h3&gt; &lt;p&gt;Age: {user.age}&lt;/p&gt; &lt;button onClick={() =&gt; onUpdate(user.id, { age: user.age + 1 })}&gt; Increase Age &lt;/button&gt; &lt;/div&gt; );
}); const UserList = () =&gt; { const { usersMap, updateUser } = useOptimizedUsers(); return ( &lt;div&gt; {Array.from(usersMap.values()).map(user =&gt; ( &lt;UserItem key={user.id} user={user} onUpdate={updateUser} /&gt; ))} &lt;/div&gt; );
};
Runconst useShoppingCart = () =&gt; { const [itemsMap, setItemsMap] = useState(new Map()); const addItem = useCallback((product) =&gt; { setItemsMap(prev =&gt; { const newMap = new Map(prev); const existingItem = newMap.get(product.id); if (existingItem) { newMap.set(product.id, { ...existingItem, quantity: existingItem.quantity + 1 }); } else { newMap.set(product.id, { ...product, quantity: 1 }); } return newMap; }); }, []); const removeItem = useCallback((productId) =&gt; { setItemsMap(prev =&gt; { const newMap = new Map(prev); newMap.delete(productId); return newMap; }); }, []); const updateQuantity = useCallback((productId, quantity) =&gt; { if (quantity &lt;= 0) { removeItem(productId); return; } setItemsMap(prev =&gt; { const newMap = new Map(prev); const item = newMap.get(productId); if (item) { newMap.set(productId, { ...item, quantity }); } return newMap; }); }, [removeItem]); const totalPrice = useMemo(() =&gt; { return Array.from(itemsMap.values()) .reduce((sum, item) =&gt; sum + (item.price * item.quantity), 0); }, [itemsMap]); return { items: Array.from(itemsMap.values()), itemsMap, addItem, removeItem, updateQuantity, totalPrice };
};
Run// 성능 측정을 위한 간단한 벤치마크
const measurePerformance = (operation, iterations = 1000) =&gt; { const start = performance.now(); for (let i = 0; i &lt; iterations; i++) { operation(); } const end = performance.now(); return end - start;
}; // Array vs Map 비교
const arrayData = Array.from({ length: 1000 }, (_, i) =&gt; ({ id: i, value: i }));
const mapData = new Map(arrayData.map(item =&gt; [item.id, item])); // 검색 성능
const arraySearchTime = measurePerformance(() =&gt; { arrayData.find(item =&gt; item.id === 500);
}); const mapSearchTime = measurePerformance(() =&gt; { mapData.get(500);
}); console.log(`Array 검색: ${arraySearchTime}ms`);
console.log(`Map 검색: ${mapSearchTime}ms`);
Run데이터 크기가 매우 작다면 (&lt; 10개) Array의 단순함이 더 나을 수 있습니다.Map은 JSON.stringify로 직접 직렬화되지 않으므로, 필요시 변환 로직이 필요합니다:// Map을 일반 객체로 변환
const mapToObject = (map) =&gt; Object.fromEntries(map); // 일반 객체를 Map으로 변환
const objectToMap = (obj) =&gt; new Map(Object.entries(obj));
Run재사용성을 위해 Map 기반 상태 관리를 커스텀 훅으로 추상화하는 것이 좋습니다:const useMapState = (initialData = []) =&gt; { const [dataMap, setDataMap] = useState( new Map(initialData.map(item =&gt; [item.id, item])) ); const operations = useMemo(() =&gt; ({ get: (id) =&gt; dataMap.get(id), set: (id, data) =&gt; setDataMap(prev =&gt; new Map(prev).set(id, data)), delete: (id) =&gt; setDataMap(prev =&gt; { const newMap = new Map(prev); newMap.delete(id); return newMap; }), clear: () =&gt; setDataMap(new Map()), values: () =&gt; Array.from(dataMap.values()), keys: () =&gt; Array.from(dataMap.keys()), size: dataMap.size }), [dataMap]); return [dataMap, operations];
};
RunMap 데이터 구조를 활용한 상태 관리는 React 애플리케이션의 성능을 크게 향상시킬 수 있는 강력한 기법입니다. 특히 대량의 데이터를 다루거나 빈번한 업데이트가 발생하는 경우, Map의 O(1) 검색 성능과 부분적 업데이트 특성이 큰 이점을 제공합니다.하지만 모든 상황에서 Map이 최선의 선택은 아닙니다. 데이터의 크기, 사용 패턴, 팀의 익숙함 등을 종합적으로 고려하여 적절한 데이터 구조를 선택하는 것이 중요합니다. Map을 도입할 때는 점진적으로 적용하면서 실제 성능 향상을 측정해보는 것을 권장합니다.]]></description><link>300-resources/310-개발공부/311-front/react에서-자주-업데이트되는-데이터리스트-관리방식.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/REACT에서 자주 업데이트되는 데이터리스트 관리방식.md</guid><pubDate>Sun, 21 Dec 2025 10:04:45 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[React-query]]></title><description><![CDATA[서버 상태 가져오기, 캐싱, 동기화 및 업데이트 를 하는 react 전용 상태관리 라이브러리이다. (비동기 or 서버상태 작업에 특화)
queryClient 에서 전역설정 및 캐싱데이터 관리
설치 및 Provider설정 / 전역설정 설정
전역 로딩설정
다음 사용자 행동을 예측해서 가져오기 queryClient.prefetchQuery
쿼리 수동 취소 `queryClient.cancelQueries
강제 refresh queryClient.invalidateQueries
기본타입 &lt;TQueryFnData, TError, TData, TQueryKey&gt;
useQuery로 데이터가져오기
기본조회 useQuery
조회간 순서가 보장돼야 하는 경우 useQueries
각각 다른 쿼리의 조회 결과 조합 useQuery의 combine 속성
useInfiniteQuery로 무한스크롤로 가져오기 useMutation로 낙관적 변경 설치 / 이슈
# 현재 react-native webview 쪽에서 v5를 쓰면 에뮬레이터상 에러발생으로 v4로 진행(에뮬레이터 버전이 낮아서 발생)
npm i @tanstack/react-query@4.7.1
npm i @tanstack/react-query-devtools@4.7.1 Provider 설정 / Error나 전역 설정위치
//QueryClientProvider.tsx
import {QueryClient, QueryClientProvider} from '@tanstack/react-query';
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { toast } from "react-toastify"; // custom Client
const queryClient = new QueryClient({ defaultOptions:{ queries:{ // useQuery의 기본 세팅 // 전역 에러설정 onError: (error) =&gt; { toast.error("에러메세지"); } }, mutations: { // useMutation의 기본세팅 }, }
}); function CustomQueryClientProvider(){ return ( &lt;QueryClientProvider client={queryClient}&gt; {children} &lt;ReactQueryDevtools /&gt; &lt;/QueryClientProvider&gt; )
}
import { ReactElement } from "react";
import { useIsFetching, useIsMutating } from "@tanstack/react-query";
import styles from "./Loading.module.scss"; export default function Loading(): ReactElement { const isFetching = useIsFetching(); const isMutatuing = useIsMutating(); const display = isFetching || isMutatuing ? "block" : "none"; return ( &lt;div className={styles.wrapper} style={{ display: display }}&gt; &lt;svg className={styles.circlewrapper} viewBox="25 25 50 50"&gt; &lt;circle className={styles.circle} r="20" cy="50" cx="50"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt; );
}
const prefetchNextPosts = async (nextPage: number) =&gt; { const queryClient = useQueryClient(); // 해당 쿼리의 결과는 일반 쿼리들처럼 캐싱 된다. await queryClient.prefetchQuery({ queryKey: ["posts", nextPage], queryFn: () =&gt; fetchPosts(nextPage), // ...options });
};
import {queryClient} from "@tanstack/react-query"; const queryClient = useQueryClient(); const onCancelHandler = (e)=&gt;{ queryClient.cancelQueries({queryKey:["query-key"]})
} import {queryClient} from "@tanstack/react-query"; const queryClient = useQueryClient(); const onCancelHandler = (e)=&gt;{ queryClient.invalidateQueries({ queryKey: ["super-heroes"] }); // 보통 useMutation과 같이 사용해서 사용자가 CUD 작업을 한 뒤 다시 조회
} useQuery, useMutation, useInfiniteQuery 모두 일반적으로 4개를 사용한다.
&lt;TQueryFnData, TError, TData, TQueryKey&gt;
backEnd에서 받은데이터, 받은 에러, 최종데이터, key배열 형태
보통 select를 쓰지 않는다면 1,3번은 같기도 하고 queryFn에서 반환데이터 타입을 잘 정의하면 자동정의되므로 queryFn의 반환타입을 정의하자
const getFn = async ():Promise&lt;Response&lt;any[]&gt;&gt; =&gt;{ return await fetch("http://"); }; const { data : data명칭, error, status, fetchStatus, isLoading, // 기존의 캐시데이터 없음 isFetching, // 비동기함수 처리여부 isError, refetch
} = useQuery({ queryKey: ["queryKey1","queryKey2"], // react-query가 관리하는 cache 데이터의 key값 queryFn : getFn, // promise로 반환하는 fetch data //options select: (data) =&gt; (data가공), data를 가공해서 반환 gcTime : 5 * 60 * 1000, staleTime : 1* 60 * 1000, retry : 1, enabled : true // 실행조건 *false 시 invalidateQueries, refetchQueries 도 무시 placeholderData: placeholderData, // 초기 세팅 , v5에는 keepPreviousData이 없고 이를대체 notifyOnChangeProps : ["data"] , // 특정 값 이상시 dependencies 같이 활동 // polling 실행 refetchInterval : 2000, refetchIntervalInBackground : true
}) // Defendent Queries 종속 순서에 상관이 있을 때 // 사전에 완료되어야 할 쿼리
const { data: user } = useQuery({ queryKey: ["user", email], queryFn: () =&gt; getUserByEmail(email),
}); const channelId = user?.data.channelId; // user 쿼리에 종속 쿼리
const { data: courses } = useQuery({ queryKey: ["courses", channelId], queryFn: () =&gt; getCoursesByChannelId(channelId), enabled: !!channelId,
}); enabled 부분을 앞에 보장되어야하는 쿼리의 데이터 값으로 설정하여 앞 쿼리가 실행되지 않으면 불가하도록 변경
// 사전에 완료되어야 할 쿼리
const { data: user } = useQuery({ queryKey: ["user", email], queryFn: () =&gt; getUserByEmail(email),
}); const channelId = user?.data.channelId; // user 쿼리에 종속 쿼리
const { data: courses } = useQuery({ queryKey: ["courses", channelId], queryFn: () =&gt; getCoursesByChannelId(channelId), enabled: !!channelId,
});
// paraeele
const queryResults = useQueries({ queries:[ { queryKey: ["queryKey",1], queryFn : ()=&gt;queryFn }, { queryKey: ["queryKey",2], queryFn : ()=&gt;queryFn }, ]
}) // 복수개의 쿼리 결과를 조합해서 추출
// front 단에서 데이터를 join해서 쓸 수 있다. (성능을 생각하면 back에서 하는게 맞다.)
const combinedQueries = useQueries({ queries: [ {queryKey:["userKey"], queryFn: () =&gt; fetchUser(id)}, {queryKey:["postKey"], queryFn: () =&gt; fetchFost(id)} ] combine: (results) =&gt; { return ({ data: results.map(result =&gt; result.data.map()), pending: results.some(result =&gt; result.isPending), }) }
})
async function fetchSongs({ page, limit }: SearchParams) { const response = await fetch(`/api/songs?page=${page}&amp;limit=${limit}`); if (!response.ok) { throw new Error("Failed to fetch songs"); } const data: Song[] = await response.json(); return data || [];
} function useInfiniteSongList({ limit }: any) { return useInfiniteQuery&lt;Song[],Error&gt;({ queryKey: ["songs"], queryFn: ( {pageParam=1} ) =&gt; fetchSongs({ page:pageParam, limit }), //initialPageParam: 1, // v5에서 초기값 설정 getNextPageParam: (lastPage, allPages) =&gt; { return lastPage.length &lt; limit ? undefined : allPages.length + 1; }, });
} const { mutate, isLoading, isError, isSuccess, error } = useMutation({ mutationFn: createTodo, onMutate() { /* ... */ }, onSuccess(data) { console.log(data); }, onError(err) { console.log(err); }, onSettled() { /* ... */ },
}); mutate(data) 보통 customHook 을 만들 때 recoil이랑 같이 사용하여 효율적인 전역변수 생성이 가능하다
// useUser.js
import { useQuery } from '@tanstack/react-query';
import { useSetRecoilState } from 'recoil';
import { userState } from './recoilState';
import axios from 'axios'; const fetchUser = async () =&gt; { const response = await axios.get('/api/user'); // 예시 API 호출 return response.data;
}; export const useUser = () =&gt; { const setUser = useSetRecoilState(userState); return useQuery({ queryKey:['user'], queryFn:fetchUser, onSuccess: (data) =&gt; { setUser(data); // 성공 시 Recoil에 데이터 저장 }, onError: (error) =&gt; { console.error('Failed to fetch user:', error); }, });
}; ]]></description><link>300-resources/310-개발공부/311-front/react-query.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/React-query.md</guid><pubDate>Sun, 21 Dec 2025 10:04:41 GMT</pubDate></item><item><title><![CDATA[React 의 FLUX 구조]]></title><description><![CDATA[
프로그래밍에서는 VIEW, MODEL , CONTROLLER 로 각자의 역할을 맡아 동작하는 부분을 나눠 객체지향적으로 SOLID 구조를 통해 변화를 유연하게 하고 재사용성을 높이는 패턴이 존재한다. 백엔드에서는 solid 원칙을 통해 로직을 단일책임으로 만들면 MVC 패턴이 유용하여 많이 사용하지만 FRONT 에서는 데이터에 따라서 VIEW가 변하는 방향이 많아 VIEW에 대한 의존성이 높아 로직의 재사용성이 낮다. 그래서 MVVM으로 비즈니스로직을 VIEW MODEL에 흡수시킨 부분이 많다. 프론트는 해당 시스템을 사용하는 사용자와 직접적으로 연관있는 부분이다. 사실상 FE 자체가 VIEW라는 역할을 수행하고 있는것과 다름이 없다.
다만 VIEW 뿐만이 아니라 온갖 이벤트도 발생하고 있고 VIEW와 상관없는 이벤트들도 시스템에 따라서 구현되기도 한다. 이 과정에서 VIEW는 MODEL과 서로 영향을 주게된다. INPUT값에서 시스템 값이 바뀌면 MODEL의 값이 변하기도 하고 반대로 어떤 동작을통해 세팅값이 바뀌면 그 세팅값에 따라서 VIEW도 바뀌어야한다. 서로 상호적인 관계가 되면서 VIEW와 MODEL은 서로 상호작용을 해야한다. 이걸 가운데에 CONTROLLER로 구현하면 VIEW,MODEL 수가 증가함에 따라 CONTROLLER가 비대해지는 문제가 발생한다.
MVVM
리액트의 MVVM구조는 화면의 tsx 구조와 커스텀 훅으로 이루어진다고 보면 편하다.
tsx 표기구조를 view로 보고 커스텀 훅이 vm 역할을 한다. 이를 통해 view 역할을 하는 UI적 요소와 비지니스 로직, 이벤트가 들어있는 부분을 CUSTOM HOOK 으로 만들어 VEIW 모델의 역할을 한다.
// 전체적으로 view와 viewModel 부분을 통합한 페이지
// page.tsx
import UserView from './UserView';
import UserView from './UserView';
import { useUserViewModel } from './useUserViewModel'; type pageParams ={ userID: number
} export default const MyPage: React.FC = ({userId}: pageParams) =&gt; { // custom Hook 으로 view Model의 역할을 함. 외부로부터 userId의 이벤트 변경을 받기도 하며 // view 단으로 내려갈 user, loading, erorr, refecht 등의 데이터를 세팅함 const { user, loading, error, refetch } = useUserViewModel(userId); return ( &lt;div&gt; &lt;!-- custom Hook 에서 연동된 대아터를 UI만은 담당하는 component로 내려줌 --&gt; &lt;UserView user={user} loading={loading} error={error} refetch={refetch} /&gt; &lt;/div&gt; );
}; // userModel.ts 백단과 소통하는 User 부분을 정의하고 직접적으로 요청해서 받는 부분도 포함함.
export interface User { id: number; name: string; email: string; phone: string;
} export const fetchUserData = async (userId: number): Promise&lt;User&gt; =&gt; { const response = await fetch(`/api/users/${userId}`); if (!response.ok) { throw new Error('Failed to fetch user data'); } return response.json();
}; // useUserViewModel.ts
// custom Hook으로 비지니스 로직부분과 view단에 그려지는 화면과 연결된 데이터를 가지고 있음
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { User, fetchUserData } from './userModel'; interface UserViewModel { user: User | undefined; loading: boolean; error: string | null; refetch: () =&gt; void;
} export const useUserViewModel = (userId: number): UserViewModel =&gt; { const queryClient = useQueryClient(); const { data: user, isLoading: loading, error, refetch } = useQuery&lt;User, Error&gt;( ['user', userId], // Query key () =&gt; fetchUserData(userId), // Query function (Model 호출) { enabled: !!userId, // userId가 존재할 때만 실행 } ); return { user, loading, error: error ? error.message : null, refetch, };
}; ]]></description><link>300-resources/310-개발공부/311-front/react-의-flux-구조.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/React 의 FLUX 구조.md</guid><pubDate>Sun, 21 Dec 2025 10:04:12 GMT</pubDate></item><item><title><![CDATA[React 성능 최적화 useContext를 이용하여 부분적으로 전역변수 사용으로 불필요한 리렌더링 제거하기]]></title><description><![CDATA[불필요한 리렌더링을 줄이기 위해 useContext를 사용하여 부분적으로 전역변수를 적용하여 리렌더링을 최소화 한다 이 방식은 Observer패턴과 같은 방식이다.이번 글에서는 실제 워크플로우 에디터 프로젝트를 통해 Context + Selector 패턴이 어떻게 이런 문제를 해결하는지 살펴보겠습니다.워크플로우 에디터에서 노드 하나의 상태가 변경될 때마다 모든 노드 컴포넌트가 리렌더링되는 문제가 있었습니다.// ❌ 문제가 있는 기존 방식
const FlowEditor = () =&gt; { const [nodes, setNodes] = useState&lt;Record&lt;string, WorkflowNode&gt;&gt;({}); const handleStatusChange = (nodeId: string, status: WorkflowNodeState) =&gt; { setNodes(prev =&gt; ({ ...prev, [nodeId]: { ...prev[nodeId], state: status } })); }; return ( &lt;div&gt; {Object.values(nodes).map(node =&gt; ( &lt;FlowNode key={node.id} node={node} nodes={nodes} // 하위노드에서 타 노드의 변경작업을 위해 조회하고 있음 onStatusChange={handleStatusChange} /&gt; ))} &lt;/div&gt; );
}; const FlowNode = React.memo(({ node, nodes, onStatusChange }) =&gt; { // nodes 객체가 바뀔 때마다 모든 FlowNode가 리렌더링 // React.memo가 무용지물이 됨! const relatedNodes = getRelatedNodes(node.id, nodes); return ( &lt;div&gt; {node.title} - {node.state} {/* 관련 노드들 정보 표시 */} &lt;/div&gt; );
}); 전체 객체 전달: nodes 전체가 props로 전달됨
참조 변경: 하나의 노드만 변경되어도 nodes 객체 참조가 바뀜
React.memo 실패: 얕은 비교로 인해 모든 컴포넌트가 리렌더링
성능 저하: 노드가 많아질수록 성능이 급격히 악화
Context + Selector 패턴은 다음과 같은 아이디어를 기반으로 합니다:
중앙 상태 관리: Context로 전역 상태 제공
선택적 구독: 각 컴포넌트가 필요한 데이터만 구독
Map 기반 저장: O(1) 접근 성능과 부분 업데이트
Observer 패턴: 관련 컴포넌트에게만 변경 알림
// contexts/WorkflowContext.tsx
import React, { createContext, useContext, useState, useCallback, useMemo } from 'react'; interface WorkflowContextType { updateNode: (nodeId: string, updatedData: Partial&lt;WorkflowNode&gt;) =&gt; void; handleStatusChange: (nodeId: string, status: WorkflowNodeState) =&gt; void; // 선택적 구독을 위한 셀렉터들 getNode: (nodeId: string) =&gt; WorkflowNode | undefined; getRelatedNodes: (nodeId: string) =&gt; WorkflowNode[]; getAllNodeIds: () =&gt; string[];
} const WorkflowContext = createContext&lt;WorkflowContextType | null&gt;(null); export const WorkflowProvider: React.FC&lt;{ children: React.ReactNode }&gt; = ({ children }) =&gt; { // 🎯 Map으로 노드 관리 (성능 최적화) const [nodesMap, setNodesMap] = useState&lt;Map&lt;string, WorkflowNode&gt;&gt;(new Map()); // 노드 업데이트 - Map의 장점 활용 const updateNode = useCallback((nodeId: string, updatedData: Partial&lt;WorkflowNode&gt;) =&gt; { setNodesMap(prev =&gt; { const newMap = new Map(prev); const existingNode = newMap.get(nodeId); if (!existingNode) return prev; // 변경된 노드만 새 객체 생성 newMap.set(nodeId, { ...existingNode, ...updatedData }); return newMap; }); }, []); // 상태 변경 처리 (Observer 패턴 적용) const handleStatusChange = useCallback((nodeId: string, status: WorkflowNodeState) =&gt; { setNodesMap(prev =&gt; { const currentNode = prev.get(nodeId); if (!currentNode || currentNode.state !== 'do') return prev; const newMap = new Map(prev); // 현재 노드 상태 업데이트 newMap.set(nodeId, { ...currentNode, state: status }); // 다음 노드들 활성화 체크 (complete인 경우만) if (status === 'complete') { (currentNode.nextFlow || []).forEach(nextId =&gt; { const nextNode = newMap.get(nextId); if (!nextNode || nextNode.state !== 'wait') return; const shouldActivate = checkActivationCondition(nextId, newMap); if (shouldActivate) { newMap.set(nextId, { ...nextNode, state: 'do' }); } }); } return newMap; }); }, []); // 활성화 조건 체크 const checkActivationCondition = useCallback((nodeId: string, nodesMap: Map&lt;string, WorkflowNode&gt;) =&gt; { const node = nodesMap.get(nodeId); if (!node || node.state !== 'wait') return false; const requiredIds = node.activateCondition || []; if (requiredIds.length === 0) return false; if (node.activateConditionType === 'all') { return requiredIds.every(id =&gt; nodesMap.get(id)?.state === 'complete'); } else { return requiredIds.some(id =&gt; nodesMap.get(id)?.state === 'complete'); } }, []); // 📊 선택적 구독을 위한 셀렉터들 const contextValue = useMemo&lt;WorkflowContextType&gt;(() =&gt; ({ updateNode, handleStatusChange, // 셀렉터들 - 각 컴포넌트가 필요한 데이터만 가져옴 getNode: (nodeId: string) =&gt; nodesMap.get(nodeId), getRelatedNodes: (nodeId: string) =&gt; { const node = nodesMap.get(nodeId); if (!node) return []; const relatedIds = [ ...(node.frontFlow || []), ...(node.nextFlow || []) ]; return relatedIds.map(id =&gt; nodesMap.get(id)).filter(Boolean) as WorkflowNode[]; }, getAllNodeIds: () =&gt; Array.from(nodesMap.keys()), }), [updateNode, handleStatusChange, nodesMap]); return ( &lt;WorkflowContext.Provider value={contextValue}&gt; {children} &lt;/WorkflowContext.Provider&gt; );
}; export const useWorkflowContext = () =&gt; { const context = useContext(WorkflowContext); if (!context) { throw new Error('useWorkflowContext must be used within WorkflowProvider'); } return context;
};
// 🎯 핵심: 각 노드가 자신의 데이터만 구독
export const useNodeSelector = (nodeId: string) =&gt; { const { getNode } = useWorkflowContext(); const [node, setNode] = useState(() =&gt; getNode(nodeId)); // 해당 노드만 구독 (실제로는 더 정교한 구독 시스템 필요) React.useEffect(() =&gt; { const checkForUpdates = () =&gt; { const currentNode = getNode(nodeId); setNode(prev =&gt; { if (!prev &amp;&amp; !currentNode) return prev; if (!prev || !currentNode) return currentNode; // 얕은 비교로 변경 감지 const changed = Object.keys(currentNode).some(key =&gt; currentNode[key as keyof WorkflowNode] !== prev[key as keyof WorkflowNode] ); return changed ? currentNode : prev; }); }; const interval = setInterval(checkForUpdates, 50); return () =&gt; clearInterval(interval); }, [nodeId, getNode]); return node;
}; export const useRelatedNodes = (nodeId: string) =&gt; { const { getRelatedNodes } = useWorkflowContext(); return useMemo(() =&gt; getRelatedNodes(nodeId), [nodeId, getRelatedNodes]);
}; export const useAllNodeIds = () =&gt; { const { getAllNodeIds } = useWorkflowContext(); const [nodeIds, setNodeIds] = useState(() =&gt; getAllNodeIds()); React.useEffect(() =&gt; { const checkForUpdates = () =&gt; { const currentNodeIds = getAllNodeIds(); setNodeIds(prev =&gt; { if (prev.length !== currentNodeIds.length) return currentNodeIds; if (prev.some((id, index) =&gt; id !== currentNodeIds[index])) return currentNodeIds; return prev; }); }; const interval = setInterval(checkForUpdates, 100); return () =&gt; clearInterval(interval); }, [getAllNodeIds]); return nodeIds;
};
// ✅ 최적화된 FlowEditor
const FlowEditor = () =&gt; { return ( &lt;WorkflowProvider initialNodes={workflowNodeMock}&gt; &lt;FlowEditorContent /&gt; &lt;/WorkflowProvider&gt; );
}; const FlowEditorContent = () =&gt; { const { addNode } = useWorkflowContext(); return ( &lt;div&gt; &lt;button onClick={addNode}&gt;노드 추가&lt;/button&gt; &lt;WorkflowCanvas /&gt; &lt;/div&gt; );
}; // ✅ 최적화된 WorkflowCanvas
const WorkflowCanvas = () =&gt; { // 🎯 노드 ID 목록만 구독 (성능 최적화) const nodeIds = useAllNodeIds(); return ( &lt;div&gt; {nodeIds.map(nodeId =&gt; ( &lt;FlowNode key={nodeId} nodeId={nodeId} // 🚀 ID만 전달! /&gt; ))} &lt;/div&gt; );
}; // ✅ 최적화된 FlowNode
const FlowNode = React.memo(({ nodeId }: { nodeId: string }) =&gt; { // 🎯 선택적 구독 - 해당 노드만 구독 const node = useNodeSelector(nodeId); const relatedNodes = useRelatedNodes(nodeId); const { handleStatusChange } = useWorkflowContext(); // node나 relatedNodes가 변경될 때만 리렌더링! if (!node) return null; console.log(`FlowNode ${nodeId} 렌더링`); // 변경된 노드만 로그 출력 return ( &lt;div className="flow-node"&gt; &lt;h3&gt;{node.title}&lt;/h3&gt; &lt;p&gt;상태: {node.state}&lt;/p&gt; &lt;p&gt;관련 노드 수: {relatedNodes.length}&lt;/p&gt; {node.state === 'do' &amp;&amp; ( &lt;button onClick={() =&gt; handleStatusChange(nodeId, 'complete')}&gt; 완료 &lt;/button&gt; )} &lt;/div&gt; );
});
// 성능 측정 예시
const measureRenderCount = () =&gt; { let renderCount = 0; const FlowNodeWithCounter = ({ nodeId }) =&gt; { renderCount++; console.log(`총 렌더링 횟수: ${renderCount}`); const node = useNodeSelector(nodeId); return &lt;div&gt;{node?.title}&lt;/div&gt;; }; // 결과: // 기존 방식: 노드 1개 변경 → 100개 모두 리렌더링 // 새 방식: 노드 1개 변경 → 1~3개만 리렌더링 (변경된 노드 + 직접 연결된 노드)
}; 복잡한 상태 구조: 여러 컴포넌트가 같은 상태를 공유
빈번한 업데이트: 상태가 자주 변경되는 경우
성능이 중요한 앱: 리렌더링 최적화가 필요한 경우
대량의 데이터: 많은 아이템을 다루는 리스트나 에디터 복잡성 증가: 단순한 상태에는 과도할 수 있음
구독 시스템: 실제 프로덕션에서는 더 정교한 구독 메커니즘 필요
메모리 누수: 구독 해제를 잊지 말 것
초기 구현 비용: 설계와 구현에 더 많은 시간 필요
Zustand, Recoil, Jotai 같은 라이브러리를 왜 사용 안했는가?
전체의 상태관리가 필요한것이 아닌 해당 페이지 내에서만 상태관리가 필요함. 전역변수를 사용하는 justand, Recoil 사용 시 문제가 발생생
// Zustand 예시
const useWorkflowStore = create((set, get) =&gt; ({ nodes: new Map(), updateNode: (nodeId, updates) =&gt; { set(state =&gt; ({ nodes: new Map(state.nodes).set(nodeId, { ...state.nodes.get(nodeId), ...updates }) })); }, // 선택적 구독 getNode: (nodeId) =&gt; get().nodes.get(nodeId),
})); // 컴포넌트에서 사용
const FlowNode = ({ nodeId }) =&gt; { const node = useWorkflowStore(state =&gt; state.getNode(nodeId)); // nodeId에 해당하는 노드가 변경될 때만 리렌더링
};
Context + Selector 패턴은 React의 기본 기능만으로도 강력한 성능 최적화를 가능하게 합니다. 특히 복잡한 상태를 가진 대규모 애플리케이션에서 그 진가를 발휘합니다.핵심은 다음 세 가지입니다:
상태 구조 최적화: Map 기반 저장으로 O(1) 접근
선택적 구독: 필요한 데이터만 구독하여 불필요한 리렌더링 방지
Observer 패턴: 관련 컴포넌트에게만 변경 사항 알림
<a class="internal-link" data-href="posts/100 Resources/103 NewDevelopments/REACT에서 자주 업데이트되는 데이터리스트 관리방식.md" href=".html" target="_self" rel="noopener nofollow">REACT에서 자주 업데이트되는 데이터리스트 관리방식</a>]]></description><link>300-resources/310-개발공부/311-front/react-성능-최적화-usecontext를-이용하여-부분적으로-전역변수-사용으로-불필요한-리렌더링-제거하기.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/React 성능 최적화 useContext를 이용하여 부분적으로 전역변수 사용으로 불필요한 리렌더링 제거하기.md</guid><pubDate>Sun, 21 Dec 2025 10:04:06 GMT</pubDate></item><item><title><![CDATA[React 상태 관리 가이드( JUSTAND )]]></title><description><![CDATA[
상태관리 라이브러리는 왜 필요한가? Prop Drilling: 깊은 컴포넌트에 데이터 전달 시 중간 컴포넌트들을 모두 거쳐야 함
전역 상태 관리 어려움: 여러 컴포넌트가 공유하는 상태 관리가 복잡
상태 변화 추적 곤란: useState로 여기저기서 setState 호출 시 어디서 상태가 변경되었는지 추적 어려움(집중화해서 관리하면 해당 위치에서만 상태가 업데이트 - 집중화, 목적을 명확하게 사용 )
위와 같은 문제로 나는 주로 justand + <a class="internal-link" data-href="posts/100 Resources/103 NewDevelopments/React-query.md" href=".html" target="_self" rel="noopener nofollow">React-query</a>를 사용한다.
react-query로 서버에서 오는 데이터를 관리해서 SSR에서도 데이터를 관리하고
Justand로 클라이언트 상태를 관리한다.
justand는 Redux-devtools을 지원해서 상태 변화를 시간순으로 추적하여 디버깅 편리하다.const useUserStore = create((set) =&gt; ({ user: null, login: (user) =&gt; set({ user, isLoggedIn: true }), logout: (user) =&gt; set({ user, isLoggedIn: false }),
})); 적용 대상: 사용자 정보, 장바구니, 테마, 로그인 상태 등
특징: 여러 페이지에서 공유, 새로고침해도 유지 필요
// 유지를 하기위해서는 persist 옵션을 사용해야한다.
const useStore = create( persist( // 첫 번째 인자: 일반적인 Zustand store 함수 (set, get) =&gt; ({ user: null, cart: [], login: (userData) =&gt; set({ user: userData }), addToCart: (item) =&gt; set((state) =&gt; ({ cart: [...state.cart, item] })), }), // 두 번째 인자: persist 설정 객체 / localsotorage의 app-storage로 저장됨 { name: 'app-storage', // localStorage 키 이름 partialize: (state) =&gt; ({}), // 어떤 상태를 저장할지 storage: createJSONStorage(() =&gt; localStorage), // 저장소 타입 } )
); 전역으로 쓸 요소는 아닌데 현재 페이지에서 사용해야하는 전역변수가 있다. 예를들면 복잡한 Canvas화면에서 동작을 할 때 전체 요소를 중앙에서 관리해야하는 경우가 있다. 해당 케이스를 위해서는 Context API를 사용해서 해당 페이지만의 상태를 관리하는게 좋다.
Atomic Design Pattern에서 복잡한 Organisms이나 templates에서도 사용된다. const CheckoutPageContext = createContext(); function CheckoutPageProvider({ children }) { const [currentStep, setCurrentStep] = useState(1); const [formData, setFormData] = useState({}); return ( &lt;CheckoutPageContext.Provider value={{ currentStep, formData, ... }}&gt; {children} &lt;/CheckoutPageContext.Provider&gt; );
} 적용 대상: 특정 페이지의 폼 데이터, 단계 상태, 모달 상태 등
특징: 해당 페이지에서만 사용, props drilling 방지
서버에서 받아오는 중요데이터는 // ✅ 서버 상태 - TanStack Query/SWR
const { data: user } = useQuery('/api/user'); // ✅ 클라이언트 상태 - Zustand (SSR 안전 패턴)
const useClientStore = create((set) =&gt; ({ theme: null, // 초기값 null isHydrated: false, hydrate: () =&gt; { const savedTheme = localStorage.getItem('theme') || 'light'; set({ theme: savedTheme, isHydrated: true }); },
})); // 컴포넌트에서 안전하게 사용
function Header() { const { theme, isHydrated } = useClientStore(); const currentTheme = isHydrated ? theme : 'light'; // 기본값 제공 return &lt;header className={currentTheme}&gt;...&lt;/header&gt;;
}
핵심: 상태의 범위와 복잡도에 따라 적절한 도구를 선택하고, Next.js에서는 서버/클라이언트 상태를 명확히 구분하여 사용하자!]]></description><link>300-resources/310-개발공부/311-front/react-상태-관리-가이드(-justand-).html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/React 상태 관리 가이드( JUSTAND ).md</guid><pubDate>Sun, 21 Dec 2025 10:03:58 GMT</pubDate></item><item><title><![CDATA[Nextjs SEO 처리]]></title><description><![CDATA[
검색엔진 최적화
대형 검색사이트에서 내가 만든 사이트를 검색하기 쉽게 만들어 노출하기 위한 디지털 마케팅 작업 siteMap : 검색엔진이 사이트 구조를 이해하고 페이지를 인덱싱하도록 돕는 xml파일
robots : 검색엔진이 크롤링할 수 있는 페이지를 지정하는 파일
metadata: 레이아웃 페이지별로 저장하는 metadata 불필요한 크롤링을 방지한다.
=&gt; 비공개 페이지, 중요치 않은 페이지의 검색엔진 크롤링을 막음
User-agent: *
Disallow: /admin/
Disallow: /api/ 서버부하 감소
=&gt; 크롤러가 불필요한 페이지 크롤링을 막음으로서 서버리소스 절약
중복 콘텐츠 방지
=&gt; 동일 콘텐츠 포함하는 페이지는 크롤러에 입력시 seo 패널티를 받을 수 있음. 해당 부분 방지
중요페이지 우선순위 지시
sitemap 위치 제공 색인화 진행
새로운 컨텐츠의 빠른 반영
사이트 구조 명시
# Nextjs 실 서비스 url
NEXT_P_BASE_URL=https://koo-sang-threejs.vercel.app
import { Song } from "@/types/types"; export default async function sitemap() { const baseUrl = process.env.NEXT_P_BASE_URL const response = await fetch(`${baseUrl}/api/songs?page=${1}&amp;limit=${10000}`); const data: Song[] = await response.json(); const songPages = data?.map((song)=&gt;{ return { url: `${baseUrl}/music/detail/${song?.id}`, latestModified: new Date() }; }); return [ { url: baseUrl, lastModified: new Date(), changeFrequency: 'yearly', priority: 1, }, ...songPages ]
}
import { MetadataRoute } from "next";
import { userAgent } from "next/server"; export default function robots(): MetadataRoute.Robots{ return { rules: { userAgent: "*", allow: ["/", "/music"], disallow:[] }, sitemap:`${process.env.NEXT_PUBLIC_API_BASE_URL}/sitemap.xml` }
} 정적 default seo
export const metadata: Metadata = { metadataBase: new URL(process.env.NEXT_PUBLIC_API_BASE_URL!), keywords:["front-end","portfolio","구상모","koosang","KooSang-project"], title: { default:"KooSang-project", template: `%s | KooSang-project` }, description: "side project for KooSang", openGraph:{ description: "구상모의 놀이터입니다. 배운기술을 연마하고 사용하기 위한 사이트 입니다.", images:[''] }
}; 동적 page의 seo
export async function generageMetadata({params}:PageProps){ try{ const song = await fetchSongById(params.musicId); return { openGraph:{ title: song.title, description: song.description, images:[song?.image?.[0]] } } }catch(e){ return { title: "Not Found", description:"The page is not exist" } }
}
tip google console에서 자체적으로 posts 경로를 막고 있다. 아무래도 테스트용으로 많이 쓰는 경로다보니 막은 것으로 추측된다.]]></description><link>300-resources/310-개발공부/311-front/nextjs-seo-처리.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Nextjs SEO 처리.md</guid><pubDate>Sun, 21 Dec 2025 09:13:45 GMT</pubDate></item><item><title><![CDATA[MSW + Jest + Nextjs 설정]]></title><description><![CDATA[
dev 모드에서 mocking한 데이터 출력
npm run test로 __test__ 하위 테스트파일들 테스트 진행 개발환경에서 테스트는 매우 중요하다. 특히 내가 겪었던 오류사항에 대해서 테스트를 적어 다른사람이 같은 실수를 하는 것을 방지 및 코드의 위험성을 낮춰 개발속도를 빠르게 개선할 수 있다. NEXTJS + MSW + JEST 환경에서 테스트 및 개발계의 사용성을 증진시키는 것을 목적으로 작업했다. 기본적으로 testing-library 부분은 user-event만 추가,
jest-environment-jsdom, jest-fixed-jsdom,msw, ts-jest 4개의 라이브러리는 설치해준다. "devDependencies": { "@testing-library/dom": "^10.4.0", "@testing-library/jest-dom": "^6.5.0", "@testing-library/react": "^16.0.1", "@testing-library/user-event": "^14.5.2", "@types/jest": "^29.5.12", "jest-environment-jsdom": "^29.7.0", "jest-fixed-jsdom": "^0.0.3", "msw": "^2.4.3", "ts-jest": "^29.2.5 } msw 는 1과 2 버전이 있는데 2도 이제 많이 안정화됐고 레퍼런스도 쌓여서 과감히 2로 진행하였다
npx msw init public/ --save
<a href=".?query=tag:추가작성필요" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#추가작성필요">#추가작성필요</a> ]]></description><link>300-resources/310-개발공부/311-front/msw-+-jest-+-nextjs-설정.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/MSW + Jest + Nextjs 설정.md</guid><pubDate>Sun, 21 Dec 2025 09:13:34 GMT</pubDate></item><item><title><![CDATA[Meta Tag]]></title><description><![CDATA[
title:
description
keywords
robots
viewport
charSet
openGraph : []
article : [] 기본적으로 검색엔진들은 title, description, keywords // 기본적으로 검색어가 content에 있을 때 효과적으로 노출하기 위한 설정
&lt;meta name="title" content="페이지 제목"&gt;
&lt;meta name="description" content="페이지 설명"&gt;
&lt;meta name="keywords" content="HTML,CSS,JavaScript,웹개발,SEO최적화"&gt; 메타에서 적용한 미리보기 관련 태그들, 설정하면 더 좋은 미리보기를 보여준다
이미 적용된 seo를 더 강화하는 역할을 함.
&lt;head&gt; &lt;meta property="og:title" content="웹사이트 제목"&gt; &lt;meta property="og:description" content="설명"&gt; &lt;meta property="og:image" content="https://koosang-project.com/img.jpg"&gt; &lt;meta property="og:url" content="https://koosang-project.com"&gt; &lt;meta property="og:type" content="website"&gt;
&lt;/head&gt; &lt;head&gt; &lt;meta name="twitter:card" content="summary_large_image"&gt; &lt;meta name="twitter:title" content="나의 멋진 페이지 제목"&gt; &lt;meta name="twitter:description" content="이 페이지는 흥미로운 정보를 제공합니다."&gt; &lt;meta name="twitter:image" content="https://example.com/large-image.jpg"&gt; &lt;meta name="twitter:site" content="@yourusername"&gt;
&lt;/head&gt; //스케일을 강제하고 zoom-in, zoom-out을 불가능하도록 변경
&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"&gt;
//Nextjs에서의 소스 export const viewport: Viewport = { width: "device-width", initialScale: 1, maximumScale: 1, userScalable: false,
}
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; // IE, EDGE 사용자 최신으로 사용하기
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; // 문자 인코딩, 한글을 위한 UTF-8
&lt;link rel="icon" href="favicon.ico" type="image/x-icon"&gt; // 패비콘 설정
&lt;meta name="copyright" content="Copyright 구상모"&gt; //저작권자 명시
&lt;meta http-equiv="refresh" content="5000; url=https://https://refreshpage.com"&gt; // 특정시간(5000초) 이후에 이동시키는 작업
]]></description><link>300-resources/310-개발공부/311-front/meta-tag.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Meta Tag.md</guid><pubDate>Sun, 21 Dec 2025 09:13:28 GMT</pubDate></item><item><title><![CDATA[MDXRemote 테이블 깨짐 문제]]></title><description><![CDATA[nextjs14 에서 렌더링 과정에서 테이블 미렌더링<img alt="직렬화가 되지 않은 테이블" src="800-references/801-image/2025/08/mdxremote-테이블-깨짐-문제-1.png" target="_self">1이런 테이블 직렬화를 위해서는 option으로 remakGfm 옵션을 주면된다.
Next.Config.js 에도 이미 준 상태인데 따로 인지를 하지 못한다. &lt;MDXRemote source={processedSource} options={{ : { remarkPlugins: [remarkGfm], }, }} components={components} /&gt; ]]></description><link>300-resources/310-개발공부/311-front/mdxremote-테이블-깨짐-문제.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/MDXRemote 테이블 깨짐 문제.md</guid><pubDate>Sun, 21 Dec 2025 09:13:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[js 번들 분석 및 최적화하기]]></title><description><![CDATA[JS 번들 분석과 최적화 방법을 알아보세요. 성능 향상과 로딩 속도 개선을 위한 유용한 팁을 제공합니다.]]></description><link>300-resources/310-개발공부/311-front/js-번들-분석-및-최적화하기.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/js 번들 분석 및 최적화하기.md</guid><pubDate>Sun, 21 Dec 2025 09:13:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[JS 기본기능 응용관련]]></title><description><![CDATA[
내가 어떤 기능을 구현할 수 있는지 확인하고 그 구현으로 어떤문제를 풀 수 있는지 빠르게 확인하는 방향으로 접근하기로 했다. 기본적으로 모든 문제는 어떤 배열 or 집합으로 부터 시작한다고 생각한다. 다만 그 배열 혹은 집합 내부가 어떻게 생겼는지가 2차적인 문제라고 생각함. key가 값인 Map하고 비슷하다 추가된 순서가 유지된다
같은 key값 add시 무시 const uniqueNumbers = [...new Set(numbers)]; const mySet = new Set(); mySet.add("값")
mySet.delete("값")
mySet.has("값");
mySet.size // 전체 크기 중요한 것은 단일 key값에 하나의 value만 들어갈 수 있다는 점이다. 추가된 순서가 유지된다
같은 key값 set 시 update const dataMap = new Map(); // i 라는 인덱스에 데이터가 있으면 1증가 없으면 default값으로 1 생성
dataMap.set(i,dataMap.get(i)+1 ?? 1) // true, false 반납
dataMap.has('키') dataMap.delete('키')
dataMap.clear() // value먼저 반환하는거 기억
dataMap.forEach((value, key)=&gt;{console.log(value, key)}) dataMap.keys() // {"키1", "키2", "키3"}
dataMap.values() // {"값1", "값2", "값3"}
dataMap.entries() // {["키1","값1"], ["키2","값2"], ["키3", "값3"]} Array.from(dataMap, ([key,value])=&gt;[key,value*2]) // 이 형태로 Iterator 객체를 Array객체로 바꿈 O(n) 계산하는 내부값들이 전부 리스트 안에 데이터가 있다면 reduce로 로직을 구성
// 배열 초기화
let arr = new Array(5).fill(0); // 어떤 값이 있고 이게 순서대로 축적되는 형식일 때
const list = [{key:1, value:"값"}, {key:2, value:"값2"}]; const result = list.reduce((a,c) =&gt;{ return {key:c.key+a.key, value:c.value}
}) //min, max값의 응용도 처리 가능 -&gt; 여러 항목에 대해서 복잡한 로직으로 판단해야할 때 사용하면 좋을듯
const numberArray = [5, 2, 9, 8, 4, 5];
numberArray.reduce( (a, c) =&gt; { if (a.firstMax &lt; c) { return { firstMax: c, secondMax: a.firstMax }; } else if (a.secondMax &lt; c) { return { firstMax: a.firstMax, secondMax: c }; } return a; }, { firstMax: -Infinity, secondMax: -Infinity }
); 첫 정렬이 되어 있어야함. 그 정렬에 대한 기준으로 이진탐색 가능 기계적으로 구현 가능하도록 암기 필요 // 배열과 target , [start,end] 로 구성된 기본 반복문 구조
// 재귀보단 덜 직관적이나 stack을 덜 먹어서 좋음
// 공간복잡도 O(1)
function binarySearchWhile(arr, target, start, end) { const [minProcessTime, maxProcessTime] = [ Math.min(...times), Math.max(...times), ]; let [left, right] = [minProcessTime, maxProcessTime * n]; while (left &lt;= right) { const mid = Math.floor((left + right) / 2); // 판단과정 재료 만들기 if (판단로직) { answer = mid; right = mid - 1; } else { left = mid + 1; } } return left;
}
]]></description><link>300-resources/310-개발공부/311-front/js-기본기능-응용관련.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/JS 기본기능 응용관련.md</guid><pubDate>Sun, 21 Dec 2025 09:13:11 GMT</pubDate></item><item><title><![CDATA[JS 기본객체별 내장메서드 정리]]></title><description><![CDATA[0.1+0.2 ===0.3 // retrun false // 소수점까지 일치하는 Number 처리
function isEqual(a,b){ return Math.abs(a-b) &lt; Number.EPSIOLON //(가장작은 단위)
} isEqaul(0.1+0.2 , 0.3) // return true Number.MAX_SAFE_INTEGER
Number.MIN_SAFE_INTEGER Number.isInteger(12)
Number.isNaN(NaN) // NaN은 서로 같지 않으므로 비교할 때 반드시 isNaN을 사용 Number.toFixed() // 소수점 아래를 반올림
Number.toPrecision() // 정확도로 몇자리까지 제대로 쓸건지 확인
(23).toString(_) // 문자열로 만드는데 _에따라 진법이 달라짐 Math.PI
Math.abs
Math.round
Math.ceil
Math.floor
Math.sqrt
Math.random
Math.pow
Math.max
Math.min
new Date(0) // 1970 1월 1일 00:00:00 기준 new Date('2025/01/31/10:00:00') // soqnsms Date.parse로 변환 가능한 format Date.now() Date.getFullYear() Date.setFullYear() Date.getMonth()
Date.setMonth() Date.getDate()
Date.setDate() // 요일 0~6
Date.getDay(); today.toString();
today.toISOString();
today.toLocaleString()'ko-KR';
str.length
new String('test'); str.indexOf('or') // 두글자도 가능 return index or -1
str.inclueds('or',startIdx) // return false
str.search(/of/) // 정규식 검사도 가능 str.startsWith
str.endsWith
str.charAt(idx) // 해당 문자열 반환 넘을경우 빈문자열 '' str.substring(startIdx,endIdx) // 음의 인덱스 사용 불가, 음의 인덱스는 slice사용 str.toUpperCase
str.toLowerCase
str.trim // 파생으로 앞 or 뒤만 필요하면 trimStart, trimEnd str.replace(/hello/, '') // 제거용으로 많이 쓰임
'Hello world'.replace('world','&lt;strong&gt;$&amp;&lt;/sctong&gt;') // $&amp;은 찾은 내용 대타 str.repeat(2) // return str+str
str.split(//, _) // const set = new Set([1,2,23,34]]); set.size
set.add(25) // return set chainning 가능
set.has(25) // return true
set.delete(25) // set.clear() set.intersection(anotherSet) // 교집합
set.union(anotherSet) // 합집합
set.difference(anotherSet) // 차집합 new Set([...set].filter((item)=&gt;!anoterSet.has(item))) // anotherSet이 안가진 데이터만 set.isSuperset(anotherSet)
new Map(); new Map([['key1','value1'],['key2','value2']]) map.size // 2
map.set('key3','value3')
map.has("key2") // true
map.get("key2") // value2 map.keys() =&gt; ['key1','key2',"key3"] // 입력됐던 순서가 유지됨 ]]></description><link>300-resources/310-개발공부/311-front/js-기본객체별-내장메서드-정리.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/JS 기본객체별 내장메서드 정리.md</guid><pubDate>Sun, 21 Dec 2025 09:13:05 GMT</pubDate></item><item><title><![CDATA[History API]]></title><description><![CDATA[history API는 브라우저 주소와 세션을 조작할 수 있게 해주는 브라우저 내 api, 웹과 모바일 브라우저에서 사용된다.
쉽게 말하면 history API는 지금껏 지나온 url을 list형태로 저장하는 방식을 채택한다. 이 과정에서 어떻게 새로운 기록을 넣을건지, 대체할건지, 삭제할건지를 조정하여 사용한다.
window.history 객체에서 사용할 수 있는 메서드 back
go
forward
pushState
replaceSate
// 1. 직접적으로 페이지 이동(SPA에서는 쓰지 않음)
window.history.back() // 뒤로가기
window.history.forward() // 뒤로가기
window.history.go(n) // 현재페이지 + n페이지 이동 (n은 +,- 둘다 가능) // 2. 특정 url로 상태를 바꾸는 function, 현재 title은 잘 사용하지 않음.
history.pushState({filter:"category1"}, title , "/blog1") // 3. 현재 history 덮어쓰기
history.replaceState({filter:"category2"}, title, "/blog2")
// 이것을 사용하면 새로 추가하는게 아닌 현재 위치의 기록을 덮어씀. // 위에 정의된 state{filter:~} 형태의 객체는 popState 이벤트시 e.state로 가져오기 가능
window.addEventListener("popstate", (e)=&gt;{ const filter = e.state.filter; if(filter){ applyFilter(filter) }
}) 기본적으로 이동에 대해서 자동으로 pushState, popState이벤트를 적용함. useNavigate, Link로 이동 시 자동으로 pushState로 이동됨.
이동된 화면에서 useLocation을 통해서 history 상태를 쉽게 가져다 사용가능
import { useNavigate, Link } from "react-router-dom"; function MyComponent() { const navigate = useNavigate(); const goToPage1 = () =&gt; { navigate("/page1", {state:{filter:"category1"}}); // 내부적으로 history.pushState 실행됨 }; return ( &lt;div&gt; &lt;button onClick={goToPage1}&gt;Go&lt;/button&gt; &lt;Link to="/page1"&gt;page1가기&lt;/Link&gt; &lt;/div&gt; );
} //
import { useLocation } from "react-router-dom"; function Page1() { const location = useLocation(); console.log(location.state) return ( &lt;div&gt; &lt;div&gt;{location.state?.filter}가 이전화면에서 filtering 한 내용&lt;/div&gt; &lt;/div&gt; );
} 뒤의 옵션에서 state, replace, relative를 줄 수 있음. navigate("/login", { replace: true }); // /curpage =&gt; /settings 로 이동할때
navigate("settings", { relative: "route" }); navigate("../settings", { relative: "path" }); //relative가 "path"면 현재 url기준, router면 현재 라우트 기준, default는 route navigate("pagename", {param1:"value"});
도착한 화면에서는 const {param1} = useRoute().params;
useNavigationState0
navigation.reset() 보통 큰 카테고리는 tab으로 하고 안에 상세 내용으로들어갈수록 stack으로 화면을 쌓는 방식으로 화면레이아웃을 구성한다.
// App.tsx
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createNativeStackNavigator } from '@react-navigation/native-stack'; const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator(); function HomeStack() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name="HomeMain" component={HomeScreen} /&gt; &lt;Stack.Screen name="Detail" component={DetailScreen} /&gt; &lt;/Stack.Navigator&gt; );
} function SettingsStack() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name="SettingsMain" component={SettingsScreen} /&gt; &lt;Stack.Screen name="SubSettings" component={SubSettingsScreen} /&gt; &lt;/Stack.Navigator&gt; );
} export default function App() { return ( &lt;NavigationContainer&gt; &lt;Tab.Navigator&gt; &lt;Tab.Screen name="HomeTab" component={HomeStack} /&gt; &lt;Tab.Screen name="SettingsTab" component={SettingsStack} /&gt; &lt;/Tab.Navigator&gt; &lt;/NavigationContainer&gt; );
}
import { useNavigation } from '@react-navigation/native'; function MyComponent() { const navigation = useNavigation(); return ( &lt;Button title="Go to Detail" onPress={() =&gt; navigation.navigate("Detail", { id: 1 })} /&gt; );
} // 이동한 화면에서는 useRoute를 통해서 이동시 넘겨주었는 state사용가능
import { useRoute, useFocusEffect } from '@react-navigation/native'; function DetailScreen() { const route = useRoute(); const { id } = route.params; // useFocusEffect를 통해 화면에 포커스 될 때 실행되는 로직을 사용가능 useFocusEffect( useCallback(() =&gt; { fetchUserProfile(); }, []) return &lt;Text&gt;Detail for item #{id}&lt;/Text&gt;;
}
해당 기능은 화면에 보여질 때 발생하는 hook이다.
주로 사용하는 경우는 아래와 같다.
화면 진입할 때마다 API를 새로 호출해야할 때
포커스 상태에서만 타이머를 돌리고 싶을 때
뒤로 돌아가기 등을 했을 때도 UI요소를 새로고침하거나 할때 react-navigation의 확장버전
nextjs의 라우팅구조를 따라 사용하여 직관적인 라우팅
import { useRouter, useLocalSearchParams, Link } from 'expo-router'; const router = useRouter();
router.push("/about"); // push stack
router.replace("/login"); // replace stack
router.back(); // go back const { id } = useLocalSearchParams();
console.log(id); // URL에서 추출된 값 (/posts/123 → id = "123") &lt;Link href="/about"&gt;About 페이지로&lt;/Link&gt; // 자동으로 해당 name 에 맞게 라우팅되면서 찾아감
export default function Layout() { return ( &lt;Tabs&gt; &lt;Tabs.Screen name="home" /&gt; &lt;Tabs.Screen name="settings" /&gt; &lt;/Tabs&gt; );
}
]]></description><link>300-resources/310-개발공부/311-front/history-api.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/History API.md</guid><pubDate>Sun, 21 Dec 2025 09:12:59 GMT</pubDate></item><item><title><![CDATA[Electron]]></title><description><![CDATA[Electron을 사용하여 웹 기반 데스크톱 애플리케이션을 쉽게 개발하는 방법을 알아보세요. React Native와 유사한 접근 방식을 제공합니다.]]></description><link>300-resources/310-개발공부/311-front/electron.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Electron.md</guid><pubDate>Sun, 21 Dec 2025 09:12:54 GMT</pubDate></item><item><title><![CDATA[Dom과 이벤트전파]]></title><description><![CDATA[
마크업 언어로 작성된 문서를 프로그래밍 언어가 조작할 수 있도록 하는 객체. html로 작성된 dom요소의 상태, 이벤트 등을 js가 인지할 수 있도록 하여 컨트롤 할 수 있도록 한다. js에서 dom 요소는 document 변수에 담겨서 사용된다.
dom은 tree구조로 이루어져 있어 구조탐색 및 이벤트 처리과정에서 상위, 하위요소로의 접근이 용이하다.
dom요소를 제어하기 위해서는 dom요소를 먼저 선택 정의해야하는데 이걸 selector(선택자)라고 한다. 우리가 보는 html 의 dom 요소를 선택하고 어떤 트리거의 시작점 혹은 끝점으로 만들어서 실 사용자와 상호작용할 수 있다. 이런 선택하는 방식을 <a class="internal-link" data-href="posts/100 Resources/103 NewDevelopments/css선택자.md" href=".html" target="_self" rel="noopener nofollow">css선택자</a>라고 하고 <a class="internal-link" data-href="posts/100 Resources/101 Temp/dev(구)/Front/이벤트위임(Event Delegation).md" href=".html" target="_self" rel="noopener nofollow">이벤트</a>를 통해서 각 dom 요소에 적용된 이벤트를 직접적으로 다룰 수 있다. ex) classname의 클래스를 가진 객체가 클릭하면 doThis를 실행한다. document.querySelector('.className').addEventHandler("click",()=&gt;{ doThis();
}) 하위요소에서 발생한 이벤트가 상위요소로 전파하는 것 onClick 혹은 onDrag등의 html의 attribute(속성)에 정의된 이벤트에 사용할 함수를 넣으면 실행되는 함수의 이벤트 개체로 전달된다.
event.target : 이벤트가 발생한 가장 안쪽 요소
this : 현 이벤트가 발생하는 주체
버블링돼서 발생한 경우 target은 내부요소, this는 외부 부모요소가 될 수 있음.
버블링을 중단하고 싶은 경우 event.stopPropagation() 을 사용함. / 단 이 경우는 조심해서 사용할 것. &lt;!DOCTYPE HTML&gt;
&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" href="example.css"&gt;
&lt;/head&gt; &lt;body&gt; 클릭하면 &lt;code&gt;event.target&lt;/code&gt;과 &lt;code&gt;this&lt;/code&gt;정보를 볼 수 있습니다. &lt;form id="form"&gt;FORM &lt;div&gt;DIV &lt;p id="p"&gt;P&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;script src="script.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
form.onclick = function(event) { event.target.style.backgroundColor = 'yellow'; // chrome needs some time to paint yellow setTimeout(() =&gt; { alert("target = " + event.target.tagName + ", this=" + this.tagName); event.target.style.backgroundColor = '' }, 0);
}; // event가 발생하는 위
p.onclick = function(event) { event.target.style.backgroundColor = 'yellow'; // chrome needs some time to paint yellow setTimeout(() =&gt; { alert("target = " + event.target.tagName + ", this=" + this.tagName); event.target.style.backgroundColor = '' }, 0);
}; 이벤트가 최상위 조상에서 아래로 전파되는 과정.
dom에서 이벤트가 발생하는 과정은
capturing : 이벤트가 하위 요소로 전파
target : 이벤트가 실제 타깃 요소에 전달되는 단계
bubbling : 이벤트가 상위요소로 전파
// 캠처링 단계에서 동작하려면 따로 설정 필요
event.addEventListener(..., {capture: true}) // true 대신 {capture: true} 로 쓰는게 명시적 // capturing을 지울거면 같은 옵션 필요
event.removeEventListener(..., {capture: true}) ]]></description><link>300-resources/310-개발공부/311-front/dom과-이벤트전파.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Dom과 이벤트전파.md</guid><pubDate>Sun, 21 Dec 2025 09:12:47 GMT</pubDate></item><item><title><![CDATA[dependencies 에 내 프로젝트 명 계속 생성됨]]></title><description><![CDATA[
dependencies 부분에 내 프로젝트 명으로 file: 경로로 프로젝트 경로로 참조하고 있었다.
결과는 아래와 같이 에러 npx expo-doctor를 통해 확인해보니 의존성 부분에 문제가 있다고 한다. 확인해보니 아래와 같이 dependencies에 내 프로젝트가 직접적으로 포함되고 있다.
이미지 오류 소실
package.json에서 dependencies로 내 프로젝트 위치가 담겨있음
내 실수다 패키지 링크한걸 까먹어서 링크된 채로 계속 빌드돼서 발생한 문제였다 script실행
npm link # 이 명령어 때문에 내가 정한 하나의 프로젝트가 갑자기 모든 프로젝트롸 링크했다.... npm ls --link --depth=0 # 이 명령어로 전체 링크된 패키기지를 확인하고 npm unlink -g &lt;패키지명&gt; # 해당명령어로 링크를 해제해주면 된다. 이후에는 package-lock.json, node_modules 삭제 및 package.json dependencies에서 제거 후 npm install 하면 정상적으로 실행됐다.
]]></description><link>300-resources/310-개발공부/311-front/dependencies-에-내-프로젝트-명-계속-생성됨.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/dependencies 에 내 프로젝트 명 계속 생성됨.md</guid><pubDate>Sun, 21 Dec 2025 09:12:40 GMT</pubDate></item><item><title><![CDATA[Debounce와 Throttle]]></title><description><![CDATA[
연속적인 이벤트 시 제일 마지막 이벤트 이후 일정시간 이후 함수실행하는 로직
import { useEffect, useState } from "react"; function useDebounce&lt;T&gt;(value: T, delay?: number): T { const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value); useEffect(() =&gt; { const timer = setTimeout(() =&gt; { setDebouncedValue(value); }, delay || 500); return () =&gt; { clearTimeout(timer); }; }, [value, delay]); return debouncedValue;
} export default useDebounce; import { useCallback, useEffect, useRef } from "react"; function useDebouncedCallback&lt;T extends (...args: any[]) =&gt; any&gt;(callback: T, delay: number) { const timerRef = useRef&lt;NodeJS.Timeout | null&gt;(null); const debouncedCallback = useCallback( (...args: Parameters&lt;T&gt;) =&gt; { if (timerRef.current) { clearTimeout(timerRef.current); } timerRef.current = setTimeout(() =&gt; { callback(...args); }, delay); }, [callback, delay] ); useEffect(() =&gt; { return () =&gt; { if (timerRef.current) { clearTimeout(timerRef.current); } }; }, []); return debouncedCallback;
} export default useDebouncedCallback; 연속적인 이벤트 시 제일 처음 이벤트 이후 일정시간 이후 함수를 실행하는 로직
(게임에서의 쿨타임과 비슷한 기능)
import { useCallback, useRef } from "react"; function useThrottle(callback: (...args: any[]) =&gt; void, delay: number) { const throttling = useRef&lt;boolean&gt;(false); const throttledCallback = useCallback((...args: any[]) =&gt; { if (!throttling.current) { callback(...args); throttling.current = true; setTimeout(() =&gt; { throttling.current = false; }, delay); } }, [callback, delay]); return throttledCallback;
} debounce , throttle은 과도한 호출을 막는 것일뿐 중복호출 자체를 막지 못함
debounce가 1초로 설정되어 있고 api 응답이 3초가 걸린다면 1~3초 사이에 발생하는 호출에 대해서는 중복으로 발생할거임.
코드는 각 요청에 대해 고유한 requestId를 부여, requestId가 동일한 요청에 대해 sendRequest 함수를 통해 요청 가능 여부를 판단하므로, 동일 요청이 동시에 실행되지 않도록 제어함.
debounce나 throttle이 단순히 호출 빈도를 조절하는 것과 달리, 실제로 진행 중인 요청이 있을 때 추가 요청을 막아주는 점이 특징
중복로그 에러시 사용자 에러표기 확인이 필요함. const useSingleRequestMutation = ( options ) =&gt; { const { sendRequest } = useSingleRequest(); const requestId = options?.requestId || "defaultRequest"; return useMutation({ ...options, mutationFn: options?.mutationFn onMutate: async ()=&gt;{ const isCallableRequest = sendRequest(requestId); if (!isCallableRequest){ throw new Error("duplicated request") } if(options?.onMutate){ return await options.onMutate(variables); } } //... });
} ]]></description><link>300-resources/310-개발공부/311-front/debounce와-throttle.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Debounce와 Throttle.md</guid><pubDate>Sun, 21 Dec 2025 09:12:35 GMT</pubDate></item><item><title><![CDATA[css선택자]]></title><description><![CDATA[
js에서 dom요소를 특정하기 위한 방식 중 하나. getElementId나 getElementName등 도 있지만 querySelector의 효응성이 높고 같은기능을 수행할 수 있기 때문에 개인적으로는 하나로 통일해서 사용하는 방식을 선호한다.
단, querySelec는 호출시점에서 해당 요소들을 가져오는거기 때문에, 추가 삭제가 된다면 다시 요소를 찾아와야한다.
document는 html문서 전체를 가르킨다.
document.documentElement 는 &lt;html&gt; 요소이다 쿼리셀렉터는 일반적으로 2개로 모든 선택이 가능하다. document.querySelector('선택자') =&gt; Node, undefined
document.querySelectorAll('선택자')=&gt; NodeList
NodeList는 iterator 객체는 맞지만 Array는 아니다 따라서 list로 사용하려면 spread 문법으로 푼다. 단순 반복이면 forEach를 사용하자. [...nodeList]
#선택자 : id선택자
.선택자 : 클래스 선택자
선택자 : 태그선택자
선택자1선택자2 : 같이쓰면 둘다 만족하는 태그
선택자1 선택자2 : 띄어쓰면 선택자1 안에 선택자2
선택자1 &gt; 선택자2 : 선택자1의 직계자식 선택자2
[type="text"] : 속성을 가진 요소
a:hover : a에 마우스 올리면
li:first-child : 첫번째 li요소
p::first-letter : &lt;p&gt;의 첫 글자
]]></description><link>300-resources/310-개발공부/311-front/css선택자.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/css선택자.md</guid><pubDate>Sun, 21 Dec 2025 09:12:30 GMT</pubDate></item><item><title><![CDATA[CSS 기본 텍스트 스타일링]]></title><description><![CDATA[CSS에서 텍스트 스타일링을 위한 기본 속성들을 설명해드리겠습니다:font-size: 16px; /* 절대 크기 */
font-size: 1rem; /* 상대 크기 */
font-size: 100%; /* 부모 요소 기준 */
font-family: Arial, sans-serif; /* 폰트 지정 */
font-weight: 400; /* 100~900, normal, bold 등 */
font-style: normal; /* normal, italic, oblique */
line-height: 1.5; /* 배수 */
line-height: 24px; /* 절대 크기 */
letter-spacing: 0.5px; /* 자간 */
word-spacing: 2px; /* 단어 간격 */
text-align: left; /* left, center, right, justify */
vertical-align: middle; /* top, middle, bottom, baseline */
text-decoration: underline; /* underline, line-through, none */
text-decoration-color: red; /* 장식 색상 */
text-decoration-style: solid; /* solid, dotted, dashed */
text-decoration-thickness: 2px; /* 장식 두께 */
text-transform: uppercase; /* uppercase, lowercase, capitalize */
text-indent: 20px; /* 첫 줄 들여쓰기 */
overflow: hidden; /* 넘치는 텍스트 숨김 */
text-overflow: ellipsis; /* 말줄임표 표시 */
white-space: nowrap; /* 줄바꿈 방지 */ /* 여러 줄 말줄임 */
display: -webkit-box;
-webkit-line-clamp: 2; /* 표시할 줄 수 */
-webkit-box-orient: vertical;
overflow: hidden;
text-shadow: 2px 2px 4px rgba(0,0,0,0.3); /* x y blur color */
user-select: none; /* 텍스트 선택 방지 */
font-smoothing: antialiased; /* 폰트 부드럽게 */
-webkit-font-smoothing: antialiased;
direction: rtl; /* right-to-left */
writing-mode: vertical-rl; /* 세로 쓰기 */
.text-example { font-size: 16px; line-height: 1.5; letter-spacing: 0.5px; font-weight: 500; color: #333; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
} /* 여러 줄 말줄임 */
.multi-line { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.5;
}
이러한 CSS 속성들을 조합하여 원하는 텍스트 스타일을 만들 수 있습니다. 특히 line-height와 overflow 관련 속성들은 텍스트가 잘리지 않도록 주의해서 사용해야 합니다.]]></description><link>300-resources/310-개발공부/311-front/css-기본-텍스트-스타일링.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/CSS 기본 텍스트 스타일링.md</guid><pubDate>Sun, 21 Dec 2025 09:12:23 GMT</pubDate></item><item><title><![CDATA[CSR · SSG · ISR · SSR 구분]]></title><description><![CDATA[CSR, SSG, ISR, SSR의 차이점과 각각의 장단점을 비교하여 SEO 최적화 전략을 제시합니다.]]></description><link>300-resources/310-개발공부/311-front/csr-·-ssg-·-isr-·-ssr-구분.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/CSR · SSG · ISR · SSR 구분.md</guid><pubDate>Sun, 21 Dec 2025 09:12:16 GMT</pubDate></item><item><title><![CDATA[Console 로그 관련한 내용]]></title><description><![CDATA[console.log();
console.error();
console.warn();
“public/image/Pasted image 20250205214550.png” could not be found.1function outerFn(){ function innerFn(){ console.trace() } innerFn();
}
outerFn();
“public/image/Pasted image 20250205214614.png” could not be found.1console.time("인덱스1"); console.timeLog("인덱스1"); // console.time으로부터 시간 ms기준 console.timeEnd("인덱스1"); // console.time으로부터 시간/ 더이상 집계 안함
“public/image/Pasted image 20250205214627.png” could not be found.1console.assert( true!=false, "출력 true")
console.assert( true==false, "출력 false")
“public/image/Pasted image 20250205214643.png” could not be found.1
여러 배열을 담은 값을 출력할 때 유용
console.table([{key:1,value:"예시값1"},{key:2,value:"예시값2"},{key:3,value:"예시값3"}])
“public/image/Pasted image 20250205214658.png” could not be found.1%c 삽입 및 두번째 인자 스타일 지정으로 시각적으로 로그를 강조할 수 있다.// %c
console.log("%c원래콘솔로그", "color:yellow;") “public/image/Pasted image 20250205214717.png” could not be found.1console.group("그룹명칭") console.group("Inner Group1")
console.log("그룹내 아이템")
console.log("그룹내 아이템")
console.log("그룹내 아이템")
console.groupEnd(); console.groupEnd(); “public/image/Pasted image 20250205214749.png” could not be found.1
요새는 chrome에서는 log나 dir
console.dir({key:1, value:"예시값1"}) Run“public/image/Pasted image 20250205214805.png” could not be found.1
다양한 프레임워크에서는 환경설정에 따라서 일부를 제외한 console.log를 제외할 수 있다.
다음과 같이 설정하면 exclude 에서 설정한 내용을 제외한 나머지 로그를 제외할 수 있다.
const nextConfig = { swcMinify:true, compiler:{ removeConsole: process.env.NODE_ENV === 'production' &amp;&amp; { exclude: ['error', 'warn'] } },
};
Run]]></description><link>300-resources/310-개발공부/311-front/console-로그-관련한-내용.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Console 로그 관련한 내용.md</guid><pubDate>Sun, 21 Dec 2025 09:12:09 GMT</pubDate></item><item><title><![CDATA[Code Splitting]]></title><description><![CDATA[Next.js에서 코드 스플리팅을 통해 초기 번들 크기를 줄이고 체감 성능을 개선하는 방법을 알아보세요.]]></description><link>300-resources/310-개발공부/311-front/code-splitting.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/Code Splitting.md</guid><pubDate>Sun, 21 Dec 2025 09:12:03 GMT</pubDate></item><item><title><![CDATA[API 설계 원칙 가이드]]></title><description><![CDATA[API 설계 원칙 가이드를 사전에 ai 에게 전달하여 모든 원칙을 고려한 개발을 할 수 있도록 하자]]></description><link>300-resources/310-개발공부/311-front/api-설계-원칙-가이드.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/API 설계 원칙 가이드.md</guid><pubDate>Sun, 21 Dec 2025 09:11:58 GMT</pubDate></item><item><title><![CDATA[한 화면에서 일부 내용만 좌우 스크롤]]></title><description><![CDATA[한 화면에서 전체적인 문서는 화면에 대해서 flex 하게 움직여야하고 일부 컨텐츠가 좌우로 스크롤이 돼야하는 상황이 있다.<img src="800-references/801-image/2025/08/한-화면에서-일부-내용만-좌우-스크롤-1.png" target="_self">1
파란 부분은 화면 flex에 의해 이동, 빨간 부분은 아래 code 부분이며 좌우 스크롤이 생겨야함.
&lt;div classname="flex flex-1 flex-col gap-20 p-5 md:ml-56"&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;해당내용은 전체적으로 화면에 맞춰 flex하게 진행&lt;/p&gt; &lt;br/&gt; &lt;pre style="overflow-x:scroll"&gt; &lt;code style="white-space:pre"&gt; 코드의 형태는 화면이 줄어들어도 동일해야하므로 좌우 스크롤 &lt;/code&gt; &lt;/pre&gt;
&lt;/div&gt;
우선 해당 화면 자체 최상위 객체는 flex, flex-direction: column 이고 그 안에 요소들이 들어있는 상황이다.overflow 는 자식요소의 실제너비가 부모의 너비보다 클 때만 스크롤이 생긴다. 하지만 min-width가 기본값 auto면 자식너비를 허용하게 된다. 그래서 줄바꿈 없이 부모요소가 확장된다.이 상황에서는 code 태그는 wite-space:pre 상태로 화면에 관계 없이 너비를 유지하게 되면서 전체 화면에서 스크롤이 생겨버린다. 브라우저의 경우 좌우로 스크롤을 하겠지만 모바일하고 같이 쓰는 환경에서는 해당 방식은 view 자체에 스크롤이 생겨 문제가 발생한다.overflow를 적용하기 위해서는 width요소가 상위요소에 적용돼야하는데 위와같이 아무것도 없으면 width가 적용 안돼서 발생한 문제이다.
상단에 min-width 요소를 적용하여 너비를 지정하여 overflow가 동작하도록 한다.&lt;div classname="flex flex-1 flex-col gap-20 p-5 md:ml-56 min-w-[0px]" &gt;
]]></description><link>300-resources/310-개발공부/311-front/한-화면에서-일부-내용만-좌우-스크롤.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/한 화면에서 일부 내용만 좌우 스크롤.md</guid><pubDate>Sun, 21 Dec 2025 09:11:48 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[왜 yarn과 pnpm을 사용하는가]]></title><description><![CDATA[npm은 Node.js와 함께 기본 제공되는 패키지 매니저입니다. 그러나 많은 개발자들이 Yarn이나 pnpm을 선택하는 이유는 성능, 의존성 관리, 캐싱 및 워크스페이스 지원 등의 측면에서 몇 가지 강점을 제공하기 때문입니다.
npm: 초기 버전은 패키지를 순차적으로 설치하여 느렸으나, 최신 버전에서는 병렬 설치 기능이 도입되어 개선됨.
여전히 프로젝트별로 node_modules에 설치하므로, 동일 패키지가 여러 프로젝트에서 중복될 수 있음. Yarn: 패키지들을 병렬로 설치하여 전체 설치 시간이 빠름.
강력한 글로벌 캐싱 메커니즘으로 이미 다운로드된 패키지를 빠르게 재사용함. pnpm: 콘텐츠 기반 저장소(Content-addressable storage)를 사용해, 동일한 패키지를 전역 캐시에 저장 후, 프로젝트별 node_modules에 심볼릭 링크 방식으로 연결.
이 방식은 설치 속도를 극대화하고 디스크 공간도 절약함. npm: 한 번 다운로드된 패키지는 글로벌 캐시(보통 ~/.npm)에 저장되어 동일 버전의 패키지를 재설치할 때 재사용됨.
하지만, 최종적으로는 각 프로젝트 내의 node_modules 폴더에 설치됩니다. Yarn: 전역 캐시(예: ~/.cache/yarn)에 패키지를 저장하고, 콘텐츠 기반 해싱을 통해 같은 패키지 버전을 여러 프로젝트에서 공유합니다.
이를 통해 네트워크 요청을 줄이고 설치 속도를 높일 수 있습니다. pnpm: 전역 저장소에 패키지를 저장한 후, 프로젝트의 node_modules에는 해당 패키지에 대한 심볼릭 링크를 생성합니다.
이 방식은 디스크 공간을 효율적으로 사용하면서, 동일 패키지를 여러 번 다운로드하지 않아 빠른 설치가 가능합니다. npm: package-lock.json 파일을 사용하여 의존성 버전을 고정합니다.
npm v7부터 워크스페이스 기능을 지원하여 모노레포 관리가 가능해졌습니다. Yarn: yarn.lock 파일을 사용해 결정론적(Deterministic) 의존성 관리를 제공, 모든 환경에서 동일한 설치 결과를 보장합니다.
초기부터 워크스페이스를 지원하여, 여러 패키지를 포함한 대규모 프로젝트에서 인기가 높습니다. pnpm: pnpm 또한 lock 파일과 강력한 워크스페이스 지원을 제공하며, 중복 설치 없이 패키지를 공유함으로써 효율적인 프로젝트 관리를 돕습니다. 빠른 설치와 효율성:
Yarn과 pnpm은 병렬 설치와 강력한 글로벌 캐시 메커니즘 덕분에 npm보다 훨씬 빠르게 의존성을 설치할 수 있습니다.
일관된 의존성 관리:
결정론적인 lock 파일(yarn.lock 또는 pnpm의 lock 파일)을 사용하여, 협업 환경에서 모든 개발자가 동일한 패키지 트리를 사용할 수 있습니다.
워크스페이스와 모노레포 지원:
특히 Yarn과 pnpm은 대규모 프로젝트나 모노레포에서 효율적인 의존성 관리와 디스크 공간 절약 측면에서 강점을 보입니다.
이러한 요소들 때문에 많은 개발자들이 기본 npm 대신 Yarn이나 pnpm을 선택하여 더 빠르고 일관된 개발 환경을 구축하고 있습니다.]]></description><link>300-resources/310-개발공부/311-front/왜-yarn과-pnpm을-사용하는가.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/왜 yarn과 pnpm을 사용하는가.md</guid><pubDate>Sun, 21 Dec 2025 09:11:38 GMT</pubDate></item><item><title><![CDATA[멀티 스레딩]]></title><description><![CDATA[
자바스크립트는 싱글스레드 언어이다. 비동기 처리를 통해서 멀티스레드처럼 할 수 있지만 CPU 연산이 무거운 작업에서는 부적합하다. 이러한 부분을 보완하기 위해서 따로 객체를 만든 것이 Worker이다.
import { useState, useEffect } from "react";
import { createWorker } from "./workerSetup"; function App() { const [result, setResult] = useState&lt;number | null&gt;(null); const [loading, setLoading] = useState(false); const startWorker = () =&gt; { const worker = createWorker(); setLoading(true); // 워커에게 작업 요청 (예: 피보나치 40번째) worker.postMessage(40); // 워커로부터 결과 수신 worker.onmessage = (e) =&gt; { setResult(e.data); setLoading(false); worker.terminate(); // 작업 끝나면 워커 종료 }; }; return ( &lt;div&gt; &lt;h1&gt;React + Web Worker 예제&lt;/h1&gt; &lt;button onClick={startWorker}&gt;계산 시작 (피보나치 40)&lt;/button&gt; {loading ? &lt;p&gt;계산 중...&lt;/p&gt; : &lt;p&gt;결과: {result}&lt;/p&gt;} &lt;/div&gt; );
} export default App; // workerSetup.ts
export const createWorker = () =&gt; { return new Worker(new URL("./worker.ts", import.meta.url), { type: "module", });
};
]]></description><link>300-resources/310-개발공부/311-front/멀티-스레딩.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/멀티 스레딩.md</guid><pubDate>Sun, 21 Dec 2025 09:11:25 GMT</pubDate></item><item><title><![CDATA[디버그로 감싸기]]></title><description><![CDATA[
중요함수에서 dev에서는 log를 찍고 prod 환경에서는 로그를 안찍을 수 있게하는 function 이후 해당 결과를 주기적으로 js객체에 저장해 주기적으로 서버를 보내면 front 단의 log도 서버에서 수집 가능하다.
HOC 로 로그를 출력하는 부분을 밖으로 뺀다 .
작성이후에는 꼭 PRODUCT 레벨에서는 콘솔을 찍지 않도록 해야한다. export const wrapWithDebug = &lt;T extends (...args: any[]) =&gt; any&gt;( fn: T, functionName?: string, enableLogging: boolean = process.env.API_DOC_ENV !== "prod" //실제 운영환경에서는 result.finally 필요없음
): T =&gt; { return ((...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; { const name = functionName || fn.name || "anonymousFunction"; console.debug(`${name} start`); const result = fn(...args); if (result instanceof Promise &amp;&amp; enableLogging) { return result.finally(() =&gt; console.debug(`${name} end`)) as ReturnType&lt;T&gt;; } console.debug(`${name} end`); return result; }) as T;
};
]]></description><link>300-resources/310-개발공부/311-front/디버그로-감싸기.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/디버그로 감싸기.md</guid><pubDate>Sun, 21 Dec 2025 09:11:17 GMT</pubDate></item><item><title><![CDATA[다국어 설정 변경작업]]></title><description><![CDATA[다국적 기업의 웹페이지는 여러 언어로 되어 있다. 한개의 언어를 고정으로 단순하게 string을 넣고 있다면 다른 언어를 지원할 때 같은 페이지를 또 만들어야하는 문제가 발생한다. 이 문제를 해결하기 위해 다국어 지원을 위한 라이브러리가 있다.
i18n : 일반 react 프로젝트
next-intl : nextjs 프로젝트
위와같은 라이브러리로 지원된다. 위 라이브러리의 중 Nextjs 의 다국어 프로젝트 설정을 알아보자
다국어 모듈을 적용하기 해서 플러그인을 선 적용해준다.
const createNextIntlPlugin = require('next-intl/plugin');
const withNextIntl = createNextIntlPlugin();
/** @type {import('next').NextConfig} */ const nextConfig = { // 기존 설정들 생략...
}; module.exports = withNextIntl(nextConfig); 어떤 설정을 가져올지 정할 수 있다. cookie 및 header에서 설정이 가능하다, 가장 간단한 방법은 경로로 한번 감싸는 것이다. origin/ko,/~ origin/en/~ 같이 변경하면 좋지만 내 블로그 글들은 어차피 다 한글이기 때문에 연습삼아 적용한 것이고 url까지 나누진 않도록 하겠다.
import {getRequestConfig} from 'next-intl/server';
import {hasLocale} from 'next-intl';
import {routing} from './routing'; // messages import (정적 import)
import ko_main_menu from './messages/ko/main-menu.json';
import en_main_menu from './messages/en/main-menu.json';
import ko_note_edit from './messages/ko/note-edit.json';
import en_note_edit from './messages/en/note-edit.json'; // messages 객체로 통합
const messages: Record&lt;string, Record&lt;string, any&gt;&gt; = { ko: { main_menu: ko_main_menu, note_edit: ko_note_edit, }, en: { main_menu: en_main_menu, note_edit: en_note_edit, },
}; export default getRequestConfig(async (param) =&gt; { // Typically corresponds to the `[locale]` segment const requested = await param.requestLocale; const locale = hasLocale(routing.locales, requested) ? requested : routing.defaultLocale; return { locale, messages: messages[locale] || messages[routing.defaultLocale], };
}); Link나 redirect 같은 부분에서 locale 을 사용해서 움직일 수 있도록 하기 위해서 next-intl에서 제공하는 Link, redirect를 사용한다.
import {createNavigation} from 'next-intl/navigation';
import {routing} from './routing'; // Lightweight wrappers around Next.js' navigation
// APIs that consider the routing configuration
export const {Link, redirect, usePathname, useRouter, getPathname} = createNavigation(routing);
import { useTranslations } from 'next-intl';
import { Link } from '@/i18n/navigation';
import { MenuItem } from '@/types/menu';
import { DrawerClose } from './ui/drawer'; export function SidebarMenu({ menu }: { menu: MenuItem[] }) { const t = useTranslations('main_menu'); return ( &lt;ul className="flex flex-col gap-2 p-4"&gt; {menu.map((item) =&gt; ( &lt;li key={item.href}&gt; &lt;DrawerClose asChild&gt; &lt;Link href={item.href} className="block rounded px-3 py-2 hover:bg-gray-200 dark:hover:bg-gray-700" &gt; {item.icon} {t(item.labelKey)} &lt;/Link&gt; &lt;/DrawerClose&gt; {item.children &amp;&amp; item.children.length &gt; 0 &amp;&amp; ( &lt;SidebarMenu menu={item.children} /&gt; )} &lt;/li&gt; ))} &lt;/ul&gt; );
}
{ "title": "메인 메뉴", "dashboard": "대시보드", "blog": "블로그", "game": "게임", "note": "노트", "rag": "RAG", "about": "소개", "blogResources": "코딩자료", "blogTest": "test", "boardgame": "보드게임", "mincraft": "미니크래프트", "services": "서비스", "contact": "연락처", "sign-in": "로그인", "sign-up": "회원가입"
}
next-intl의 Link는 serverComponent에서 사용시 asChild가 적용되지 않는 문제가 있을 수 있다.// 작동안함.
import { Link } from '@/i18n/navigation'; &lt;Button asChild&gt; &lt;Link href="/"&gt; {t('sign-in')} &lt;/Link&gt;
&lt;/Button&gt; scadn ui 에서는 다음과 같이 button class 에 스타일을 적용해서 같은 스타일을 적용할 수 있다.
&lt;Link href="/sign-up" className={buttonVariants({ variant: 'default', size: 'sm' })}&gt; {t('sign-up')}
&lt;/Link&gt; ]]></description><link>300-resources/310-개발공부/311-front/다국어-설정-변경작업.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/다국어 설정 변경작업.md</guid><pubDate>Sun, 21 Dec 2025 09:11:09 GMT</pubDate></item><item><title><![CDATA[프로젝트 중요 개발문서]]></title><description><![CDATA[이 문서는 프로젝트 내에서 사용되는 고유한 용어들을 명확히 정의하는 사전 역할을 합니다. 동영상은 특히 팀원 간의 소통 오류를 방지하는 데 이 문서가 필수적이라고 설명합니다.
소통 오류 방지: 기획자, 퍼블리셔, 개발자 등 각기 다른 직군에 있는 팀원들은 같은 용어에 대해 다른 의미를 부여할 수 있습니다. 예를 들어, "프론트엔드"가 고객 대상(B2C)을 의미할 수도 있고, 직원 대상(B2E)을 의미할 수도 있습니다. 이러한 혼란을 막기 위해 용어사전을 통해 용어를 통일하는 것이 중요합니다.
비생산적인 논쟁 방지: 용어에 대한 명확한 정의가 없으면 팀원 간에 불필요하고 비생산적인 논쟁이 발생할 수 있습니다. 용어사전은 이러한 시간 낭비를 막고, 본질적인 문제 해결에 집중할 수 있게 돕습니다.
이 문서는 프로젝트의 전반적인 기술적 규칙과 표준을 명시합니다. 코드가 일관성을 갖도록 하여 개발 효율성을 높이는 것이 목적입니다.
코드 일관성: 이 문서에는 클래스명에 PascalCase를, 변수명에 camelCase를 사용하는 등의 명명 규칙이 포함됩니다. 또한, SQL 쿼리 작성 규칙과 같은 코딩 표준도 명시하여 모든 개발자가 통일된 방식으로 코드를 작성하게 합니다.
유지보수 용이성: 모든 코드가 일관된 규칙에 따라 작성되면, 새로운 팀원이 프로젝트에 합류하거나 기존 코드를 수정할 때 훨씬 수월해집니다. 이 문서는 마치 코딩을 위한 '헌법'과 같아서, 개발자들이 스스로 참고할 수 있는 지침이 됩니다.
네, 맞습니다. 표준 개발 정의서는 단일 문서가 아니라 여러 문서를 아우르는 광범위한 개념입니다. 동영상에서 언급된 '표준 개발 정의서'는 프로젝트의 코딩 표준이나 기술적 규칙을 포괄적으로 일컫는 용어로 이해하는 것이 좋습니다.실제 프로젝트에서는 말씀하신 것처럼 코딩 스타일 가이드, 개발 스펙, 라이브러리 사용 방식, 심지어는 파일 및 디렉토리 구조까지도 문서화하여 표준을 만듭니다. 이러한 문서들은 하나로 통합되기보다는 각자의 목적에 맞게 분리되어 관리되는 경우가 많습니다.이 문서는 개발팀이 무엇을 만들 것인지에 대한 청사진을 제시하는 핵심 문서입니다. 개발자나 디자이너의 관점보다는 비즈니스와 사용자 관점에서 제품의 목표와 기능, 그리고 '왜' 이 기능이 필요한지를 설명하는 데 중점을 둡니다.
제품의 비전과 목표: 이 제품(또는 기능)을 통해 어떤 문제를 해결하고 어떤 목표를 달성할 것인지 명시합니다. (예: "사용자 이탈률 감소", "신규 가입자 수 증대")
사용자 페르소나: 제품을 사용할 대표적인 사용자의 특징과 행동을 상세히 기술하여, 팀원들이 사용자를 명확히 이해하도록 돕습니다.
기능 목록: 개발해야 할 기능들을 목록으로 정리하고, 각 기능의 우선순위를 정합니다.
사용자 시나리오: 사용자가 제품을 어떻게 이용하게 될지 스토리 형태로 풀어냅니다. (예: "로그인한 사용자가 마이페이지에서 주문 내역을 확인한다.")
성공 지표: 프로젝트의 성공 여부를 측정할 수 있는 지표(KPI)를 정의합니다. (예: "특정 기능의 주간 사용률 10% 달성")
나는 바이브 코딩을 하려고 하는데 미리 LLM이 이해하기 쉽도록 내 프로젝트에 대한 사항을 cursor rule로 정의하려고 해. 각각의 문서를 만든다고 할 때 종류가 용어사전 코딩컨벤션 개발스펙 기술스택 및 라이브러리 가이드라인 파일 및 디렉토리 구조 규칙 ]]></description><link>100-projects/커서-룰관련-개편/프로젝트-중요-개발문서.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/프로젝트 중요 개발문서.md</guid><pubDate>Sun, 21 Dec 2025 09:10:36 GMT</pubDate></item><item><title><![CDATA[관심사의 분리 원칙(Seperation Of Concern)]]></title><description><![CDATA[<a class="internal-link data-link-icon data-link-icon-after data-link-text" data-href="300 Resources/310 개발공부/311 FRONT/관심사의 분리 원칙(Seperation Of Concern).md" href="300-resources/310-개발공부/311-front/관심사의-분리-원칙(seperation-of-concern).html" target="_self" rel="noopener nofollow" data-link-path="300 Resources/310 개발공부/311 FRONT/관심사의 분리 원칙(Seperation Of Concern).md" style="--data-link-tags: #activity/best-practice #tech/frontend/react; --data-link-path: 300 Resources/310 개발공부/311 FRONT/관심사의 분리 원칙(Seperation Of Concern).md;" data-link-tags="#activity/best-practice #tech/frontend/react">관심사의 분리 원칙(Seperation Of Concern)</a>코드를 유지보수함에 있어서 파악할 수 있는 단위에 한가지의 업무성격만을 유지하도록 하는 방식코드가 단위별로 하나의 관심사에만 충실하게 만드는 것.
코드 파악을 위해 읽어야 하는 코드의 단위가 적음
수정 시 신경 써야 할 코드 수가 적어짐
낮은 결합도와 높은 응집도로 수정 시 변경점을 줄일 수 있고 연관 있는 코드가 모여 있음
가장 대표적인 예시로 VIEW와 BUSINESS LOGIC 간의 분리를 들 수 있음.
VIEW 부분: BUSINESS LOGIC으로부터 데이터를 받아서 해당 데이터를 표시하는 역할만 수행
VIEW MODEL: 해당 데이터에 대한 로직 및 관리를 맡음
하나의 컴포넌트에서 같이 실행되지 않는 코드들은 따로 분리해서 사용function ConditionComp(){ const condition = useCustomHook() === true; useEffect(()=&gt;{ if(condition){ return; } doWhenConditionTrue(); }, [condition]) return condition ? ( &lt;Text&gt;true&lt;/Text&gt; ) : ( &lt;Text&gt;false&lt;/Text&gt; )
} 각 컴포넌트가 실행되는 코드에 대한 내용들만 가지고 있다.
function ConditionComp(){ const condition = useCustomHook() === true; return condition ? &lt;TrueComponent/&gt; : &lt;FalseComponent/&gt;
} function TrueComponent(){ useEffect(()=&gt;{ doWhenConditionTrue(); }, [condition]) return &lt;Text&gt;true&lt;/Text&gt;
} function FalseComponent(){ return &lt;Text&gt;false&lt;/Text&gt;
} 어던 로직이 독립적으로 실행될 때 그 로직과 결과를 사용하는 컴포넌트와 같이 사용하게 된다면 분리하는게 좋음
function ProcessAssembleComp(){ // 사전체크로직 useComplexCheck({ onChecked: (state)=&gt;{ if(state==="Checking"){ doProcess(); } } }) // processA ..... // processB ..... return &lt;&gt;{최종 결과}&lt;/&gt; // } mobile인지 아니면 web인지 판단해서 Mobile의 경우 MobileComponent를 보여주고 아니면 WebComp를 보여주는 방식
사실 mobile,web구분은 서버에서 userAgent에서 파악해서 사용하므로 Wrapper로 로직을 분리해서 사용하는거에 중점으로 확인import dynamic from 'next/dynamic';
import MobileComp from '@/components/MobileComp';
import WebComp from '@/components/WebComp'; const DeviceWrapper = dynamic(() =&gt; import('@/components/DeviceWrapper'), { ssr: false }); export default function Page() { return ( &lt;main&gt; &lt;DeviceWrapper MobileComponent={&lt;MobileComp /&gt;} WebComponent={&lt;WebComp /&gt;} /&gt; &lt;/main&gt; );
} // components/DeviceWrapper.tsx
'use client'; import { useEffect, useState } from 'react'; type Props = { MobileComponent: React.ReactNode; WebComponent: React.ReactNode;
}; export default function DeviceWrapper({ MobileComponent, WebComponent }: Props) { const [isMobile, setIsMobile] = useState&lt;boolean | null&gt;(null); useEffect(() =&gt; { // 사용자 에이전트를 기반으로 환경 파악 (더 정교하게 하려면 라이브러리 사용 가능) const userAgent = navigator.userAgent.toLowerCase(); const mobile = /iphone|android|ipad|mobile/.test(userAgent); setIsMobile(mobile); }, []); if (isMobile === null) return null; // 로딩 중 처리 return isMobile ? &lt;&gt;{MobileComponent}&lt;/&gt; : &lt;&gt;{WebComponent}&lt;/&gt;;
} 하나의 커스텀 hook 에서는 한 관심사에 대한 내용만 참고하도록 한다.
function useUser(){ //...
} function useTheme(){ //...
} function useSidebar(){ //...
} function Header() { const user = useUser(); // 로그인 사용자만 추적 const { open, setOpen } = useSidebar(); // 사이드바 상태만 관리 return ( &lt;div&gt; &lt;span&gt;{user.name}&lt;/span&gt; &lt;button onClick={() =&gt; setOpen(!open)}&gt;Toggle Sidebar&lt;/button&gt; &lt;/div&gt; );
}
]]></description><link>300-resources/310-개발공부/311-front/관심사의-분리-원칙(seperation-of-concern).html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/관심사의 분리 원칙(Seperation Of Concern).md</guid><pubDate>Sun, 21 Dec 2025 09:08:08 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[---tags:
activity/documentation
activity/productivity
tool/obsidian
id: rEH7UT5D9E3iLg0
title: koosang
description: ""
socialImage: 20251218140123XXvP-index.png
domains: ""
created: 2025-12-18 23:01:49
updated: 2025-12-18 23:03:49
CODE:
Express
publish: true
이 블로그는 외부에 나를 알리기 위한 용도이다.나는 obsidian을 좋아한다. md파일로 내가 데이터의 근원을 들고 있으며 로컬에서 데이터 활용, 데이터끼리의 연동, 오픈된 plugin으로 이 노트앱만한 건 없다고 생각한다. LLM이 아무리 성장해도 나에대한 많은 기반 데이터를 기반으로 하고 이를 위해서는 나의 데이터를 쌓는 것이 중요하다.AI 서비스를 만드는 사람들은 공감할 것이다. 무엇을 만들던지간에 만드는 대상에 대한 도메인 지식의 POOL이 필요하다. 나는 옵시디언이 나 라는 POOL의 지식을 저장할 수 있다고 생각한다.다만 vault, 제2의 뇌와 같이 개인용 메모앱이고 외부로의 공유는 제한적인 형태이다. 그렇기에 나의 생각, 흔적을 남에게 보여줄 때는 제한이 될 수 밖에 없다.예전에는 방향성이 하나에 대한 스페셜리스트라고 생각했다. AI시대가 도래하고 보니 하나에 대해서 깊게 생각하고 더 나은 답을 도출하는 것은 AI가 더 잘했다. 나는 이 상황에서 내가 무엇을 해야하는지 고민하게 됐다.
결론은 다 하면 됐다. 그리고 특정 시점, 나의 재능을 폭발시켜야했다. 대부분의 일반인은 못하지만 나는 할 수 있는 시점. 그 시점이 나에게 유일한 기회일 것이다.주식에서 좋은 주식을 갖고 있는게 중요한가? 아니다. 좋은 주식을 오르기 전에 갖는 것이 중요하다. 내가 AI보다 못났다고 하더라도 한순간은 나의 생산성이 폭발하는 시기 그 시기가 얼마 남지 않았다고 생각한다.나는 오케스트라가 된다.<img src="800-references/801-image/2025/12/20251218140123xxvp-index.png" target="_self">1<br><img alt="Drawing 2025-12-17 00.54.00.excalidraw" src="800-references/802-excalidraw/drawing-2025-12-17-00.54.00.excalidraw.svg" target="_self">1]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Sun, 21 Dec 2025 09:07:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01 TypeScript 기초관련]]></title><description><![CDATA[타입 기본관련]]></description><link>300-resources/310-개발공부/311-front/01-typescript-기초관련.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/01 TypeScript 기초관련.md</guid><pubDate>Sat, 20 Dec 2025 18:48:17 GMT</pubDate></item><item><title><![CDATA[01 블로그 개편하기]]></title><description><![CDATA[
나의 가치를 증명할 수 있게 옵시디언을 외부로 공개할 수 있는 수단이 필요했음.
나의 가치를 외부로 전달하기 힘들다는 문제가 발생하였음.
AI시대가 도래하면서 생산성이 극도로 상승하게 됐음. 하지만 AI가 아무리 발전하더라도 사람이 개입해서 수정해야하는 부분이 있고, AI 자체로도 부족한 부분이 계속 나오고 있음.
사람들이 SPEC DRIVEN DEVELOP 이라면서 SDD를 가져와서 하고 있음. 이는 표준적으로 학습된 LLM 에게 사전 지식으로 책을 한권 주면서 일을 시키는 것과 똑같음. 이런 책들을 잘 전달하기 위해 MCP, CLAUDE SKILL등이 나왔고, Open-spec, spec-kit 등이 나오면서 변화에 대한 내용을 저장하기도 했음.
어차피 주변 내용은 이렇게 누군가가 갖다 준다면, 내가 지금 해야할건 무엇인지 고민을 해봐야함.
내가 가장 잘 아는 환경에서 발생한 문제를 기록하고 이를 사용해야하는 상황임.
즉, 한번 질문하면 그걸 어디다가 적어두고 잘 질문하는 신입 개발자가 돼야하는 상황임 그래서 옵시디언을 사용했음.
하지만 옵시디언은 메모앱 성격이 강하기에 외부로 공유하는데 취약함. 이를 극복하기 위해 블로그를 obsidian 용으로 개편하기로 함.블로그를 공개하는건 부가적인 목표임. 시간공수를 최소화할 것이를 위해 다음의 기능들이 동작해야함
1. obsidian link
2. obsidian embeding
3. excalidraw 임베딩
올리는 내용의 선택이 가능해야하는 문제
]]></description><link>100-projects/101-지식관리-pipelin만들기/01-블로그-개편하기.html</link><guid isPermaLink="false">100 Projects/101 지식관리 pipelin만들기/01 블로그 개편하기.md</guid><pubDate>Sat, 20 Dec 2025 17:32:33 GMT</pubDate></item><item><title><![CDATA[nextjs FSD 폴더구조에 Shcadn-ui 적용시키기]]></title><description><![CDATA[nextjs 에]]></description><link>300-resources/310-개발공부/311-front/nextjs-fsd-폴더구조에-shcadn-ui-적용시키기.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/nextjs FSD 폴더구조에 Shcadn-ui 적용시키기.md</guid><pubDate>Sat, 20 Dec 2025 13:48:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[React 상태 관리 useContext vs Zustand 완벽 가이드]]></title><description><![CDATA[
rerendering 을 최소화 할 수 있음.
디버깅비용 감소
// ❌ useContext - 전체 리렌더링
const UserContext = createContext();
const contextValue = { user, setUser }; // 매번 새 객체 생성
// → Provider 하위 모든 컴포넌트 리렌더링 // ✅ Zustand - 선택적 구독
const useStore = create((set) =&gt; ({ ... }));
const name = useStore(state =&gt; state.user.name); // name만 구독
// → name 변경 시에만 해당 컴포넌트 리렌더링
목표: 추가/삭제되는 노드와 관련 연결선만 리렌더링// 상태 구조 분리
const useWorkflowStore = create((set) =&gt; ({ nodeIds: [], // 노드 목록 (추가/삭제 시에만 변경) nodesById: {}, // 개별 노드 데이터 connections: [], // 연결 정보 (별도 관리) addNode: (nodeData) =&gt; set(state =&gt; ({ nodeIds: [...state.nodeIds, nodeData.id], nodesById: { ...state.nodesById, [nodeData.id]: nodeData } }))
})); // 개별 노드 컴포넌트 최적화
const NodeWrapper = React.memo(({ nodeId }) =&gt; { const nodeData = useWorkflowStore(state =&gt; state.nodesById[nodeId]); return nodeData ? &lt;WorkflowNode data={nodeData} /&gt; : null;
});
목표: 변경된 연결선만 리렌더링// 연결선 개별 컴포넌트
const ConnectionLine = React.memo(({ connectionId }) =&gt; { const connection = useWorkflowStore(state =&gt; state.connections.find(c =&gt; c.id === connectionId) ); const fromPosition = useWorkflowStore(state =&gt; state.nodesById[connection?.from]?.position ); const toPosition = useWorkflowStore(state =&gt; state.nodesById[connection?.to]?.position ); return &lt;SVGLine from={fromPosition} to={toPosition} /&gt;;
});
개별 노드 이동: 해당 노드만 리렌더링const WorkflowNode = React.memo(({ nodeId }) =&gt; { const position = useWorkflowStore(state =&gt; state.nodesById[nodeId]?.position); const [localPosition, setLocalPosition] = useState(null); // 드래그 중 로컬 상태 const handleDragEnd = () =&gt; { if (localPosition) { updateNodePosition(nodeId, localPosition); // 드래그 끝날 때만 전역 업데이트 setLocalPosition(null); } };
});
캔버스 팬/줌: CSS transform으로 노드 리렌더링 없음const WorkflowCanvas = () =&gt; { const [canvasTransform, setCanvasTransform] = useState({ x: 0, y: 0, scale: 1 }); return ( &lt;div style={{ transform: `translate(${canvasTransform.x}px, ${canvasTransform.y}px) scale(${canvasTransform.scale})` }} &gt; {/* 노드들은 리렌더링되지 않음 */} &lt;/div&gt; );
};
전략: 모달은 로컬 상태, 미리보기는 선택적 구독// 데이터 구조 분리
const useWorkflowStore = create((set) =&gt; ({ updateNodeBasicInfo: (nodeId, basicInfo) =&gt; { /* 기본 정보만 업데이트 */ }, updateNodeDetails: (nodeId, details) =&gt; { /* 상세 정보만 업데이트 */ }
})); // 미리보기 컴포넌트 - 필요한 정보만 구독
const NodePreview = React.memo(({ nodeId }) =&gt; { const previewData = useWorkflowStore(state =&gt; { const node = state.nodesById[nodeId]; return { title: node?.title, status: node?.status, progress: node?.details?.progress }; }); return &lt;div&gt;{previewData.title} - {previewData.status}&lt;/div&gt;;
}); // 모달 컴포넌트 - 편집 중에는 로컬 상태 사용
const NodeDetailsModal = () =&gt; { const [editingData, setEditingData] = useState(currentNode); const handleSave = () =&gt; { const changes = getChangedFields(currentNode, editingData); if (changes.basicInfo) updateNodeBasicInfo(nodeId, changes.basicInfo); if (changes.details) updateNodeDetails(nodeId, changes.details); };
};
{ "nodes": [ { "x": 98, "y": 99, "id": "node-1", "role": "PM", "state": "do", "title": "프로젝트 시작", "nextFlow": ["node-2"], "frontFlow": [], "doCondition": "프로젝트 계획서 작성" } ], "connections": [ {"id": "connection-1", "to": "node-2", "from": "node-1"} ]
}
const transformWorkflowJson = (originalJson) =&gt; { const { nodes, connections } = originalJson; return { // 워크플로우 메타 정보 workflow: { id: `workflow-${Date.now()}`, name: "워크플로우", createdAt: Date.now() }, // 노드 ID 목록 (렌더링 순서 유지) nodeIds: nodes.map(node =&gt; node.id), // 노드별 데이터 분리 nodesById: Object.fromEntries( nodes.map(node =&gt; [ node.id, { // 기본 정보 (미리보기용) id: node.id, title: node.title, role: node.role, state: node.state, // 위치 정보 (드래그용) position: { x: node.x, y: node.y }, // 워크플로우 로직 (모달용) workflow: { doCondition: node.doCondition, nextFlow: node.nextFlow, activateCondition: node.activateCondition } } ]) ), // 연결 정보 (이미 분리됨) connections: connections, // UI 상태 ui: { selectedNodeIds: [], canvasTransform: { x: 0, y: 0, scale: 1 } } };
};
// 스토어 팩토리 함수
const createWorkflowStore = (initialData) =&gt; create((set) =&gt; ({ nodes: initialData?.nodes || {}, connections: initialData?.connections || [], // ... 액션들
})); // Context Provider
const WorkflowStoreContext = createContext(); const WorkflowProvider = ({ children, workflowData }) =&gt; { // 컴포넌트 마운트 시 스토어 생성 const [store] = useState(() =&gt; createWorkflowStore(workflowData)); return ( &lt;WorkflowStoreContext.Provider value={store}&gt; {children} &lt;/WorkflowStoreContext.Provider&gt; );
}; // 커스텀 훅
const useWorkflowStore = () =&gt; { const store = useContext(WorkflowStoreContext); if (!store) throw new Error('WorkflowProvider 내에서 사용해야 합니다'); return store;
};
Run// /workflow/page.tsx
export default function WorkflowPage() { const initialData = { /* API에서 가져온 데이터 */ }; return ( &lt;WorkflowProvider workflowData={initialData}&gt; &lt;div className="workflow-editor"&gt; &lt;Toolbar /&gt; &lt;Canvas /&gt; &lt;PropertyPanel /&gt; &lt;/div&gt; &lt;/WorkflowProvider&gt; );
}
Run 페이지 진입 (/workflow/page.tsx 마운트) WorkflowProvider 마운트
useState로 새 스토어 생성
Context Provider 활성화 페이지 사용 하위 컴포넌트들이 스토어 구독
상태 변경 시 선택적 리렌더링 페이지 이탈 (다른 페이지로 이동) WorkflowProvider 언마운트
Context Provider 제거
스토어 자동으로 가비지 컬렉션됨 // ✅ 로컬 스토어 - 자동 정리
const WorkflowProvider = ({ children }) =&gt; { const [store] = useState(() =&gt; createWorkflowStore()); // 컴포넌트 언마운트 시 자동으로 정리됨 return ( &lt;WorkflowStoreContext.Provider value={store}&gt; {children} &lt;/WorkflowStoreContext.Provider&gt; );
}; // ❌ 전역 스토어 - 메모리 누수 위험
const globalStore = create(() =&gt; ({ ... })); // 앱 종료까지 메모리에 계속 존재
Run
상태 분리: 자주 변경되는 상태와 안정적인 상태 분리
선택적 구독: 필요한 데이터만 구독하는 selector 사용
React.memo: 불필요한 리렌더링 방지
드래그 최적화: 드래그 중에는 로컬 상태, 완료 시 전역 상태 업데이트
CSS transform: 캔버스 팬/줌은 CSS로 처리 적절한 스코프: 페이지별 로컬 스토어 사용
자동 정리: 컴포넌트 언마운트 시 스토어 자동 해제
지연 로딩: 대용량 데이터는 필요할 때 로딩
정규화: JSON 데이터를 평면적 구조로 변환 팩토리 패턴: 스토어 생성 함수 분리
커스텀 훅: 스토어 접근 로직 캡슐화
타입 안전성: TypeScript 적용 시 타입 정의
테스트 가능성: 스토어 로직과 UI 분리
// 1. 로컬 스코프 Zustand 스토어
// 2. 상태별 분리 (nodes, connections, ui)
// 3. 선택적 구독으로 성능 최적화
// 4. 드래그 시 로컬 상태 활용
// 5. 페이지 이탈 시 자동 정리 export default function WorkflowPage() { return ( &lt;WorkflowProvider&gt; &lt;WorkflowEditor /&gt; &lt;/WorkflowProvider&gt; );
}
Run핵심 메시지: "전역 스토어의 성능 이점 + 로컬 스코프의 메모리 효율성"을 동시에 얻는 것이 최선의 해결책입니다.]]></description><link>300-resources/310-개발공부/311-front/react-상태-관리-usecontext-vs-zustand-완벽-가이드.html</link><guid isPermaLink="false">300 Resources/310 개발공부/311 FRONT/React 상태 관리 useContext vs Zustand 완벽 가이드.md</guid><pubDate>Sat, 20 Dec 2025 13:48:06 GMT</pubDate></item><item><title><![CDATA[01 블로그 개편하기]]></title><description><![CDATA[AI시대가 도래하면서 학습의 많은 부분이 쓸모없게 되는지 고민하는 부분이 있음.
학습에서 가장 중요한 것은 기록이라고 생각합. 이 기록을 잘 하고자 OBSIDIAN을 도입해서 사용하고 있음.
Obsidian은 개인 메모앱으로 나를 외부로 알리는 과정에서 한계가 생겼음.
이 한계를 극복하기 위한 외부로 공개할 수 있는 창구가 필요하고 그게 바로 블로깅임.내 메모수정을 최소화 : 나는 내 메모중 일부를 공개하면서 정리를 하지만 많은 시간의 할애를 원치 않음메모를 쓰다보면 안쓰게되거나 관리가 되지 않는 경우가 생김. 그 이유가 내가 집중할 것이 퍼져있으면 사용에 힘이들고 일정수준이 넘어가면 사용하지 않게 되는 것을 깨달았음. 따라서 내 메모의 규칙중 가장 중요한 것은 나의 관심도임. 그래서 PARA체계를 도입. 바로 PARA체계를 적용하면 부족한 부분이 있어서 Inbox에서 내용을 정돈하고 PARA체계에 편입하는 방식으로 관리함.
폴더별 명확한 일 Inbox에 있는 파일들은 추출해서 PARA 정보처리체계에 넣어야할 대상
Projects는 현재 책임을 갖고 기간내에 진행해야할 프로젝트
Areas는 매일매일 관심을 갖고 처리해야할 내용
Resources는 내 관심사에 대한 내용
Archives는 신경을 안써도 되는 모든 내용 블로그와 연동하기 쉬운 형태 내 정돈방식 그대로 외부로 전달.
이 과정에서 특정 blogging 하기로 한 대상에 대해 properties 적용 <a class="internal-link data-link-icon data-link-icon-after data-link-text" data-href="300 Resources/320 지식관리/지식관리 방법론.md" href="300-resources/320-지식관리/지식관리-방법론.html" target="_self" rel="noopener nofollow" data-link-path="300 Resources/320 지식관리/지식관리 방법론.md" style="--data-link-tags: #지식관리 #PARA #CODE #Obsidian #생산성 #정보정리 #제텔카스텐; --data-link-path: 300 Resources/320 지식관리/지식관리 방법론.md;" data-link-tags="#지식관리 #PARA #CODE #Obsidian #생산성 #정보정리 #제텔카스텐">지식관리 방법론</a>2의 CODE 방법에 따라서 정리되는데 여기서 정리되는 항목은 Capture, Organize, Distill, Express 형태이다. 여기서 Distill 부분은 항상 적용되야하는 내용이므로 빼고 처리한다.데이터를 처음 들어왔을 때는 InBox(Capture)에 존재하므로 따로 구분 필요없음.
이후 Organize와 Distill 이 동시에 동작하는데 이때, 완성된 글이 아니라면 상태, 완료해서 쓸 수 있는 형태는 Express까지 이동한다.초기 상태 : x
중간 상태 : properties: [[Distill]], [[Express]] 무조건 한번정리 아니면 Inbox에서 다른 곳으로 옮기지 말것
완료 상태 : properties: [[Express]] 여기서 Distill 까지만 가고 완료를 못한 문서에 대해서는 계속 dataview로 확인하고 완료시켜준다.]]></description><link>100-projects/101-블로그-개편하기/01-블로그-개편하기.html</link><guid isPermaLink="false">100 Projects/101 블로그 개편하기/01 블로그 개편하기.md</guid><pubDate>Sat, 20 Dec 2025 14:13:47 GMT</pubDate></item><item><title><![CDATA[02]]></title><link>100-projects/101-블로그-개편하기/02.html</link><guid isPermaLink="false">100 Projects/101 블로그 개편하기/02.md</guid><pubDate>Sat, 20 Dec 2025 14:03:30 GMT</pubDate></item><item><title><![CDATA[Drawing 2025-12-17 00.54.00]]></title><description><![CDATA[<img src="800-references/802-excalidraw/drawing-2025-12-17-00.54.00.excalidraw.svg" target="_self">]]></description><link>800-references/802-excalidraw/drawing-2025-12-17-00.54.00.excalidraw.html</link><guid isPermaLink="false">800 References/802 Excalidraw/Drawing 2025-12-17 00.54.00.excalidraw.svg</guid><pubDate>Thu, 18 Dec 2025 23:26:57 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[00.프로젝트 초기 구성]]></title><description><![CDATA[소설관계도를 시각화 할 수 있는 Saas 구성, 여기서 개인이 스토리를 작성하면 같이 스토리가 작성되는 ]]></description><link>100-projects/사이드프로젝트(story)/00.프로젝트-초기-구성.html</link><guid isPermaLink="false">100 Projects/사이드프로젝트(Story)/00.프로젝트 초기 구성.md</guid><pubDate>Thu, 13 Nov 2025 14:02:06 GMT</pubDate></item><item><title><![CDATA[2. 현재있는 flow를 과연 llm이 mermaid로 작성할 수 있을까]]></title><description><![CDATA[내가 현재 개발하고 있는 내용을 mermaid.js 로 작성해달라고 말해봤다.
아래와 같이 작성이 되었는데. 기본 모델을 사용했음에도 생각보다 깔끔하고 구체적이어서 놀랐다.
내가 쓴 prompt (cursor의 auto모드)
: system tray에서 카테고리의 항목을 변경했을 때 발생하는 코드들에 대해서 mermaid.js로 변경하는 작업을 진행해줘
]]></description><link>100-projects/mermaid를-통한-prd/2.-현재있는-flow를-과연-llm이-mermaid로-작성할-수-있을까.html</link><guid isPermaLink="false">100 Projects/mermaid를 통한 prd/2. 현재있는 flow를 과연 llm이 mermaid로 작성할 수 있을까.md</guid><pubDate>Tue, 16 Sep 2025 19:31:48 GMT</pubDate></item><item><title><![CDATA[4. 확인사항]]></title><description><![CDATA[출분히 비지니스나 업무관련 workflow는 mermaid.js 로 그리는 것이 가능하다.특히 claude 4.0 sonnet 부터는 claude-desktop에 mermaid 탑재기능을 넣으면서 workflow 해석능력이 타 언어모델보다 나아보임.업무를 수행하면서 해당 업무가 어떤 기능에 대한 것을 명시 혹은 진입점의 component 상단에 넣어놓으면 해당 업무를 수행하면서 workflow 수정 혹은 완료 시 표기하여 이후 해당 workflow 에 대한 이해도를 대폭 늘릴 수 있을 것으로 보인다.추가적으로 작업이후에 해당기능에 대해서 평가를 해보겠다.]]></description><link>100-projects/mermaid를-통한-prd/4.-확인사항.html</link><guid isPermaLink="false">100 Projects/mermaid를 통한 prd/4. 확인사항.md</guid><pubDate>Tue, 16 Sep 2025 19:11:00 GMT</pubDate></item><item><title><![CDATA[3. mermaid관련된 내용 작업 진행(템플릿)]]></title><description><![CDATA[Create documentation focused on business logic and workflows rather than technical implementation details, making it easy for future developers to understand how features work.
Data Branching Criteria: When and how logic branches
Function Names: Which functions are called (excluding technical implementation)
External API Integration: Points of integration with external systems
User Actions: What actions users perform
Results/State: What results occur at each step
Business Rules: Why the system behaves this way Code implementation details
Variable names, type definitions, interface structures
Technical architecture explanations
Error handling details
Performance optimization content
# [Feature Name] Workflow ## Overview
- Brief description of what this feature does
- What problem it solves for users ## User Scenario
- User performs [specific action]
- [Condition] determines [result] ## Branching Criteria
1. **[Condition A]** → Execute [Path 1]
2. **[Condition B]** → Execute [Path 2]
3. **[Condition C]** → Execute [Path 3] ## Execution Flow
1. **[Function Name]** Call - Purpose: [Why it's called] - Result: [What state changes] 2. **[External API]** Integration - Purpose: [What data is retrieved] - Result: [What information is obtained] 3. **[State Change]** Occurs - Purpose: [Why state is changed] - Result: [What UI updates] ## Data Flow
- Input: [Data user inputs]
- Processing: [How it's transformed]
- Output: [Final result] ## Exception Handling
- **[Exception 1]**: [How it's handled]
- **[Exception 2]**: [How it's handled] ## Related Functions
- `[Function1]`: [Role description]
- `[Function2]`: [Role description]
- `[Function3]`: [Role description] Start with "When user clicks..." format
Use common terms rather than technical jargon Explain if/else conditions as business logic
Use expressions like "if data exists", "if user has permission" switchToCategory() → "Category switching function"
updateMCPConfig() → "Configuration file update function" API calls, file saves, database connections
Include reasons for external integration Specify "what changes" at each step
UI changes, data changes, state changes
# System Tray Category Change Workflow ## Overview
When users select a different category from the system tray, the server settings for that category are reflected in the actual Claude/Cursor configuration files. ## User Scenario
- User right-clicks system tray icon
- Selects desired category from "Claude Category" or "Cursor Category" submenu
- Servers in selected category become available in the respective application ## Branching Criteria
1. **Claude Category Selected** → Update Claude configuration file
2. **Cursor Category Selected** → Update Cursor configuration file
3. **Category Has No Servers** → Create empty configuration file ## Execution Flow
1. **Category Switch Function** Call - Purpose: Change selected category to active state - Result: Store active category information 2. **Configuration File Update Function** Call - Purpose: Reflect selected category's servers in actual configuration file - Result: Claude/Cursor recognizes new servers 3. **Renderer Process Notification** - Purpose: Display changed category information in UI - Result: New active category shown in app interface ## Data Flow
- Input: Category ID selected by user
- Processing: Convert servers in category to configuration file format
- Output: Save as JSON in Claude/Cursor configuration file ## Related Functions
- `switchToCategory()`: Category switching processing
- `updateMCPConfig()`: Configuration file update
- `updateTrayMenu()`: Tray menu state synchronization Written from user perspective?
Branching criteria clear?
Function names match their roles?
External integration points specified?
Results clear at each step?
Technical details excluded?
]]></description><link>100-projects/mermaid를-통한-prd/3.-mermaid관련된-내용-작업-진행(템플릿).html</link><guid isPermaLink="false">100 Projects/mermaid를 통한 prd/3. mermaid관련된 내용 작업 진행(템플릿).md</guid><pubDate>Tue, 16 Sep 2025 19:06:20 GMT</pubDate></item><item><title><![CDATA[1. LLM과 협업하기]]></title><description><![CDATA[현재 바이브코딩에서는 LLM과 협업하는 형태로 다시 개발문서 작성을 통한 개발로 돌아가고 있다.
해당 방식이 가능해진 이유는 다음과 같다.
개발문서 작업공수 감소 : 개발문서를 작성할 수 있는 방식이 기존에는 사람이 모든 문서내용을 작성해야했다면, 현재는 LLM이 대략적인 플로우를 작성해주기 때문이다.
사람이라면 내재화된 지식들을 llm은 일관성을 유지하기 어려움으로 컨텍스트로 쓸 문서를 작성하는 개념 하지만 복잡한 업무 플로우에 대해서 작성하지 못하는 문제가 발생한다.
이런 문제 방식을 좀더 효율적으로 개선하기 위해서는 어떤방식을 사용할까 고민해봤다.LLM이 사람이라면 어떤 방식을 이해하기 쉬울까 고민해봤을 때 가장 잘 이해하는 방식은 WORKFLOW 방식이다. 알고리즘 FLOW CHART를 그려서 판단하는 것이다.
하지만 줄글을 통해서는 해당 WORKFLOW를 판단하는데 어려움이 있다.코딩으로는 이미 WORKFLOW가 있는거나 다름없지만 코드로 존재하는 것이기 때문에 전체적인 윤곽을 잡기가 어렵다.그렇다면 현재 Claude에서 밀고있는 mermaid.js로부터 시작해보면 어떨까라는 아이디어를 갖게 되었다.]]></description><link>100-projects/mermaid를-통한-prd/1.-llm과-협업하기.html</link><guid isPermaLink="false">100 Projects/mermaid를 통한 prd/1. LLM과 협업하기.md</guid><pubDate>Tue, 16 Sep 2025 18:35:33 GMT</pubDate></item><item><title><![CDATA[반복적인 엑셀 작성업무 자동화]]></title><description><![CDATA[반복적인 엑셀의 데이터를 입력해야하는 일이 발생하였다. 이를 간편하게 해결하고 차후 추가적으로 기능을 개선할 수 있도록 하기위한 electron으로 만든 프로그램이다.예를들어 A,B,C 의 데이터가 있는데 이 데이터를 통해서 엑셀에 있는 값을 바꿔야하는 상황이다. 문제는 B의 데이터가 엑셀 내부에서 하나의 셀에서만 사용하지 않고 사용하는 곳이 10군데 이상이다.
실제 사용자 입장에서 해야하는 행동프로세스는 다음과 같았다.
엑셀템플릿을 복사
해당 템플릿 내부에 데이터를 일일히 변경
수식을 사용하려고 하였으나 데이터상으로 고정값이 들어가야하고 기록용 시트 및 실 사용자들의 요구로는 데이터 값이 들어가야하는 요구
기록하는 데이터가 외부 웹에 있는 데이터, 차후 api수신을 통해서 사용자가 직접 복붙이 아닌 한번에 동작할 수 있는 기능으로 적용
]]></description><link>100-projects/엑셀-데이터-변경-프로젝트/반복적인-엑셀-작성업무-자동화.html</link><guid isPermaLink="false">100 Projects/엑셀 데이터 변경 프로젝트/반복적인 엑셀 작성업무 자동화.md</guid><pubDate>Sun, 31 Aug 2025 16:35:37 GMT</pubDate></item><item><title><![CDATA[08. FSD 관련 cursor rule]]></title><description><![CDATA[app → pages → widgets → features → entities → shared
Dependency Rule: Upper layers can import from lower layers, but NOT vice versa.
app: Global setup, routing, providers, root store
pages: Route components, layout composition
widgets: Independent UI blocks combining features+entities
features: Business functionality with user interactions
entities: Domain models, data-centric components
shared: Reusable, domain-agnostic components &amp; utilities
[domain]/
├── ui/ # UI components
├── model/ # Business logic, state management
├── api/ # Server communication
├── lib/ # Helper functions
├── config/ # Configuration files
└── index.ts # Public API exports
Is it domain-agnostic? ├── YES → shared/ui
└── NO → Is it pure data display? ├── YES → entities/[domain]/ui └── NO → features/[feature]/ui shared/ui: "Can this be used in any project without domain knowledge?"
entities: "Does this only display domain data without business logic?"
features: "Does this perform a specific business function?"
widgets: "Does this combine multiple features/entities into an independent block?"
// shared/ui/Button.tsx - Pure UI component
const Button = ({ variant, onClick, children }) =&gt; ( &lt;button className={`btn-${variant}`} onClick={onClick}&gt; {children} &lt;/button&gt;
) // entities/user/ui/UserCard.tsx - Pure data display
const UserCard = ({ user }) =&gt; ( &lt;Card&gt; &lt;Avatar src={user.avatar} /&gt; &lt;Text&gt;{user.name}&lt;/Text&gt; &lt;Text&gt;{user.email}&lt;/Text&gt; &lt;/Card&gt;
) // features/auth/ui/LoginForm.tsx - Business function
const LoginForm = () =&gt; { const { login, isLoading } = useAuth() return ( &lt;form onSubmit={handleLogin}&gt; &lt;Input name="email" /&gt; &lt;Input name="password" type="password" /&gt; &lt;Button loading={isLoading}&gt;Login&lt;/Button&gt; &lt;/form&gt; )
} // widgets/header/ui/Header.tsx - Combined block
const Header = () =&gt; ( &lt;header&gt; &lt;Logo /&gt; &lt;SearchInput /&gt; &lt;UserProfile /&gt; &lt;LogoutButton /&gt; &lt;/header&gt;
)
// Always use index.ts for public exports
export { UserCard, UserProfile } from './ui'
export { useUserStore } from './model'
export { fetchUser } from './api'
export type { User } from './model/types'
// pages can import from all lower layers
import { Header } from 'widgets/header'
import { LoginForm } from 'features/auth'
import { UserCard } from 'entities/user'
import { Button } from 'shared/ui' // widgets can import features, entities, shared
import { SearchForm } from 'features/search'
import { ProductCard } from 'entities/product'
import { Card } from 'shared/ui' // features can import entities, shared
import { UserAvatar } from 'entities/user'
import { validateEmail } from 'shared/lib'
// Lower layers importing from upper layers
import { LoginForm } from 'features/auth' // in entities
import { UserCard } from 'entities/user' // in shared // Cross-layer imports at same level
import { AuthFeature } from 'features/auth' // in features/profile // Direct internal imports (bypass index.ts)
import { UserCard } from 'entities/user/ui/UserCard' // Use 'entities/user' instead
// entities/user/model/store.ts
export const useUserStore = create((set) =&gt; ({ users: [], currentUser: null, setCurrentUser: (user) =&gt; set({ currentUser: user })
})) // features/auth/model/store.ts
export const useAuthStore = create((set) =&gt; ({ isAuthenticated: false, login: async (credentials) =&gt; { const user = await authApi.login(credentials) useUserStore.getState().setCurrentUser(user) // OK to call entities }
}))
user-management/
product-search/
order-history/
UserCard.tsx
userApi.ts
userStore.ts
types.ts
// Domain-specific component in shared
shared/ui/UserSpecificButton/ // Should be in entities/user // Pure UI component in domain layer entities/user/ui/Button/ // Should be in shared/ui // Business logic in entities
entities/user/model/loginUser() // Should be in features/auth
// Circular dependencies
// entities/user imports features/auth AND
// features/auth imports entities/user // Skipping layers inappropriately // pages directly using entities when features exist
src/
├── app/
│ ├── providers/
│ ├── store/
│ └── styles/
├── pages/
│ └── [route]/
│ ├── ui/
│ └── index.ts
├── widgets/
│ └── [widget-name]/
│ ├── ui/
│ ├── model/
│ └── index.ts
├── features/
│ └── [feature-name]/
│ ├── ui/
│ ├── model/
│ ├── api/
│ └── index.ts
├── entities/
│ └── [entity-name]/
│ ├── ui/
│ ├── model/
│ ├── api/
│ └── index.ts
└── shared/ ├── ui/ ├── lib/ ├── api/ └── config/
When creating a new component, ask:
Domain-agnostic? → shared/ui
Just displaying entity data? → entities/[domain]/ui
Performing business action? → features/[feature]/ui
Combining multiple features/entities? → widgets/[widget]/ui
Route-level composition? → pages/[route]/ui
]]></description><link>100-projects/커서-룰관련-개편/각-요소-템플릿/08.-fsd-관련-cursor-rule.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/각 요소 템플릿/08. FSD 관련 cursor rule.md</guid><pubDate>Sat, 30 Aug 2025 05:33:02 GMT</pubDate></item><item><title><![CDATA[07.디자인 스타일 가이드]]></title><link>100-projects/커서-룰관련-개편/각-요소-템플릿/07.디자인-스타일-가이드.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/각 요소 템플릿/07.디자인 스타일 가이드.md</guid><pubDate>Tue, 26 Aug 2025 15:50:11 GMT</pubDate></item><item><title><![CDATA[05.DB 가이드]]></title><description><![CDATA[supabase 이용시 테이블 가이드 관련database.ts 파일만으로는 부분적으로만 충분해요. 더 효과적으로 만들려면 추가 정보가 필요합니다.// Supabase에서 자동 생성되는 타입들
export interface Database { public: { Tables: { users: { Row: { id: number email: string created_at: string } Insert: { id?: number email: string created_at?: string } Update: { id?: number email?: string created_at?: string } } } }
}
✅ 타입 정보는 완벽하게 제공
✅ CRUD 인터페이스 명확❌ 관계 정보 (FK, 1:N, M:N)
❌ 비즈니스 규칙
❌ 인덱스/제약조건
❌ RLS 정책# Supabase Database Schema ## Types (자동생성)
[database.ts 내용 포함] ## Relationships
```sql
-- Foreign Key Relationships
users (1) ---&gt; (N) orders (user_id)
orders (1) ---&gt; (N) order_items (order_id)
products (1) ---&gt; (N) order_items (product_id) users: 본인 데이터만 읽기/수정 가능
orders: 본인 주문만 접근 가능
profiles: public 읽기, 본인만 수정
// 관계 데이터 조회
const { data } = await supabase .from('users') .select(` *, orders ( *, order_items ( *, products (name, price) ) ) `) .eq('id', userId); 주문 생성시 재고 확인 필수
사용자는 본인 데이터만 접근 가능 (RLS)
soft delete 사용 (deleted_at 컬럼) ## 결론
`database.ts` + **관계 정보** + **비즈니스 규칙** + **RLS 정책**을 함께 제공하면 LLM이 Supabase 특성을 고려한 최적의 코드를 생성할 수 있어요. 특히 Supabase의 `.select()` 문법이나 RLS 고려사항 등은 별도로 명시해주는 것이 좋습니다.
]]></description><link>100-projects/커서-룰관련-개편/각-요소-템플릿/05.db-가이드.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/각 요소 템플릿/05.DB 가이드.md</guid><pubDate>Tue, 26 Aug 2025 15:45:48 GMT</pubDate></item><item><title><![CDATA[06.Clean code 룰]]></title><description><![CDATA[You are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:
DRY - Eliminate duplication ruthlessly
KISS - Simplest solution that works
YAGNI - Build only what's needed now
SOLID - Apply all five principles consistently
Boy Scout Rule - Leave code cleaner than found Use intention-revealing names
Avoid abbreviations except well-known ones (e.g., URL, API)
Classes: nouns, Methods: verbs, Booleans: is/has/can prefix
Constants: UPPER_SNAKE_CASE
No magic numbers - use named constants Single Responsibility - one reason to change
Maximum 20 lines (prefer under 10)
Maximum 3 parameters (use objects for more)
No side effects in pure functions
Early returns over nested conditions Cyclomatic complexity &lt; 10
Maximum nesting depth: 3 levels
Organize by feature, not by type
Dependencies point inward (Clean Architecture)
Interfaces over implementations Code should be self-documenting
Comments explain why, not what
Update comments with code changes
Delete commented-out code immediately
Document public APIs thoroughly Fail fast with clear messages
Use exceptions over error codes
Handle errors at appropriate levels
Never catch generic exceptions
Log errors with context TDD when possible
Test behavior, not implementation
One assertion per test
Descriptive test names: should_X_when_Y
AAA pattern: Arrange, Act, Assert
Maintain test coverage &gt; 80% Profile before optimizing
Optimize algorithms before micro-optimizations
Cache expensive operations
Lazy load when appropriate
Avoid premature optimization Never trust user input
Sanitize all inputs
Use parameterized queries
Follow principle of least privilege
Keep dependencies updated
No secrets in code Atomic commits - one logical change
Imperative mood commit messages
Reference issue numbers
Branch names: type/description
Rebase feature branches before merging Review for correctness first
Check edge cases
Verify naming clarity
Ensure consistent style
Suggest improvements constructively Duplicate code (Rule of Three)
Long methods/classes
Feature envy
Data clumps
Divergent change
Shotgun surgery
Before committing, ensure:
All tests pass
No linting errors
No console logs
No commented code
No TODOs without tickets
Performance acceptable
Security considered
Documentation updated
Remember: Clean code reads like well-written prose. Optimize for readability and maintainability over cleverness.]]></description><link>100-projects/커서-룰관련-개편/각-요소-템플릿/06.clean-code-룰.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/각 요소 템플릿/06.Clean code 룰.md</guid><pubDate>Tue, 26 Aug 2025 15:42:57 GMT</pubDate></item><item><title><![CDATA[04.기술스택 및 라이브러리 가이드라인]]></title><description><![CDATA[
always use promise for page.tsx params props.
use valid picsum.photos stock image for placeholder image use following libraries for specific functionalities:
date-fns: For efficient date and time handling.
ts-pattern: For clean and type-safe branching logic.
@tanstack/react-query: For server state management.
zustand: For lightweight global state management.
react-use: For commonly needed React hooks.
es-toolkit: For robust utility functions.
lucide-react: For customizable icons.
zod: For schema validation and data integrity.
shadcn-ui: For pre-built accessible UI components.
tailwindcss: For utility-first CSS styling.
supabase: For a backend-as-a-service solution.
react-hook-form: For form validation and state management. src
src/app: Next.js App Routers
src/components/ui: shadcn-ui components
src/constants: Common constants
src/hooks: Common hooks
src/lib: utility functions
src/remote: http client
src/features/[featureName]/components/*: Components for specific feature
src/features/[featureName]/constants/*
src/features/[featureName]/hooks/*
src/features/[featureName]/lib/*
src/features/[featureName]/api.ts: api fetch functions Rephrase Input: Transform to clear, professional prompt.
Analyze &amp; Strategize: Identify issues, outline solutions, define output format.
Develop Solution: "As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:"
List steps numerically.
"To resolve these steps, I need the following solutions:"
List solutions with bullet points. Validate Solution: Review, refine, test against edge cases.
Evaluate Progress: If incomplete: Pause, inform user, await input.
If satisfactory: Proceed to final output. Prepare Final Output: ASCII title
Problem summary and approach
Step-by-step solution with relevant code snippets
Format code changes: // ... existing code ... function exampleFunction() { // Modified or new code here } // ... existing code ... Use appropriate formatting
Describe modifications
Conclude with potential improvements Simplicity
Readability
Maintainability
Testability
Reusability
Functional Paradigm
Pragmatism Early Returns
Conditional Classes over ternary
Descriptive Names
Constants &gt; Functions
DRY
Functional &amp; Immutable
Minimal Changes
Pure Functions
Composition over inheritance Avoid Mutation
Use Map, Filter, Reduce
Currying and Partial Application
Immutability Use TypeScript for type safety.
Follow the coding standards defined in the ESLint configuration.
Ensure all components are responsive and accessible.
Use Tailwind CSS for styling, adhering to the defined color palette.
When generating code, prioritize TypeScript and React best practices.
Ensure that any new components are reusable and follow the existing design patterns.
Minimize the use of AI generated comments, instead use clearly named variables and functions.
Always validate user inputs and handle errors gracefully.
Use the existing components and pages as a reference for the new components and pages. Avoid Premature Optimization
Profile Before Optimizing
Optimize Judiciously
Document Optimizations Comment function purpose
Use JSDoc for JS
Document "why" not "what" Higher-order functionality first
Group related functions Use TODO: and FIXME: comments Use appropriate techniques
Prefer returning errors over exceptions Unit tests for core functionality
Consider integration and end-to-end tests you must use promise for page.tsx params props. if you need to add new component, please show me the installation instructions. I'll paste it into terminal.
example
$ npx shadcn@latest add card
$ npx shadcn@latest add textarea
$ npx shadcn@latest add dialog if you need to add new table, please create migration. I'll paste it into supabase.
do not run supabase locally
store migration query for .sql file. in /supabase/migrations/ use npm as package manager. 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요. You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.
Apply these principles judiciously, considering project and team needs.]]></description><link>100-projects/커서-룰관련-개편/각-요소-템플릿/04.기술스택-및-라이브러리-가이드라인.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/각 요소 템플릿/04.기술스택 및 라이브러리 가이드라인.md</guid><pubDate>Tue, 26 Aug 2025 15:39:53 GMT</pubDate></item><item><title><![CDATA[03.개발스펙]]></title><description><![CDATA[개발 스펙은 개발팀이 기능을 구현하는 데 필요한 모든 기술적 세부 사항을 담은 문서입니다. 이는 단순히 기능 목록을 나열하는 것을 넘어, '어떻게' 구현할지에 대한 명확한 지침을 제공하여 불확실성을 없애고 개발 효율성을 높입니다.
기능 요약: 구현하려는 기능이 무엇인지 한두 문장으로 간결하게 설명합니다. (예: "사용자가 파일을 업로드하고 관리할 수 있는 기능")
개발 배경: 왜 이 기능을 개발해야 하는지, 비즈니스적 목표와 사용자 니즈를 명시합니다. (예: "고객 문의 시 첨부 파일이 필요한 경우가 많아 고객센터 운영 효율성 증대를 위함") 세부 기능 목록: 기능의 모든 하위 기능과 동작을 구체적으로 나열합니다. (예: 파일 업로드 버튼, 업로드 상태 표시, 파일 삭제 기능)
사용자 인터페이스 (UI) 스펙: UI/UX 디자인에 따라 각 화면의 구성 요소, 레이아웃, 버튼의 동작 방식 등을 설명합니다.
데이터 모델: 기능 구현에 필요한 데이터 구조를 정의합니다. 어떤 데이터를 어떤 형식으로 저장하고 관리할지 명시합니다. 예: User 테이블에 profile_image_url 컬럼 추가 비즈니스 로직: 기능의 핵심적인 로직과 규칙을 설명합니다. (예: "상품 할인율은 최대 50%를 넘지 못한다", "결제 완료 후 재고 수량을 감소시킨다") API 명세: 프론트엔드와 백엔드 간의 통신을 위해 필요한 API 엔드포인트, 요청/응답 데이터 구조, HTTP 메서드 등을 구체적으로 명시합니다. 예: POST /api/v1/products (상품 등록 API) 기술적 제약사항 및 의존성: 기능 구현에 필요한 외부 라이브러리, API, 또는 기술적 제약사항을 기록합니다.
데이터베이스 스키마 설계: 기능과 관련된 데이터베이스 테이블의 구조, 컬럼, 관계 등을 정의합니다.
오류 및 예외 처리: 발생 가능한 모든 오류 상황(예: 입력값 유효성 검사 실패, 네트워크 오류)에 대한 처리 방안을 상세히 기술합니다. 성능 요구사항: 응답 시간(Latency), 처리량(Throughput) 등 기능이 만족해야 할 성능 지표를 정의합니다. (예: "결제 요청에 대한 응답 시간은 2초 이내여야 한다")
보안 스펙: 기능에 필요한 보안 관련 요구사항을 명시합니다. (예: "사용자 비밀번호는 단방향 암호화하여 저장해야 한다", "모든 API 통신은 HTTPS를 사용한다") playground, jest 기반을 이용하여 테스트를 진행합니다.
테스트 케이스: 기능의 정상 작동 여부를 확인하기 위한 테스트 시나리오를 작성합니다. (예: "유효한 값으로 회원가입 시 정상적으로 가입이 완료되는지 확인", "중복된 아이디로 회원가입 시 오류 메시지가 출력되는지 확인")
성능 테스트: 정의된 성능 요구사항을 만족하는지 확인하기 위한 테스트 시나리오를 포함할 수 있습니다.
]]></description><link>100-projects/커서-룰관련-개편/각-요소-템플릿/03.개발스펙.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/각 요소 템플릿/03.개발스펙.md</guid><pubDate>Tue, 26 Aug 2025 15:29:09 GMT</pubDate></item><item><title><![CDATA[02.코딩 컨벤션 템플릿]]></title><description><![CDATA[코드의 품질과 유지보수성을 높이고 가독성을 높이기 위해서 아래의 규칙을 따른다.명명 규칙은 코드의 각 요소(변수, 함수, 클래스 등)가 어떤 역할을 하는지 이름을 통해 명확히 전달하는 것을 목표로 합니다.
공통: 기본적으로 명명규칙 시 용어사전 내 용어로 작성하며 없을 시 보편적인 용어로 작성한다.(우선순위: 용어사전내 용어 &gt; 보편적인용어) 변수(Variable): camelCase 사용이 일반적입니다. (예: userName, totalCount)
의미를 명확히 담아, 주석 없이도 변수의 역할을 짐작할 수 있도록 해야 합니다.
Bad Example: const a = 10; (무엇을 의미하는지 알 수 없음)
Good Example: const userAge = 25; (변수 역할이 명확함) 함수(Function): camelCase 사용이 일반적입니다.
동사+명사 조합으로 함수의 동작을 표현합니다. (예: getUserProfile, calculateTotalPrice) 클래스(Class): PascalCase 사용이 일반적입니다. (예: UserProfile, ShoppingCart)
클래스가 나타내는 '객체'나 '개념'을 명사로 표현합니다. 상수(Constant): 모두 대문자로 작성하고 단어 사이를 언더스코어(_)로 연결하는 SNAKE_CASE를 사용합니다. (예: API_KEY, MAX_ITEM_COUNT) 주석은 코드 자체로는 설명하기 어려운 맥락, 복잡한 로직의 이유, 기술적 결정의 배경 등을 기록하는 데 사용됩니다.
필요한 경우에만 작성: 코드가 스스로 설명하도록 작성하는 것이 최우선입니다.
파일/모듈 단위 주석: 파일의 최상단에 작성하여 해당 파일의 전반적인 역할과 의존성 등을 설명합니다.
함수/클래스 단위 주석: JSDoc과 같은 표준화된 포맷을 사용해 함수의 기능, 매개변수, 반환 값 등을 명확히 기록합니다. 이는 자동 문서화 도구와 연동하여 효과적으로 문서를 생성하는 데 도움을 줍니다.
코드 포맷팅은 개발 환경을 통일시켜 코드의 시각적인 일관성을 유지하는 것입니다. 이를 위해 Prettier 형식을 사용합니다. 탭은 2칸입니다.]]></description><link>100-projects/커서-룰관련-개편/각-요소-템플릿/02.코딩-컨벤션-템플릿.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/각 요소 템플릿/02.코딩 컨벤션 템플릿.md</guid><pubDate>Tue, 26 Aug 2025 15:27:16 GMT</pubDate></item><item><title><![CDATA[01.용어사전 템플릿]]></title><description><![CDATA[프로젝트에서 사용되는 용어들을 명확히 정의하여 팀원 간의 소통 오류를 방지하고, 프로젝트에 대한 이해를 돕습니다.
PRD (Product Requirements Document) 설명: 제품의 비전, 목표, 기능 등 사용자와 비즈니스 관점의 요구사항을 정의하는 문서입니다. 개발팀이 '무엇을 만들지' 명확히 이해하기 위한 핵심 가이드 역할을 합니다. API (Application Programming Interface) 설명: 소프트웨어 간의 통신을 위한 인터페이스입니다. 주로 프론트엔드와 백엔드가 서로 데이터를 주고받는 규칙을 정의하는 데 사용됩니다. Frontend 설명: 사용자가 직접 보고 상호작용하는 웹 또는 애플리케이션의 영역을 의미합니다. 주로 HTML, CSS, JavaScript 등으로 개발됩니다. Backend 설명: 서버, 데이터베이스 등 사용자의 눈에 보이지 않는 영역입니다. 비즈니스 로직을 처리하고 데이터를 관리하는 역할을 합니다. Git 설명: 소스 코드의 변경 이력을 관리하는 분산형 버전 관리 시스템입니다. 협업하는 개발자들이 코드 병합 및 관리를 효율적으로 할 수 있도록 돕습니다. CI/CD (Continuous Integration/Continuous Deployment) 설명: 개발자가 작성한 코드를 지속적으로 통합하고 배포하는 자동화 프로세스입니다. 개발 생산성과 안정성을 높이는 데 기여합니다. Scrum 설명: 애자일(Agile) 개발 방법론 중 하나로, 스프린트(Sprint)라는 짧은 주기를 반복하여 프로젝트를 진행하는 방식입니다. Jira/Confluence 설명: 프로젝트 관리 및 문서화를 위한 협업 도구입니다. 작업 추적, 이슈 관리, 회의록 작성 등에 활용됩니다. ]]></description><link>100-projects/커서-룰관련-개편/각-요소-템플릿/01.용어사전-템플릿.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/각 요소 템플릿/01.용어사전 템플릿.md</guid><pubDate>Tue, 26 Aug 2025 15:17:02 GMT</pubDate></item><item><title><![CDATA[CURSOR RULE 작성가이드]]></title><link>100-projects/커서-룰관련-개편/cursor-rule-작성가이드.html</link><guid isPermaLink="false">100 Projects/커서 룰관련 개편/CURSOR RULE 작성가이드.md</guid><pubDate>Tue, 26 Aug 2025 15:05:38 GMT</pubDate></item><item><title><![CDATA[Drawing 2025-12-20 16.50.09]]></title><link>800-references/802-excalidraw/drawing-2025-12-20-16.50.09.excalidraw.html</link><guid isPermaLink="false">800 References/802 Excalidraw/Drawing 2025-12-20 16.50.09.excalidraw.md</guid><pubDate>Sat, 20 Dec 2025 07:51:50 GMT</pubDate></item><item><title><![CDATA[Drawing 2025-12-17 00.54.00]]></title><link>800-references/802-excalidraw/drawing-2025-12-17-00.54.00.excalidraw.html</link><guid isPermaLink="false">800 References/802 Excalidraw/Drawing 2025-12-17 00.54.00.excalidraw.md</guid><pubDate>Thu, 18 Dec 2025 23:26:57 GMT</pubDate></item><item><title><![CDATA[20251216180906UqWQ-obsidian plugin 배포 BRAT]]></title><description><![CDATA[<img src="800-references/801-image/2025/12/20251216180906uqwq-obsidian-plugin-배포-brat.png" target="_self">]]></description><link>800-references/801-image/2025/12/20251216180906uqwq-obsidian-plugin-배포-brat.html</link><guid isPermaLink="false">800 References/801 Image/2025/12/20251216180906UqWQ-obsidian plugin 배포 BRAT.png</guid><pubDate>Tue, 16 Dec 2025 18:08:57 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20251216180906LlbA-obsidian plugin 배포 BRAT]]></title><description><![CDATA[<img src="800-references/801-image/2025/12/20251216180906llba-obsidian-plugin-배포-brat.png" target="_self">]]></description><link>800-references/801-image/2025/12/20251216180906llba-obsidian-plugin-배포-brat.html</link><guid isPermaLink="false">800 References/801 Image/2025/12/20251216180906LlbA-obsidian plugin 배포 BRAT.png</guid><pubDate>Tue, 16 Dec 2025 18:07:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20251130121401TepG-Git전략 실무관련 GITHUB FLOW와 GIT FLOW의 변형]]></title><description><![CDATA[<img src="800-references/801-image/2025/11/20251130121401tepg-git전략-실무관련-github-flow와-git-flow의-변형.png" target="_self">]]></description><link>800-references/801-image/2025/11/20251130121401tepg-git전략-실무관련-github-flow와-git-flow의-변형.html</link><guid isPermaLink="false">800 References/801 Image/2025/11/20251130121401TepG-Git전략 실무관련 GITHUB FLOW와 GIT FLOW의 변형.png</guid><pubDate>Sun, 30 Nov 2025 12:13:49 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20251123123349RzGF-01.IOT 시스템의 구조 및 설계]]></title><description><![CDATA[<img src="800-references/801-image/2025/11/20251123123349rzgf-01.iot-시스템의-구조-및-설계.png" target="_self">]]></description><link>800-references/801-image/2025/11/20251123123349rzgf-01.iot-시스템의-구조-및-설계.html</link><guid isPermaLink="false">800 References/801 Image/2025/11/20251123123349RzGF-01.IOT 시스템의 구조 및 설계.png</guid><pubDate>Sat, 15 Nov 2025 11:58:29 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20251123123349VZoh-01.IOT 시스템의 구조 및 설계]]></title><description><![CDATA[<img src="800-references/801-image/2025/11/20251123123349vzoh-01.iot-시스템의-구조-및-설계.png" target="_self">]]></description><link>800-references/801-image/2025/11/20251123123349vzoh-01.iot-시스템의-구조-및-설계.html</link><guid isPermaLink="false">800 References/801 Image/2025/11/20251123123349VZoh-01.IOT 시스템의 구조 및 설계.png</guid><pubDate>Sat, 15 Nov 2025 11:51:29 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250915130927HcZI-MCP 관리 툴 프로그램]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250915130927hczi-mcp-관리-툴-프로그램.gif" target="_self">]]></description><link>800-references/801-image/2025/09/20250915130927hczi-mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250915130927HcZI-MCP 관리 툴 프로그램.gif</guid><pubDate>Mon, 15 Sep 2025 13:08:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250915130927GKcK-MCP 관리 툴 프로그램]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250915130927gkck-mcp-관리-툴-프로그램.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250915130927gkck-mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250915130927GKcK-MCP 관리 툴 프로그램.png</guid><pubDate>Mon, 15 Sep 2025 12:19:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250915130926yUKf-MCP 관리 툴 프로그램]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250915130926yukf-mcp-관리-툴-프로그램.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250915130926yukf-mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250915130926yUKf-MCP 관리 툴 프로그램.png</guid><pubDate>Mon, 15 Sep 2025 12:13:36 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250915130926kmNJ-MCP 관리 툴 프로그램]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250915130926kmnj-mcp-관리-툴-프로그램.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250915130926kmnj-mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250915130926kmNJ-MCP 관리 툴 프로그램.png</guid><pubDate>Sun, 14 Sep 2025 16:06:44 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250915130926CSmm-MCP 관리 툴 프로그램]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250915130926csmm-mcp-관리-툴-프로그램.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250915130926csmm-mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250915130926CSmm-MCP 관리 툴 프로그램.png</guid><pubDate>Sun, 14 Sep 2025 16:06:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250915130926SDeU-MCP 관리 툴 프로그램]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250915130926sdeu-mcp-관리-툴-프로그램.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250915130926sdeu-mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250915130926SDeU-MCP 관리 툴 프로그램.png</guid><pubDate>Sun, 14 Sep 2025 16:04:36 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250915130926RkMN-MCP 관리 툴 프로그램]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250915130926rkmn-mcp-관리-툴-프로그램.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250915130926rkmn-mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250915130926RkMN-MCP 관리 툴 프로그램.png</guid><pubDate>Sun, 14 Sep 2025 16:02:42 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250915130926EVZE-MCP 관리 툴 프로그램]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250915130926evze-mcp-관리-툴-프로그램.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250915130926evze-mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250915130926EVZE-MCP 관리 툴 프로그램.png</guid><pubDate>Sun, 14 Sep 2025 16:01:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250915130926sFgd-MCP 관리 툴 프로그램]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250915130926sfgd-mcp-관리-툴-프로그램.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250915130926sfgd-mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250915130926sFgd-MCP 관리 툴 프로그램.png</guid><pubDate>Sun, 14 Sep 2025 15:59:14 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20251130115012LGOo-FSD에 Shcadn 적용시키기]]></title><description><![CDATA[<img src="800-references/801-image/2025/11/20251130115012lgoo-fsd에-shcadn-적용시키기.png" target="_self">]]></description><link>800-references/801-image/2025/11/20251130115012lgoo-fsd에-shcadn-적용시키기.html</link><guid isPermaLink="false">800 References/801 Image/2025/11/20251130115012LGOo-FSD에 Shcadn 적용시키기.png</guid><pubDate>Sat, 13 Sep 2025 03:21:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250911131404xlVB-Untitled]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250911131404xlvb-untitled.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250911131404xlvb-untitled.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250911131404xlVB-Untitled.png</guid><pubDate>Thu, 11 Sep 2025 13:14:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250911131507Ecsm-js 번들 분석 및 최적화하기]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250911131507ecsm-js-번들-분석-및-최적화하기.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250911131507ecsm-js-번들-분석-및-최적화하기.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250911131507Ecsm-js 번들 분석 및 최적화하기.png</guid><pubDate>Sun, 07 Sep 2025 09:16:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20250911131507iJCR-js 번들 분석 및 최적화하기]]></title><description><![CDATA[<img src="800-references/801-image/2025/09/20250911131507ijcr-js-번들-분석-및-최적화하기.png" target="_self">]]></description><link>800-references/801-image/2025/09/20250911131507ijcr-js-번들-분석-및-최적화하기.html</link><guid isPermaLink="false">800 References/801 Image/2025/09/20250911131507iJCR-js 번들 분석 및 최적화하기.png</guid><pubDate>Sun, 07 Sep 2025 08:26:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20251130163330YCFo-백엔드의 3요소]]></title><description><![CDATA[<img src="800-references/801-image/2025/12/20251130163330ycfo-백엔드의-3요소.png" target="_self">]]></description><link>800-references/801-image/2025/12/20251130163330ycfo-백엔드의-3요소.html</link><guid isPermaLink="false">800 References/801 Image/2025/12/20251130163330YCFo-백엔드의 3요소.png</guid><pubDate>Tue, 02 Sep 2025 12:34:29 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20251130163330NwvL-백엔드의 3요소]]></title><description><![CDATA[<img src="800-references/801-image/2025/12/20251130163330nwvl-백엔드의-3요소.png" target="_self">]]></description><link>800-references/801-image/2025/12/20251130163330nwvl-백엔드의-3요소.html</link><guid isPermaLink="false">800 References/801 Image/2025/12/20251130163330NwvL-백엔드의 3요소.png</guid><pubDate>Tue, 02 Sep 2025 12:25:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Obsidian 폴더구조 가이드-225418]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/obsidian-폴더구조-가이드-225418.png" target="_self">]]></description><link>800-references/801-image/2025/08/obsidian-폴더구조-가이드-225418.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/Obsidian 폴더구조 가이드-225418.png</guid><pubDate>Mon, 25 Aug 2025 13:51:57 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SUPBASE GOOGLE OAUTH VERCEL 인증 환경설정-2]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/supbase-google-oauth-vercel-인증-환경설정-2.png" target="_self">]]></description><link>800-references/801-image/2025/08/supbase-google-oauth-vercel-인증-환경설정-2.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/SUPBASE GOOGLE OAUTH VERCEL 인증 환경설정-2.png</guid><pubDate>Thu, 14 Aug 2025 08:02:51 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SUPBASE GOOGLE OAUTH VERCEL 인증 환경설정-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/supbase-google-oauth-vercel-인증-환경설정-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/supbase-google-oauth-vercel-인증-환경설정-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/SUPBASE GOOGLE OAUTH VERCEL 인증 환경설정-1.png</guid><pubDate>Thu, 14 Aug 2025 08:01:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[MDXRemote 테이블 깨짐 문제-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/mdxremote-테이블-깨짐-문제-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/mdxremote-테이블-깨짐-문제-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/MDXRemote 테이블 깨짐 문제-1.png</guid><pubDate>Wed, 23 Jul 2025 10:57:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[공유기 원격데스크톱 접속-4]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/공유기-원격데스크톱-접속-4.png" target="_self">]]></description><link>800-references/801-image/2025/08/공유기-원격데스크톱-접속-4.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/공유기 원격데스크톱 접속-4.png</guid><pubDate>Tue, 15 Jul 2025 15:44:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[공유기 원격데스크톱 접속-3]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/공유기-원격데스크톱-접속-3.png" target="_self">]]></description><link>800-references/801-image/2025/08/공유기-원격데스크톱-접속-3.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/공유기 원격데스크톱 접속-3.png</guid><pubDate>Tue, 15 Jul 2025 15:42:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[공유기 원격데스크톱 접속-5]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/공유기-원격데스크톱-접속-5.png" target="_self">]]></description><link>800-references/801-image/2025/08/공유기-원격데스크톱-접속-5.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/공유기 원격데스크톱 접속-5.png</guid><pubDate>Tue, 15 Jul 2025 15:41:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[공유기 원격데스크톱 접속-2]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/공유기-원격데스크톱-접속-2.png" target="_self">]]></description><link>800-references/801-image/2025/08/공유기-원격데스크톱-접속-2.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/공유기 원격데스크톱 접속-2.png</guid><pubDate>Tue, 15 Jul 2025 15:38:36 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[공유기 원격데스크톱 접속-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/공유기-원격데스크톱-접속-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/공유기-원격데스크톱-접속-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/공유기 원격데스크톱 접속-1.png</guid><pubDate>Tue, 15 Jul 2025 15:31:44 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Cursor rule 관련-2]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/cursor-rule-관련-2.png" target="_self">]]></description><link>800-references/801-image/2025/08/cursor-rule-관련-2.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/Cursor rule 관련-2.png</guid><pubDate>Tue, 17 Jun 2025 18:51:43 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Cursor rule 관련-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/cursor-rule-관련-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/cursor-rule-관련-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/Cursor rule 관련-1.png</guid><pubDate>Tue, 17 Jun 2025 18:47:20 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[REACT에서 자주 업데이트되는 데이터리스트 관리방식-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/react에서-자주-업데이트되는-데이터리스트-관리방식-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/react에서-자주-업데이트되는-데이터리스트-관리방식-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/REACT에서 자주 업데이트되는 데이터리스트 관리방식-1.png</guid><pubDate>Sun, 08 Jun 2025 10:51:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[한 화면에서 일부 내용만 좌우 스크롤-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/한-화면에서-일부-내용만-좌우-스크롤-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/한-화면에서-일부-내용만-좌우-스크롤-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/한 화면에서 일부 내용만 좌우 스크롤-1.png</guid><pubDate>Sat, 17 May 2025 05:56:37 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멀티 스레딩-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/멀티-스레딩-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/멀티-스레딩-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/멀티 스레딩-1.png</guid><pubDate>Wed, 14 May 2025 11:35:45 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[자동화 n8n-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/자동화-n8n-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/자동화-n8n-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/자동화 n8n-1.png</guid><pubDate>Tue, 15 Apr 2025 16:35:09 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[COMMIT MESSAGE규칙-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/commit-message규칙-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/commit-message규칙-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/COMMIT MESSAGE규칙-1.png</guid><pubDate>Wed, 02 Apr 2025 12:12:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[WEB HOOK 관련-2]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/web-hook-관련-2.png" target="_self">]]></description><link>800-references/801-image/2025/08/web-hook-관련-2.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/WEB HOOK 관련-2.png</guid><pubDate>Wed, 02 Apr 2025 12:12:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[WEB HOOK 관련-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/web-hook-관련-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/web-hook-관련-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/WEB HOOK 관련-1.png</guid><pubDate>Wed, 02 Apr 2025 12:12:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[VSCODE 문자열을 원래 문자열과 함께 특정형태 replace-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/vscode-문자열을-원래-문자열과-함께-특정형태-replace-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/vscode-문자열을-원래-문자열과-함께-특정형태-replace-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/VSCODE 문자열을 원래 문자열과 함께 특정형태 replace-1.png</guid><pubDate>Wed, 02 Apr 2025 12:12:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Obsidian Templater에서 js로 값  실행-4]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-4.png" target="_self">]]></description><link>800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-4.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/Obsidian Templater에서 js로 값  실행-4.png</guid><pubDate>Wed, 02 Apr 2025 12:12:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Obsidian Templater에서 js로 값  실행-2]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-2.png" target="_self">]]></description><link>800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-2.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/Obsidian Templater에서 js로 값  실행-2.png</guid><pubDate>Wed, 02 Apr 2025 12:12:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Obsidian Templater에서 js로 값  실행-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/Obsidian Templater에서 js로 값  실행-1.png</guid><pubDate>Wed, 02 Apr 2025 12:12:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Obsidian Templater에서 js로 값  실행-3]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-3.png" target="_self">]]></description><link>800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-3.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/Obsidian Templater에서 js로 값  실행-3.png</guid><pubDate>Wed, 02 Apr 2025 12:12:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Android Studio 삭제 후 재설치 관련-1]]></title><description><![CDATA[<img src="800-references/801-image/2025/08/android-studio-삭제-후-재설치-관련-1.png" target="_self">]]></description><link>800-references/801-image/2025/08/android-studio-삭제-후-재설치-관련-1.html</link><guid isPermaLink="false">800 References/801 Image/2025/08/Android Studio 삭제 후 재설치 관련-1.png</guid><pubDate>Wed, 02 Apr 2025 12:12:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[웹서비스 기획하기 템플릿]]></title><description><![CDATA[
프로젝트명: [프로젝트 이름]
시작일: [YYYY-MM-DD]
MVP 목표일: [YYYY-MM-DD] (2-4주) 작성 완료
# [프로젝트명] PRD ## 개요
- 만들고자 하는 것: - 해결할 문제: - 타겟 사용자: ## 핵심 기능 (MVP)
1. **기능 1**: [설명]
2. **기능 2**: [설명] 3. **기능 3**: [설명] ## 사용자 플로우
1. 사용자가 접속한다
2. [단계별로 적기]
3. 목표를 달성한다 ## 성공 지표
- 사용자가 이걸 하면 성공: - 내가 이정도 달성하면 성공: 작성 완료
# [프로젝트명] TRD ## 기술 스택
- Frontend: - Backend: - Database: - 배포: ## 폴더 구조
[위의 폴더 구조 복사] ## 주요 컴포넌트/모듈
1. **컴포넌트1**: [역할]
2. **컴포넌트2**: [역할] ## API 설계 (필요시)
- GET /api/xxx: [설명]
- POST /api/xxx: [설명] ## 데이터 구조
[사용할 데이터 형태] 초안 작성 (1주차)
설치/실행 방법 추가 (2-3주차)
배포 링크/사용법 완성 (4주차)
# [프로젝트명] ## 설명
[한 줄로 뭘 하는 앱인지] ## 기능
- 기능 1
- 기능 2 - 기능 3 ## 기술 스택
- [사용한 기술들] ## 설치 및 실행
[나중에 작성] ## 배포 링크
[나중에 작성] ## 스크린샷
[나중에 추가] 해결할 문제:
타겟 사용자:
기존 해결책의 문제점: 내가 아는 기술로 가능한가? (Y/N)
모르는 부분은 2주 안에 학습 가능한가? (Y/N)
혼자서 3개월 안에 만들 수 있나? (Y/N) 개인정보 수집하나? → 개인정보처리방침 필요
결제 기능 있나? → 사업자등록 필요
저작권 침해 요소 없나?
핵심 기능 3개만
기능 1: [한 줄 설명]
기능 2: [한 줄 설명]
기능 3: [한 줄 설명]
추가 기능
기능 A: [한 줄 설명]
기능 B: [한 줄 설명]
UI 개선 프론트엔드: [React/Vue/Vanilla JS]
백엔드: [Node.js/Python/없음]
데이터베이스: [Firebase/Supabase/로컬스토리지]
배포: [Vercel/Netlify/GitHub Pages] 아이디어 검증 완료
기술 스택 결정
PRD 작성 (기획서)
TRD 작성 (기술 설계서)
개발 환경 세팅
GitHub 레포 생성
README 초안 작성 기본 UI 구조
핵심 기능 1
핵심 기능 2
핵심 기능 3
README 업데이트 (설치/실행 방법) 기본 테스트
배포
README 완성 (배포 링크, 사용법)
지인 5명 피드백
my-app/
├── src/
│ ├── components/
│ ├── pages/
│ ├── utils/
│ └── App.js
├── public/
└── README.md
# 코딩 규칙 ## 기본 원칙
- 함수/변수명은 명확하게
- 주석은 '왜'를 적기
- 커밋 메시지 명확히 ## 폴더/파일명
- 컴포넌트: PascalCase
- 파일명: kebab-case
- 함수명: camelCase ## Git 규칙
- feat: 새 기능
- fix: 버그 수정
- style: UI 변경 완료한 것:
막힌 부분:
다음 주 목표: 완료한 것:
막힌 부분:
다음 주 목표: 완료한 것:
막힌 부분:
다음 주 목표: 내가 매일 써보기 (1주일)
지인 5명 써보게 하기
온라인 커뮤니티에 공유하기 사용성: 지인들이 혼자서 사용 가능한가?
유용성: 실제로 문제를 해결하는가?
지속성: 일주일 후에도 사용하는가? 구글링 (30분)
ChatGPT 질문 (30분)
커뮤니티 질문 (Stack Overflow, 오픈채팅)
다른 방법 찾기 (우회 방법) 왜 이걸 만들고 싶었는지 적기:
완성했을 때 기분 상상하기
작은 성취도 기록하기
간단하게 시작해서 점점 발전시켜 나가세요! 🚀]]></description><link>300-resources/360-기획/웹서비스-기획하기-템플릿.html</link><guid isPermaLink="false">300 Resources/360 기획/웹서비스 기획하기 템플릿.md</guid><pubDate>Sat, 20 Dec 2025 13:48:07 GMT</pubDate></item><item><title><![CDATA[자동화 n8n]]></title><description><![CDATA[n8n은 "workflow automation tool", 즉 자동화 워크플로우 도구로, 다양한 서비스 및 앱 간의 작업을 코드 작성 없이 또는 코드와 함께 연결하고 자동화할 수 있는 오픈소스 기반의 도구입니다. 이름은 “n8n”으로, “nodemation(node + automation)”의 줄임말입니다.
하나 이상의 노드(Node) 들이 연결되어 실행 순서를 구성한 것
각 노드는 특정 작업(ex. 이메일 전송, HTTP 요청, 데이터베이스 조회 등)을 수행 각각의 노드는 하나의 단일 작업을 수행하는 모듈
예: Google Sheets 노드, HTTP Request 노드, Function 노드, MySQL 노드 등 워크플로우를 시작하는 역할
예: Cron (정기 실행), Webhook (외부 이벤트), Gmail (새 이메일 수신 시) 드래그 앤 드롭 방식으로 워크플로우 구성 가능 Slack, Discord, Google Drive, AWS, MySQL, PostgreSQL, Airtable 등 300개 이상의 서비스와 통합 IF, SWITCH, LOOP 같은 조건 제어 가능 Function 노드에서 JavaScript로 직접 로직 구현 가능 외부 API 연동을 위한 인증 정보는 n8n 내부에 안전하게 저장 및 관리 n8n은 오픈소스로, 서버에 직접 설치 가능
클라우드 서비스(n8n.cloud)도 존재 Google Sheets에 새로운 행이 추가되면 Slack으로 메시지 발송 HTTP Request → HTML Extract → Discord 알림 MySQL에서 데이터 가져와 → Notion에 삽입 → 이메일 전송 주기적으로 API 요청 → 특정 응답값 조건 충족 시 Telegram 알림
version: "3" services: n8n: image: n8nio/n8n ports: - "5678:5678" environment: - N8N_BASIC_AUTH_USER=admin - N8N_BASIC_AUTH_PASSWORD=admin123 volumes: - ~/.n8n:/home/node/.n8n
→ 브라우저에서 http://localhost:5678 접속
트리거 노드가 발동되면 → 이후 노드가 순차적으로 실행되며 → 각 노드의 출력이 다음 노드의 입력으로 전달됨 각 노드는 JSON 데이터를 받아 → 변형하거나 → 전달하거나 → 외부 API와 통신 직관적인 UI/UX
오픈소스 및 자체 서버 설치 가능
JavaScript로 고급 로직 구현 가능
다양한 플러그인 및 노드 지원 워크플로우 복잡도가 높아질 경우 시각화 어려움
UI가 무거워질 수 있음
기능 추가 시 JavaScript 지식 필요
→ GitHub PR 생성 시 → Notion 자동 정리→ SQL 못 쓰는 상황에서 JS로 필터 조건 작성→ Docker 볼륨 마운트 시 유지 가능<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=Fk5pQ0fQkJ0&amp;t=56s" target="_self">https://www.youtube.com/watch?v=Fk5pQ0fQkJ0&amp;t=56s</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/n8n-io/self-hosted-ai-starter-kit" target="_self">https://github.com/n8n-io/self-hosted-ai-starter-kit</a><br><img src="800-references/801-image/2025/08/자동화-n8n-1.png" target="_self">1]]></description><link>300-resources/350-자동화/자동화-n8n.html</link><guid isPermaLink="false">300 Resources/350 자동화/자동화 n8n.md</guid><pubDate>Sat, 20 Dec 2025 13:48:07 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[매크로부터 N8N까지]]></title><description><![CDATA[자동화의 발전단계는 LLM을 통해 크게 국면이 전환됐다. 기본적으로 자동화는 TRIGGER와 ACTION으로 나누어지는데 특정 TRIGGER를 받으면 ACTION을 행하는 형태로 만들어진다.
이런 자동화는 예전부터 됐고 다음과 같이 AI AGENT까지 오게 됐다.
매크로 : TRIGGER + ACTION
AI 자동화 : TRIGGER + ACTION + LLM
AI AGENT : TRIGGER + LLM + MCP(TOOL)
이러한 자동화는 기본적으로 외부 서비스와 API로 통신하여 상호작용한다.n8n의 AI Agent는 n8n 워크플로우 자동화 플랫폼에 통합된 인공지능 기능입니다. 2024년에 도입된 이 혁신적인 기능은 자연어 처리(NLP)와 대형 언어 모델(LLM)을 활용하여 사용자가 복잡한 코딩 없이도 강력한 자동화 워크플로우를 구축할 수 있게 합니다. 로우코드(Low-code) 및 노코드(No-code) 움직임과 맥을 같이하는 이 기술은 디지털 변환을 가속화하고 있습니다.나의 경우는 일반적으로 DOCKER DESKTOP으로 환경을 분리하고 해당 환경에서 N8N을 사용함.
이]]></description><link>300-resources/350-자동화/매크로부터-n8n까지.html</link><guid isPermaLink="false">300 Resources/350 자동화/매크로부터 N8N까지.md</guid><pubDate>Sat, 20 Dec 2025 13:48:07 GMT</pubDate></item><item><title><![CDATA[지식관리 체계 확장 및 개인화]]></title><description><![CDATA[지식관리 체계의 확장과 개인화 방법을 OBSIDIAN에서 구현하는 방법을 탐구합니다. PARA와 CODE 시스템을 활용해 효율적인 지식 관리를 도와드립니다.]]></description><link>300-resources/320-지식관리/지식관리-체계-확장-및-개인화.html</link><guid isPermaLink="false">300 Resources/320 지식관리/지식관리 체계 확장 및 개인화.md</guid><pubDate>Sat, 20 Dec 2025 13:48:07 GMT</pubDate></item><item><title><![CDATA[지식관리 방법론]]></title><description><![CDATA[효율적인 지식관리 체계 구축을 위한 PARA와 CODE 방법론을 소개합니다. 지식 재사용성을 높이고 생산성을 향상시켜 보세요.]]></description><link>300-resources/320-지식관리/지식관리-방법론.html</link><guid isPermaLink="false">300 Resources/320 지식관리/지식관리 방법론.md</guid><pubDate>Sat, 20 Dec 2025 13:48:07 GMT</pubDate></item><item><title><![CDATA[obsidian 템플릿 활용건]]></title><description><![CDATA[Link :: <a class="internal-link data-link-icon data-link-icon-after data-link-text" data-href="900 Settings/901 Templates/express-template.md.md" href="900-settings/901-templates/express-template.html" target="_self" rel="noopener nofollow" data-link-path="900 Settings/901 Templates/express-template.md.md" style="--data-link-path: 900 Settings/901 Templates/express-template.md.md;" data-link-tags="">express-template.md</a>, <a class="internal-link data-link-icon data-link-icon-after data-link-text" data-href="900 Settings/901 Templates/main-template.md.md" href="900-settings/901-templates/main-template.html" target="_self" rel="noopener nofollow" data-link-path="900 Settings/901 Templates/main-template.md.md" style="--data-link-path: 900 Settings/901 Templates/main-template.md.md;" data-link-tags="">main-template.md</a>우선 초기이니 기본템플릿 (main-template)와 포스팅용템플릿(express-template) 2가지를 만들었다.
기본적인 파일정보를 세팅해준다. 핵심 관리 키워드인 para와 code도 같이 parameter로 넣는다. thumnail의 경우 가장 첫번째 이미지파일로 가져오고 해당 이미지는 월별로 저장된다. 파일명칭과 동일한 이름으로 저장된다.
추가기능
수정하고 template적용 시 updated_at, path 를 현재 상황에 따라 update
thumbnail의 경우 현재 글의 가장 첫번째 thumnail적용 및 파일명-시분초.png형태로 800 reference에 저장된다. id: "{tp.file.path(true)}"
title: "{thumbnailValue}"
tags: []
created_at: "{date}"<br>
para: "<a data-href="Project" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Project</a>2"<br>
code: "<a data-href="Collect" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Collect</a>2"
seo를 통해서 chatgpt-4o를 사용해서 excerpt 및 tags 관련해서 추가작업진행
chatgpt api를 사용해서 excerpt와 tags 적용id: RKZEoGrsFuH3DQa
path: 100 PARA/110 Projects/Obsidian 관리체계 구축하기/지식관리 체계 확장 및 개인화.md
title: 지식관리 체계 확장 및 개인화
excerpt: 지식관리 체계의 확장과 개인화 방법을 OBSIDIAN에서 구현하는 방법을 탐구합니다. PARA와 CODE 시스템을 활용해 효율적인 지식 관리를 도와드립니다.
thumbnail: ""
tags: - 지식관리 - OBSIDIAN - PARA - 개인화 - 지식재활용 - 폴더구조 - 태그시스템
created_at: 2025-08-25 23:38:20
updated_at: 2025-08-26 00:07:34
para: "[[100 PARA/110 Projects/Obsidian 관리체계 구축하기/지식관리 체계 구축|지식관리 체계 구축]]"
code: "[[Collect]]"
위와같이 설정함으로 기본적인 구성이 끝났다.]]></description><link>300-resources/320-지식관리/obsidian-템플릿-활용건.html</link><guid isPermaLink="false">300 Resources/320 지식관리/obsidian 템플릿 활용건.md</guid><pubDate>Sat, 20 Dec 2025 13:48:07 GMT</pubDate></item><item><title><![CDATA[Templater 에서 js 선언 후 실행]]></title><description><![CDATA[
obsidian 으로 작성한 글을 블로그 글로 옮기는 중에 필요한 글을 작성하기 위해서 properties를 세팅해줘야하는데 이부분을 templater로 설정해서 추가적인 작성 없이도 충분히 하도록 설정을 하도록 한다.
이 내용을 통해 SEO를 적용하려고 한다.우선 plugIn으로 Templater를 설치한다.
<img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-1.png" target="_self">2이후로는 Template가 모여있는 Template folder location의 위치를 특정하고 script가 있는 부분도 위치를 정해준다.<br><img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-2.png" target="_self">2<br><img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-3.png" target="_self">2template는 해당 template.md 파일에&lt;% tp.~ %&gt; 방식으로 사용할 수 있다.
tp 객체는 다음과 같다.<br>
<img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-4.png" target="_self">2내가 폴더에 넣은 js 코드는 tp.user.js파일명() 형태로 사용할 수 있다.
원래 function get_reading_time(tp) { console.log('tp',tp) console.log(tp.file.title) let content = app.vault.read(tp.file.title); let wordCount = content.split(/\s+/).length; return String(Math.ceil(wordCount / 200)); // 문자열로 변환
} module.exports = get_reading_time; &lt;%
const noteTitle = tp.file.title;
const todayDate = tp.date.now("YYYY-MM-DD");
const author = tp.frontmatter.author || "Unknown"; tR += `# ${noteTitle}\n`;
tR += `&gt; Created on ${todayDate} by ${author}`;
%&gt; ]]></description><link>300-resources/320-지식관리/templater-에서-js-선언-후-실행.html</link><guid isPermaLink="false">300 Resources/320 지식관리/Templater 에서 js 선언 후 실행.md</guid><pubDate>Sat, 20 Dec 2025 13:48:07 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Obsidian Templater에서 js로 값  실행]]></title><description><![CDATA[
obsidian 으로 작성한 글을 블로그 글로 옮기는 중에 필요한 글을 작성하기 위해서 properties를 세팅해줘야하는데 이부분을 templater로 설정해서 추가적인 작성 없이도 충분히 하도록 설정을 하도록 한다.
이 내용을 통해 SEO를 적용하려고 한다.우선 plugIn으로 Templater를 설치한다.
<img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-1.png" target="_self">2이후로는 Template가 모여있는 Template folder location의 위치를 특정하고 script가 있는 부분도 위치를 정해준다.<br><img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-2.png" target="_self">2<br><img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-3.png" target="_self">2template는 해당 template.md 파일에&lt;% tp.~ %&gt; 방식으로 사용할 수 있다.
tp 객체는 다음과 같다.<br>
<img src="800-references/801-image/2025/08/obsidian-templater에서-js로-값-실행-4.png" target="_self">2내가 폴더에 넣은 js 코드는 tp.user.js파일명() 형태로 사용할 수 있다.
원래 function get_reading_time(tp) { console.log('tp',tp) console.log(tp.file.title) let content = app.vault.read(tp.file.title); let wordCount = content.split(/\s+/).length; return String(Math.ceil(wordCount / 200)); // 문자열로 변환
} module.exports = get_reading_time; &lt;%
const noteTitle = tp.file.title;
const todayDate = tp.date.now("YYYY-MM-DD");
const author = tp.frontmatter.author || "Unknown"; tR += `# ${noteTitle}\n`;
tR += `&gt; Created on ${todayDate} by ${author}`;
%&gt; ]]></description><link>300-resources/320-지식관리/obsidian-templater에서-js로-값-실행.html</link><guid isPermaLink="false">300 Resources/320 지식관리/Obsidian Templater에서 js로 값  실행.md</guid><pubDate>Sat, 20 Dec 2025 13:48:07 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[MCP 관리 툴 프로그램]]></title><description><![CDATA[MCP 관리툴 프로그램으로 다양한 MCP 도구를 효율적으로 관리하고 설정하는 방법을 알아보세요.]]></description><link>300-resources/310-개발공부/316-ai/mcp-관리-툴-프로그램.html</link><guid isPermaLink="false">300 Resources/310 개발공부/316 AI/MCP 관리 툴 프로그램.md</guid><pubDate>Sat, 20 Dec 2025 13:48:07 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Obsidian MCP 서버 응답 지연 및 Lock 문제 해결 가이드]]></title><description><![CDATA[npx로 실행한 Obsidian MCP 서버에서 긴 콘텐츠 요청 후 lock이 발생하는 문제의 원인 분석과 해결 방법을 정리합니다.]]></description><link>300-resources/320-지식관리/obsidian_mcp_서버_응답_지연_문제_해결.html</link><guid isPermaLink="false">300 Resources/320 지식관리/Obsidian_MCP_서버_응답_지연_문제_해결.md</guid><pubDate>Sat, 20 Dec 2025 13:44:56 GMT</pubDate></item><item><title><![CDATA[현대오토에버 프로젝트]]></title><link>300-resources/330-hr/내-프로젝트-정리/현대오토에버-프로젝트.html</link><guid isPermaLink="false">300 Resources/330 HR/내 프로젝트 정리/현대오토에버 프로젝트.md</guid><pubDate>Tue, 16 Dec 2025 13:11:30 GMT</pubDate></item><item><title><![CDATA[꿈 판매 이야기]]></title><description><![CDATA[우리는 하루중 약 7~8시간 정도를 수면에 사용하는데 이 수면을 줄여주는 것은 사실상 우리가 가장 중요하다고 여기는 자원인 시간을 파는 것과 같은 행위라고 생각함.도입부,당신은 하루에 한시간씩 더 쓸 수 있다면 얼마를 지불하시겠습니까?어느날 어느 한 작은 기업에서 기적의 약을 만들어냄.해당 약물은 수면을 깊게 만들어서 사람들로 하여금 4시간만 자도 멀쩡한 활동을 할 수 있게하는 약물이 약물은 수면시간을 줄인다는 개념보다 당신의 하루를 늘려주는 것에 대한 대가로 엄청 적은 금액만 받고 약을 팔음. 단 이 약의 주의사항중에 대가로 당신의 꿈을 받는다는 항목이 들어있음.사람들은 반신반의 했지만 하루에 4시간 씩 더 얻고, 수면의 질도 월등하게 높은 사람한테 경쟁으로 밀릴 수 밖에 없었고, 너도 나도 쓰기 시작함.이제 현실로 돌아와서.
대학생인 주인공은 해당 약을 먹고 대학교 시험을 치루고 나온 상태. ]]></description><link>300-resources/340-이야기/꿈-판매-이야기.html</link><guid isPermaLink="false">300 Resources/340 이야기/꿈 판매 이야기.md</guid><pubDate>Fri, 28 Nov 2025 02:44:34 GMT</pubDate></item><item><title><![CDATA[통합 자소서]]></title><link>300-resources/330-hr/통합-자소서.html</link><guid isPermaLink="false">300 Resources/330 HR/통합 자소서.md</guid><pubDate>Tue, 25 Nov 2025 11:55:36 GMT</pubDate></item><item><title><![CDATA[JD]]></title><description><![CDATA[
자회사/BG
두산로보틱스 모집분야
Fullstack Developer 수행업무/전공/자격요건
[이런 일을 수행해요]
• 로보틱스의 다양한 인터페이스를 이용해 최적화된 소프트웨어를 구현해요.
• 백엔드(API, 데이터 파이프라인)부터 프론트엔드(React 기반 UI)까지 전체 스택을 설계하고 구현해요. [이런 경험을 가진 분을 찾아요!]
• TypeScript, Node.js, React 기반 서비스 개발 경험이 있는 분
• gRPC, RESTful 또는 GraphQL 같은 API 설계 및 구현 경험이 있는 분
• 모듈화된 코드 구조와 클린 아키텍처에 대한 이해를 갖고 있는 분 [이런 경험이 있으시면 더 좋아요!]
• WebSocket, gRPC, TCP/IP, UDP 등 실시간 통신 구조 구현 경험
• Go 또는 Python, Node 기반 백엔드 경험
• 다양한 프론트엔드 개발경험 및 업무 자동화 경험 지역
오리
]]></description><link>300-resources/330-hr/두산로보틱스/jd.html</link><guid isPermaLink="false">300 Resources/330 HR/두산로보틱스/JD.md</guid><pubDate>Sun, 23 Nov 2025 14:08:04 GMT</pubDate></item><item><title><![CDATA[01. 오늘의집 자소서]]></title><description><![CDATA[FEConf에서 오늘의집 이라는 회사를 처음 접했습니다. 회사에 관심이 생겨서 제가 관심있어하고 학습해 나갔던 AI, 3D, FRONT 를 하나의 직무에 포함된 것을 보고 지원하게 됐습니다.^]]></description><link>300-resources/330-hr/오늘의-집-자소서-작성/01.-오늘의집-자소서.html</link><guid isPermaLink="false">300 Resources/330 HR/오늘의 집 자소서 작성/01. 오늘의집 자소서.md</guid><pubDate>Mon, 22 Sep 2025 17:20:12 GMT</pubDate></item><item><title><![CDATA[00. jd]]></title><description><![CDATA[Frontend Engineer, GenAI/3D Interior 포지션 소개 오늘의집은 자신의 취향을 ​가진 커뮤니티 ​유저들과 함께 영감을 발산하는 ​콘텐츠와 ​일상 실현을 ​돕는 커머스를 연결하여 ​각자가 원하는 ​라이프스타일을 ​쉽게, 편하게, ​즐겁게 ​만들어가도록 ​돕습니다.오늘의집은 인테리어와 주거 전반의 ​경험을 혁신하는 서비스를 ​만들어가고 ​있으며, ​Frontend Engineer는 유저가 ​가장 먼저 ​마주하는 ​웹 경험을 ​책임지는 제품 ​공동 ​제작자입니다. 단순히 UI를 ​구현하는 것을 ​넘어, 비즈니스의 의도를 인터랙션 구조로 풀어내고, 실시간 유저 피드백을 반영하며, 반복적인 작업 자동화와 인터랙션 실험을 함께 고민합니다. 성능, 확장성, 재사용성을 고려한 프론트엔드 아키텍처와 컴포넌트 설계를 통해 팀의 기술 기반을 함께 구축해 나갑니다.Space AI팀은 AI와 3D 기술을 바탕으로 사용자의 상상을 실현 가능한 경험으로 바꾸는 것을 목표로 합니다. 누구나 직관적으로 사용할 수 있는 3D 인터페이스를 구축하고, AI 기술을 접목해 사용자 맞춤형 인테리어 경험을 제공합니다. 사용자는 3D 모델과 AI 기능을 통해 공간을 시각화하고, 가구와 소품을 자유롭게 배치하며 실제처럼 꾸미는 몰입감 있는 경험을 누릴 수 있습니다. Space AI팀은 이러한 기술을 통해 공간과 사람을 연결하는 혁신적인 서비스를 만들어갑니다.오늘의집은 현재 AI Native 조직으로 변화 중입니다. 우리는 AI를 단순한 보조 도구가 아닌, 일하는 방식 자체를 재정의하는 핵심 기술로 바라보며, 이 변화의 한가운데에서 새로운 사용자 경험을 함께 만들어갈 동료를 기다리고 있습니다.👩‍💻 AI와 동료처럼 함께 일하고 싶은 개발자라면, 바로 오늘의집이 당신의 Playground 입니다.No.1 Lifestyle Tech Company 오늘의집에서 세상에 더 큰 가치를 전하기 위해 도전과 혁신을 이어갈 Frontend Engineer, GenAI/3D Interior 를 기다립니다.👉&nbsp;오늘의집은 여전히 시작점에 서있습니다. 👉 오늘의집 개발팀 소개 바로가기주요업무 공간 기반 웹 애플리케이션을 설계, 개발, 테스트 및 운영 유저의 행동과 니즈를 바탕으로 웹 인터페이스와 데이터 흐름 설계 및 구현 디자이너, 기획자, 백엔드 엔지니어 등 다양한 직군과 협업하며 기획 구체화 및 문제 정의 React와 TypeScript 기반의 웹 애플리케이션을 개발 및 성능·접근성·유지보수성을 고려한 기술 설계 수행 * LLM 기반 Agent를 활용한 사용자 인터랙션 흐름(UI + 로직)을 설계 및 프론트엔드에서 구현자격요건 컴퓨터공학 또는 이와 유사한 전공·지식을 갖추고, 만 2년 이상의 프론트엔드 실무 경험이 있는 분 React, TypeScript 등 현대적인 웹 프레임워크에 대한 깊은 이해를 갖춘 분 CSR, SSR 등 웹 렌더링 방식과 이에 따른 성능 구조에 대한 이해가 있는 분 LLM 기반 구조 설계 또는 Agent 기반 UI 흐름 구현에 관심이 있거나 경험이 있는 분 문제를 빠르게 정의하고, MVP 단위의 실험과 개선 과정을 반복하는 방식에 익숙한 분 Slack, Notion, Figma 등 협업 도구 사용에 익숙하고 원활한 커뮤니케이션 역량을 갖춘 분우대사항 프론트엔드 환경에서 GPT, Claude 등 LLM API를 연동하고 실험한 경험이 있는 분 v0, Cursor 등 AI 기반 UI 개발 도구 또는 코드 보조 도구를 사용한 경험이 있는 분 반복 작업 자동화, 코드 리뷰, 문서화 등 코드 품질 관리에 AI 도구를 적용한 경험이 있는 분 컴포넌트 또는 디자인 시스템을 설계하고 운영한 경험이 있는 분 MSW, Firebase Functions, React Query 등을 활용해 기능 실험 또는 인터페이스 목업을 진행한 경험이 있는 분 Three.js, WebGL 등으로 웹 기반 3D 서비스를 개발한 경험이 있는 분 * 인테리어 및 주거 산업에 대한 관심과 문제의식을 가진 분지원 및 진행 절차 지원서류 :&nbsp;자유양식의 이력서(필수), 포트폴리오 및 커버레터(선택)&nbsp;/ PDF 형식 권장 연봉, 신체 정보, 가족 사항 및 주민번호 등의 민감한 개인정보는 제외 부탁드립니다. 진행절차 : 서류전형 &gt; 직무 인터뷰 &gt; 조직문화 인터뷰 및 레퍼런스 체크 &gt; 처우협의 &gt; 최종합격 직무 인터뷰는 지원자의 이력 및 경력 사항에 따라 1~2일에 걸쳐 진행될 수 있습니다. 인터뷰 과정에 AI 활용 역량을 확인하는 인터뷰가 포함될 예정입니다. 자세한 인터뷰 프로세스는 인터뷰 진행 시점에 개별 안내드리겠습니다. * 진심과 정성을 담는 오늘의집 합류 여정 자세히 알아보기 🔍참고사항 문의사항 : <a data-tooltip-position="top" aria-label="mailto:recruit@bucketplace.net" rel="noopener nofollow" class="external-link is-unresolved" href="mailto:recruit@bucketplace.net" target="_self">recruit@bucketplace.net</a> 해당 공고는 수시 채용으로, 채용 완료 시 조기 마감될 수 있습니다. 입사지원 서류에서 허위기재 사실이 발견될 경우, 입사가 취소될 수 있습니다. 입사 후 3개월의 수습기간 내 온보딩을 위한 프로그램(Move in Program)을 진행합니다. 국가유공자 및 장애인 등 취업보호대상자는 관계 법령에 의거하여 우대합니다. 개인정보 처리방침보상제도 * 인재에 대한 아낌없는 보상 - 최고의 인재에게 최고의 보상 - 입사자 전원 스톡옵션 부여 - 고기여자 대상의 스톡옵션 부여 - 성과에 따른 전사 인센티브 지급근무환경 * 몰입과 성장을 위한 근무환경 - 근무시간 자율 (6시~22시) - 결재 필요 없는 자유로운 휴가 사용 - 조/중/석식 지원&nbsp; - 사내카페 O!Cafe 전 메뉴 무료 지원 - 도서, 컨퍼런스, 교육 지원 - 휴게실 내 고급 안마의자 비치복지 * 함께 오래 가기 위한 케어 - 건강검진 지원 (본인/배우자/양가 부모님) - 단체보험 지원 (본인/배우자/자녀) - 리프레시 휴가 및 장기근속 포상 - 마음케어 프로그램 지원
우리 일의 의미를 함께 경험하기 위한 지원
오늘의집 꾸미기 지원금 연 150만원 지원
오늘의집 VIP 회원 승급
회사의 성장과 함께 우상향 그래프를 그리는 오늘의집 복지와 최적의 근무환경을 더 자세히 알고 싶다면? 👉&nbsp;링크를 클릭하세요! 직군 개발 경력사항 경력 2년 이상 고용형태 정규직 근무지 서울 오피스대한민국 서울특별시 서초구 서초대로74길 4, 삼성생명 서초타워 21층, 25층, 27층 공유하기]]></description><link>300-resources/330-hr/오늘의-집-자소서-작성/00.-jd.html</link><guid isPermaLink="false">300 Resources/330 HR/오늘의 집 자소서 작성/00. jd.md</guid><pubDate>Mon, 22 Sep 2025 17:16:40 GMT</pubDate></item><item><title><![CDATA[01. 토스플레이스 자소서]]></title><description><![CDATA[
name : 구상모
year of birth : 950614
phone : 010-9502-8766
blog : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.koosang.com" target="_self">https://blog.koosang.com</a>
<br>github : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/rn0614" target="_self">https://github.com/rn0614</a>
무엇이든 배우고 쌓는 4년 차 개발자 구상모입니다. 코드는 문제를 해결하기 위한 수단이자 결과물이며, 결과물을 통해 또 다른 해결책을 제시할 수 있는 거름이 될 거라고 믿습니다. 새로운 도전을 계속해나갈 수 있는 환경에서 근무하고 싶어서 토스플레이스에 지원하게 됐습니다.소규모팀으로 각자의 전문성을 가지고 협업할 수 있는 형태의 기업에서 일을하고 싶습니다. 토스는 사일로라는 형태를 통해 작은 스타트업의 결합체와 같은 형태로 기업을 유지하고 있습니다. 최종적으로는 창업이나 사내 창업프로그램을 통해서 내가 생각한 서비스를 만들고 싶습니다. 아직 성장할 길이 많이 남은 토스플레이스에서 소규모팀에서 점점 커져가는 방식의 회사를 경험하고 싶습니다.그 중에 토스플레이스를 선택한 이유는 다양한 산업군에서 많은 문제를 개선해나가는 작업을 하고싶기 때문입니다. 토스는 토스앱을 통해서 고착화된 금융생태계를 변화시켰습니다. 저는 이렇게 고착화가 된 부분이 현재 자영업계에서 많다고 생각합니다. 제가 만든 첫 서비스는 python으로 우유 대리점을 하시는 아버지의 우유 재고 주문 계산기를 만든 것이 처음이었습니다. 아버지는 매일 단순한 업무를 하고 계셨고 그게 불편한게 아니라 해야하는 일로 인지하고 계셨습니다. 저는 이런 문제들이 자영업 계열에서 많이 있다고 생각합니다. 이런 문제를 현재 산업을 넓혀가고 있는 토스플레이스에서 해결해나가고 싶습니다.
시스템이 레거시한 환경에서 근무했지만 언젠간 개선할거라는 믿음, 또 새로운 기술을 쓰면서 레거시에서 어떻게 편해졌고 좋아졌는지 확인하는 과정이 재밌어서 꾸준히 공부해왔습니다. React, Nextjs
Typescript
Spring / Java
PostgreSQL, OracleSQL 목적 : RAG 시스템 도입, 시스템에서 발생하는 오류 및 해결 내역을 기반으로 ELASTIC DB에 저장
기간 : 2025.04~2025.06 / (~ 2025.12 예정)
인원 : 2명
시스템 : spring boot + vue3
내 업무 : 챗봇 화면 구성, Spring LLM API 체계 구축
얻은 것 : ai vector DB 구축 및 시스템, llm 관련 이해
문제 상황 : LLM의 유사도가 생각보다 나오지 않았다. 첫 단계는 우리가 개선한 사항을 적어놓은 메시지를 기반으로 해결책을 제시했으나, 현재는 이슈와 GitLab Commit 코드를 가져와 해당 내용도 같이 포함하는 방식으로 개발 중이다. 미래에는 하나의 파일에 최대한 짧은 코드 조각이 들어있어야 LLM의 Context Window에 유리하다고 생각하여 현재 코드를 짧게, convention rule의 재정의 및 나누는 방식에 대해서 고민하고 있습니다. 목적 : 내화물 시스템 전산화, 설비로부터 받는 시스템 개선 작업
기간 : 2024.06 ~2024.12 / 2023.01 ~2023.06
인원 : 3명 시스템 : 웹뷰 환경 android + jsp(bootstrap)
내 업무 : 웹 화면 개발 작업 + 설비로부터 받는 DB, API 설계 작업
얻은 것 : Android 구조 및 터치 구조, RESTFUL 및 DB 정규화 문제 상황 : 이전 레거시 시스템에서 DB 항목 추가를 고려하지 않은 비정규화되어 있는 컬럼이 있었다. 그냥 레거시 상태로 개발하는 것보다 정규화하기로 하였고 생각보다 많은 공수가 나왔지만 결과물이 만족스러운 개발이었습니다. 목적 : 레거시 환경 테스트구축을 위한 데이터 세팅
기간 : 2025.03 ~ 2025.04
인원 : 개인
시스템 : EJB
내 업무 : 레거시 환경에서 테스팅 하기위한 데이터 세팅작업
얻은 것 : 테스트 시간 평균 30분 남짓 -&gt; 2분
문제상황 : 레거시 환경에서 Backend 테스트 툴인 junit을 도입하기 힘든 상태. flow 가 있어서 flow 대로 테스트가 진행되지 않으면 데이터 세팅이 안되는 테스트 환경, 해당 환경에서 한번 flow가 지나면 해당 데이터는 더이상 쓰지 못하고 앞단에서 만들거나 혹은 직접적으로 데이터를 가져오는 방식으로 개발 필요.
해당 문제를 해결하기 위해 데이터 세팅 스냅샷을 준비. 해당 데이터의 스
고객사에서 프린터 관련해서 아예 세팅을 못 해서 제가 세팅을 하면서 결국 모든건 사용자 위주라는 것을 깨닫게 된 계기가 있었습니다. 프린터 업무의 경우 제 업무가 아니어서 처음에는 기분이 좋지 않았지만 직접 가서 현장에서 근무하시던 매니저분들과 얘기를 나누면서 그동안 통화나 메신저로만 나눈 것이 아닌, 직접적으로 어려운 점을 듣고 현장도 견학 시켜주었습니다. 프린터 설정 관련해서도 네트워크에 대해 공부하는 계기가 되었고, 매니저와 직접적으로 얘기 나누면서 불편한 사항에 관해서도 듣고 개선하는 작업을 했습니다. (일부 화면 프로세스 스텝 관련 문제, 관련 데이터가 흩어진 사항 하나의 화면의 탭 화면 개선)그 뒤로 프로젝트를 진행하면서 한 번씩은 찾아뵙게 됐고 그 과정에서 도메인에 대해서도 깊게 이해하게 됐습니다. 이를 통해 개발만이 아니라 실질적으로 도메인을 알아야 개발을 할 수 있다는 것을 알았고 도메인 지식에 관해서도 재밌거나 불편했던 실 사용자의 의견을 듣고 해결하는 과정에서 결국 가장 도메인에 대해서 잘 아는 사람은 자주 사용하는 사용자라는 걸 알게 되었습니다.]]></description><link>300-resources/330-hr/토스-자소서작성/01.-토스플레이스-자소서.html</link><guid isPermaLink="false">300 Resources/330 HR/토스 자소서작성/01. 토스플레이스 자소서.md</guid><pubDate>Sun, 31 Aug 2025 12:11:48 GMT</pubDate></item><item><title><![CDATA[00. 토스플레이스 JD]]></title><description><![CDATA[ 토스플레이스 Frontend Developer는 초기 멤버 오프라인 결제산업, 결제 생태계의 변화를 기획 Product Owner, Product Designer, Hardware Engineer 등 여러 동료들과 함께 일함 프론트엔드 챕터의 규모적 성장 업무 : 오프라인 결제 시장에서 디지털 혁신을 만들기 위해 매장 운영에 필요한 다양한 문제를 해결 B2B 오프라인 결제 시장에서 마주하는 도전적인 문제들을 처음부터 고민 Point of Sale(POS)는&nbsp;고객이 상품이나 서비스를 구매하고 결제를 완료하는 '판매 시점'을 의미하며, 이 판매 시점의 정보를 관리하는 시스템(POS 시스템)을 통칭합니다.&nbsp;POS 시스템은 매장의 매출, 재고, 고객 데이터 등을 관리하여 효율적인 매장 운영을 돕는 역할을 합니다 사장님 대시보드, 홈페이지 등 데스크탑 웹페이지 및 테이블오더, 픽업오더 등 모바일 웹페이지도 개발 다양한 환경을 모두 대응하는 만큼 독특하고 도전적인 프론트엔드 개발을 경험 주도적으로 문제를 발견하고 분석해 해결할 수 있는 분 고객예약, 포인트 관리, 유지보수하기 쉬운 코드를 작성하고, 견고한 결제로직을 작성하는 것 ]]></description><link>300-resources/330-hr/토스-자소서작성/00.-토스플레이스-jd.html</link><guid isPermaLink="false">300 Resources/330 HR/토스 자소서작성/00. 토스플레이스 JD.md</guid><pubDate>Sun, 31 Aug 2025 09:17:49 GMT</pubDate></item><item><title><![CDATA[20251218140123XXvP-index]]></title><description><![CDATA[<img src="800-references/801-image/2025/12/20251218140123xxvp-index.png" target="_self">]]></description><link>800-references/801-image/2025/12/20251218140123xxvp-index.html</link><guid isPermaLink="false">800 References/801 Image/2025/12/20251218140123XXvP-index.png</guid><pubDate>Thu, 18 Dec 2025 13:57:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Drawing 2025-12-17 00.54.00]]></title><link>excalidraw/drawing-2025-12-17-00.54.00.excalidraw.html</link><guid isPermaLink="false">Excalidraw/Drawing 2025-12-17 00.54.00.excalidraw.md</guid><pubDate>Tue, 16 Dec 2025 15:54:20 GMT</pubDate></item></channel></rss>